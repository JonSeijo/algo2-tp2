\begin{Interfaz}


\textbf{se explica con}: \tadNombre{Mapa}.

\textbf{g\'eneros}: \TipoVariable{map}.

\Title{Operaciones b\'asicas de Mapa}


\InterfazFuncion{CrearMapa}{}{map}%
{$res \igobs crearMapa$}%
[$O(1)$]
[genera una mapa vac\'io.]


\InterfazFuncion{AgregarCoor}{ \In{c}{coord}, \Inout{m}{map}}{}
[$m_0 \igobs m \land \lnot posExistente(c, m_0) $]  
{$m \igobs agregarCoor(c, m_0)$}
[$O(  max(latitud(c), longitud(c), tam(m))^4  )$]
[agrega la coordenada \texttt{c} al mapa \texttt{m}]


\InterfazFuncion{Coordenadas}{\In{m}{map}}{$conj(coord)$}%
{$res \igobs coordenadas(m)$}%
[$O(tam(m))$]  % Algoritmo: recorro la diagonal principal
[devuelve el conjunto de todas las coordenadas de m.]


\InterfazFuncion{PosExistente}{ \In{c}{coord}, \In{m}{map}}{bool}
{$res \igobs posExistente(c, m)$}
[$O(1)$]
[verifica si la coordenada \texttt{c} existe en el mapa \texttt{m}]


\InterfazFuncion{HayCamino}{ \In{c_1}{coord}, \In{c_2}{coord}, \In{m}{map}}{bool}
[$posExistente(c_1, m) \land posExistente(c_2, m) $]
{$res \igobs hayCamino(c_1, c_2, m)$}
[$O(1)$]
[verifica si existe una forma de llegar desde \texttt{$c_1$} a \texttt{$c_2$}]


\Title{Especificacion de auxiliares usadas en la interfaz}
  
\begin{tad}{\tadNombre{Mapa Extension}}
\tadExtiende{\tadNombre{Mapa}}

\tadTitulo{Otras operaciones}{}

\tadOperacion{tam}{mapa/$m$}{nat}{}
\tadOperacion{max}{nat/$x$, nat/$y$}{nat}{}
\tadOperacion{maxLatitud}{conj(coor)/$cs$}{nat}{$\neg \emptyset ?(cs)$}
\tadOperacion{maxLongitud}{conj(coor)/$cs$}{nat}{$\neg \emptyset ?(cs)$}

\tadAxioma{tam(mapa)}
{
\IF
$\#$(coordenadas(mapa)) = 0
THEN
0
ELSE
max(maxLatitud(coordenadas(mapa)), maxLongitud(coordenadas(mapa)))
FI
}

\tadAxioma{max(x ,y)}{\IF x $\geq$ y THEN x ELSE y FI}

\tadAxioma{maxLatitud(cs)}
{
\IF
$\#cs = 1$
THEN
latitud(dameUno(cs))
ELSE
{
\IF latitud(dameUno(cs)) $\geq$ maxLatitud(sinUno(cs))
THEN
damUno(cs)
ELSE
maxLatitud(sinUno(cs))
FI
}
FI}


\tadAxioma{maxLongitud(cs)}
{
\IF
$\#cs = 1$
THEN
longitud(dameUno(cs))
ELSE
{
\IF longitud(dameUno(cs)) $\geq$ maxLongitud(sinUno(cs))
THEN
damUno(cs)
ELSE
maxLongitud(sinUno(cs))
FI
}
FI}


\end{tad}



\end{Interfaz}


\begin{Representacion}

\begin{Estructura}{mapa}[map]
	\begin{Tupla}[map]  
		\tupItem{tam}{nat}
		\tupItem{grilla}{vector(vector(vector(vector(bool)))}  
  	\end{Tupla}
  	
\end{Estructura}

\Title{Invariante de representacion en castellano}

$ $\newline
[Comentarios para la parte de explicacion de estructura] $ $\newline
(decimos que C=(x,y) $"$esta en la grilla$"$ cuando grilla[x][y][x][y] == true) $ $\newline
(decimos que hay camino entre C=(x,y) y C'=(z,w) cuando grilla[x][y][z][w] == true) $ $\newline

(1) Todos los vectores que forman la grilla son de la misma longitud$ $\newline
(2) tam es consistente con la longitud de la grilla $ $\newline
(3) Si vale grilla[x][y][z][w] vale tambien grilla[z][w][x][y] $ $\newline
(4) Si C no esta en la grilla, entonces no tiene camino con ninguna $ $\newline
(5) Si C y C' son contiguas y ambas estan en la grilla, entonces hay camino entre ellas $ $\newline
(6) Si hay camino entre C y C', y hay camino entre C' y C'' entonces hay camino entre C y C'' $ $\newline
Y Si hay camino entre C y C', y NO hay camino entre C' y C'' entonces NO hay camino entre C y C'' $ $\newline

\Title{Invariante de representacion en logica}

(1)
(($\forall i$: nat)(i $<$ long(m.grilla)) $\impluego$ long(m.grilla[i]) = long(m.grilla)) $\yluego$ $ $\newline
(($\forall i, j$: nat)(i $<$ long(m.grilla) $\land$ j $<$ long(m.grilla)) $\impluego$ long(m.grilla[i][j]) = long(m.grilla)) $\yluego$ $ $\newline
(($\forall i, j, k$: nat)(i $<$ long(m.grilla) $\land$ j $<$ long(m.grilla) $\land$ k $<$ long(m.grilla)) $\impluego$ $ $\newline long(m.grilla[i][j][k]) = long(m.grilla))

$ $\newline
(2)
m.tam = long(e.grilla)

$ $\newline
(3) 
(($\forall x, y, z, w$: nat)(x $<$ m.tam $\land$ y $<$ m.tam $\land$ z $<$ m.tam $\land$ w $<$ m.tam) $\impluego$ (grilla[x][y][z][w] = grilla[z][w][x][y])

$ $\newline
(4)
(($\forall x, y$: nat)(x $<$ m.tam $\land$ y $<$ m.tam) $\impluego$ $ $\newline 
($\neg$ grilla[x][y][x][y] $\implies$
($\forall z, w$: nat)(z $<$ m.tam $\land$ w $<$ m.tam) $\impluego$
$\neg$ grilla[x][y][z][w] ))) 

$ $\newline
(5)
HACER
VER COMO PUEDO TOMAR LAS CONTIGUAS VALIDAS SIN OCHENTA IFS
(VER COMO USAR AUXILIARES EN REP)

$ $\newline
(6)
(($\forall a, b, c, d, e, f$: nat)$ $\newline
((a < m.tam $\land$ b < m.tam $\yluego$ m.grilla[a][b][a][b]) $\land$ $ $\newline
(c < m.tam $\land$ d < m.tam $\yluego$ m.grilla[c][d][c][d]) $\land$ $ $\newline
(e < m.tam $\land$ f < m.tam $\yluego$ m.grilla[e][f][e][f]) $\land$ $ $\newline
(a $\neq$ c $\lor$ b $\neq$ d) $\land$ (c $\neq$ e $\lor$ d $\neq$ f)) $ $\newline
$\impluego$ ( $ $\newline
((m.grilla[a][b][c][d] $\land$ m.grilla[c][d][e][f]) $\implies$ m.grilla[a][b][e][f]) $\land $\newline
((m.grilla[a][b][c][d] $\land$ $\neg$m.grilla[c][d][e][f]) $\implies$ $\neg$ m.grilla[a][b][e][f])$ $\newline
)

$ $\newline

% REP  
% REVISAR LOS YLUEGOS
\tadOperacion{Rep}{estr$/m$}{bool}{}%
\tadAxioma{Rep($m$)}
{{(1) $\yluego$ (2) $\yluego$ (3) $\land$ (4) $\land$ (5) $\land$ (6)}} 

$ $\newline
$ $\newline


% ABS

\tadOperacion{Abs}{estr$/m$}{Mapa}{Rep($m$)}%
\tadAxioma{Abs($m$)}
{map : Mapa / ($\forall c$: coord)(c $\in$ coordenadas(map)) $\impluego$ \\
(m.grilla[latitud(c)][longitud(c)][latitud(c)][longitud(c)] = true )}%

\end{Representacion}

$ $\newline
$ $\newline

\begin{Algoritmos}


% crearMapa
\begin{algorithm}[H]
{\textbf{iCrearMapa}()$\to$ $res$ : map}
\begin{algorithmic}[1]
   
  							% Como digo que aca va un vector(vector(v.... vacio? 	
\State $res \gets  \langle 0 , Vacio() \rangle $     COMO SABER QUE VACIO ES UN VECTOR?  \Comment Crear vector vacio es O(1) // $O(1)$

\medskip
\Statex \underline{Complejidad:} $O(1)$

\end{algorithmic}
\end{algorithm}

% coordenadas
\begin{algorithm}[H]
{\textbf{iCoordenadas}(\In{m}{map})$\to$ $res$ : conj(coor)}
\begin{algorithmic}[1]
   
 
\State $res \gets Vacio() $     COMO SABER QUE VACIO ES UN CTO?  \Comment Crear conjunto vacio es O(1) // $O(1)$

\For{$i=0$ to $tam(m)$}
	
	\For{$j=0$ to $tam(m)$}
		
		\If{iPosExistente(i, j)}  \Comment $O(1)$
			
			\State $c \gets NuevaCoor(i, j) $  \Comment $O(1)$			
			\State $Agregar(res, c) $  \Comment $O(log(\#res))$			
			
		\EndIf
		
	\EndFor

\EndFor


\medskip
\Statex \underline{Complejidad:} $O(log(tam(m))*(tam(m))^2)$

\Statex \underline{Justificacion:} Son dos for anidados, por cada iteracion externa, se ejecutan $tam(m)$ iteraciones internas. En total son $(tam(m))^2$ iteraciones. En cada una de ellas, puede ejecutarse el $Agregar(rec, c)$ con complejidad $O(log(\#res))$. $res$ solo contiene coordenadas recorridas por la iteracion, por lo que $\#res <= tam(m)$, es decir $O(log(\#res)) = O(log(tam(m)))$, por lo que la complejidad final es $O(log(tam(m))*(tam(m))^2)$.

\end{algorithmic}
\end{algorithm}

% posExistente

% EXPLICACION:
% CUANDO AGREGO UNA COORDENADA, LA CONECTO EN LA GRILLA CONSIGO MISMA, SIGNIFICANDO QUE EXISTE 
\begin{algorithm}[H]
{\textbf{iPosExistente}(\In{m}{map}, \In{c}{coor})$\to$ $res$ : bool}
\begin{algorithmic}[1]
   

\If{latitud(c) $>=$ tam(m) OR longitud(c) $>=$ tam(m)}
	\State $res \gets false$ \Comment $O(1)$
\Else
	\State $x \gets latitud(c)$ \Comment $O(1)$
	\State $y \gets longitud(c)$ \Comment $O(1)$
	\State $res \gets m.grilla[x][y][x][y]$ \Comment $O(1)$
\EndIf


\medskip
\Statex \underline{Complejidad:} $O(1)$


\end{algorithmic}
\end{algorithm}

% hayCamino

\begin{algorithm}[H]
{\textbf{iHayCamino}(\In{m}{map}, \In {c1}{coor}, \In{c2}{coor})$\to$ $res$ : bool}
\begin{algorithmic}[1]

\State $res \gets grills[latitud(c1)][longitud(c1)][latitud(c2)][longitud(c1)]$ \Comment $O(1)$

\medskip
\Statex \underline{Complejidad:} $O(1)$


\end{algorithmic}
\end{algorithm}


% agregaCoor


%\begin{algorithm}[H]
{\textbf{iAgregaCoor}(\Inout{m}{map}, \In {c}{coor})}
\begin{algorithmic}[1]

\State $maximo \gets max(latitud(c), longitud(c)) $ \Comment $O(1)$

% Si hay una coordenada mayor al maximo
\State \If{maximo $>$ m.tam} \Comment $O(1)$

\State $nGrilla = iCrearGrilla(maximo)$ \Comment $O(maximo^4)$
\State $iCopiarCoordenadas(nGrilla, m.grilla)$ \Comment $O((maximo^4)$
\State $m.grilla = nGrilla$ \Comment $O(maximo^4)$
\State $m.tam = maximo$ \Comment $O(1)$

\EndIf

% La marco consigo misma para decir que la cooordenada existe
\State $m.grilla[latitud(c)][longitud(c)][latitud(c)][longitud(c)] = true$ \Comment $O(1)$
\State $ $

% Creo una grilla de visitadas, todas false
%Vector vacio ver como escribirlo bien
\State $visitados \gets Vacio() $ \Comment $O(1)$
\For{$i = 0$ to $m.tam$}	    \Comment $O(infinito)$
\State $visitadosAux \gets Vacio() $ \Comment $O(1)$	
\For{$j = 0$ to $m.tam$}      \Comment $O(Inifinito)$
\State $visitadosAux.AgregarAtras(false)$ \Comment $O(1)$
\EndFor
\State $visitados.AgregarAtras(visitadosAux)$ \Comment $O(1)$
\EndFor


% aRecorrer es una cola..
\State $aRecorrer \gets Vacio() $ \Comment $O(1)$
\State $aRecorrer.Encolar(c)$ \Comment $O(1)$

\State $ $

\While{$\neg aRecorrer.EsVacia()$}    \Comment Como maximo se recorren todas las coordenadas del mapa // $O((m.tam)^2)$

\State $act \gets Proximo(aRecorrer)$ \Comment Obtener el proximo de la cola es O(1) // $O(1)$
\State $Desencolar(aRecorrer)$ \Comment Eliminar el proximo de la cola es O(1) // $O(1)$

\State $ $


% Reviso la coordenada de la izquierda
\If{$latitud(act) > 0$}      \Comment $O(1)$
\State $tmpX = latitud(coordenadaALaIzquierda(act))$   \Comment $O(1)$
\State $tmpY = longitud(coordenadaALaIzquierda(act))$  \Comment $O(1)$
\If{$\neg visitados[tmpX][tmpY]$}    \Comment $O(1)$
\State $visitados[tmpX][tmpY] = true$    \Comment $O(1)$
	\If{$Existe(coordenadaALaIzquierda(act))$} 	\Comment $O(1)$
		\State $m.Grilla[latitud(c)][longitud(c)][tmpX][tmpY] = true$ \Comment $O(1)$
		\State $m.Grilla[tmpX][tmpY][latitud(c)][longitud(c)] = true$ \Comment $O(1)$
	\EndIf
\EndIf
\EndIf

\State $ $

\If{$longitud(act) > 0$}      \Comment $O(1)$
\State $tmpX = latitud(coordenadaAbajo(act))$   \Comment $O(1)$
\State $tmpY = longitud(coordenadaAbajo(act))$  \Comment $O(1)$
\If{$\neg visitados[tmpX][tmpY]$}    \Comment $O(1)$
\State $visitados[tmpX][tmpY] = true$    \Comment $O(1)$
	\If{$Existe(coordenadaAbajo(act))$} 	\Comment $O(1)$
		\State $m.Grilla[latitud(c)][longitud(c)][tmpX][tmpY] = true$ \Comment $O(1)$
		\State $m.Grilla[tmpX][tmpY][latitud(c)][longitud(c)] = true$ \Comment $O(1)$
	\EndIf
\EndIf
\EndIf

\State $ $


\If{$latitud(act) < m.Tam-1$}      \Comment $O(1)$
\State $tmpX = latitud(coordenadaALaDerecha(act))$   \Comment $O(1)$
\State $tmpY = longitud(coordenadaALaDerecha(act))$  \Comment $O(1)$
\If{$\neg visitados[tmpX][tmpY]$}    \Comment $O(1)$
\State $visitados[tmpX][tmpY] = true$    \Comment $O(1)$
	\If{$Existe(coordenadaALaDerecha(act))$} 	\Comment $O(1)$
		\State $m.Grilla[latitud(c)][longitud(c)][tmpX][tmpY] = true$ \Comment $O(1)$
		\State $m.Grilla[tmpX][tmpY][latitud(c)][longitud(c)] = true$ \Comment $O(1)$
	\EndIf
\EndIf
\EndIf

\State $ $

\If{$longitud(act) < m.Tam-1$}      \Comment $O(1)$
\State $tmpX = latitud(coordenadaArriba(act))$   \Comment $O(1)$
\State $tmpY = longitud(coordenadaArriba(act))$  \Comment $O(1)$
\If{$\neg visitados[tmpX][tmpY]$}    \Comment $O(1)$
\State $visitados[tmpX][tmpY] = true$    \Comment $O(1)$
	\If{$Existe(coordenadaArriba(act))$} 	\Comment $O(1)$
		\State $m.Grilla[latitud(c)][longitud(c)][tmpX][tmpY] = true$ \Comment $O(1)$
		\State $m.Grilla[tmpX][tmpY][latitud(c)][longitud(c)] = true$ \Comment $O(1)$
	\EndIf
\EndIf
\EndIf


\EndWhile

\medskip
\Statex \underline{Complejidad:} $O((max(latitud(c), longitud(c), m.tam))^4)$
\Statex \underline{Justificacion:} Trabajo con matrices de 4 dimensiones, en peor caso hay que redimensionar, en donde se recorren todos los elementos. VER COMO JUSTIFICAR MEJOR


\end{algorithmic}
%\end{algorithm}


% tam

\begin{algorithm}[H]
{\textbf{iTam}(\In{m}{map})$\to$ $res$ : nat}
\begin{algorithmic}[1]

\State $res \gets m.tam$ \Comment $O(1)$

\medskip
\Statex \underline{Complejidad:} $O(1)$

\end{algorithmic}
\end{algorithm}


  
\end{Algoritmos}