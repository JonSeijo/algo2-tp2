\begin{Interfaz}


\textbf{se explica con}: \tadNombre{Mapa}.

\textbf{g\'eneros}: \TipoVariable{map}.

\Title{Operaciones b\'asicas de Mapa}


\InterfazFuncion{crearMapa}{}{map}%
{$res \igobs crearMapa$}%
[$O(1)$]
[genera una mapa vac\'io.]


\InterfazFuncion{agregarCoor}{ \In{c}{coord}, \Inout{m}{map}}{}
[$m_0 \igobs m \land \lnot posExistente(c, m_0) $]  
{$m \igobs agregarCoor(c, m_0)$}
[$O(  max(latitud(c), longitud(c))^4  )$]
[agrega la coordenada \texttt{c} al mapa \texttt{m}]


\InterfazFuncion{coordenadas}{\In{m}{map}}{$conj(coord)$}%
{$res \igobs coordenadas(m)$}%
[$O(tam(m))$]  % Algoritmo: recorro la diagonal principal
[devuelve el conjunto de todas las coordenadas de m.]


\InterfazFuncion{posExistente}{ \In{c}{coord}, \In{m}{map}}{bool}
{$res \igobs posExistente(c, m)$}
[$\O(1)$]
[verifica si la coordenada \texttt{c} existe en el mapa \texttt{m}]


\InterfazFuncion{hayCamino}{ \In{c_1}{coord}, \In{c_2}{coord}, \In{m}{map}}{bool}
[$posExistente(c_1, m) \land posExistente(c_2, m) $]
{$res \igobs hayCamino(c_1, c_2, m)$}
[$O(1)$]
[verifica si existe una forma de llegar desde \texttt{$c_1$} a \texttt{$c_2$}]


\end{Interfaz}

\begin{Representacion}

\begin{Estructura}{mapa}[map]
	\begin{Tupla}[map]  
		\tupItem{tam}{nat}
		\tupItem{grilla}{vector(vector(vector(vector(bool)))}  
  	\end{Tupla}
  	
\end{Estructura}

\RepFc[]{true}



  

  \AbsFc[]{}

\end{Representacion}

\begin{Algoritmos}
\begin{algorithm}[H]

% crearMapa

{\textbf{iCrearMapa}()$\to$ $res$ : map}
\begin{algorithmic}[1]
   
  							% Como digo que aca va un vector(vector(v.... vacio? 	
\State $res \gets  \langle 0 , Vacio() \rangle $     COMO SABER QUE VACIO ES UN VECTOR?  \Comment Crear vector vacio es O(1) // $O(1)$

\medskip
\Statex \underline{Complejidad:} $O(1)$

\end{algorithmic}



{\textbf{iCoordenadas}(\In m : map)$\to$ $res$ : conj(coor)}
\begin{algorithmic}[1]
   
 
\State $res \gets Vacio() $     COMO SABER QUE VACIO ES UN CTO?  \Comment Crear conjunto vacio es O(1) // $O(1)$

\For{$i=0$ to $tam(m)$}
	
	\For{$j=0$ to $tam(m)$}
		
		\If{iEsta(i, j)}  \Comment $O(1)$
			
			\State $c \gets NuevaCoor(i, j) $  \Comment $O(1)$			
			\State $Agregar(res, c) $  \Comment $O(log(\#res))$			
			
		\EndIf
		
	\EndFor

\EndFor


\medskip
\Statex \underline{Complejidad:} $O(log(tam(m))*(tam(m))^2)$

\Statex \underline{Justificacion:} Son dos for anidados, por cada iteracion externa, se ejecutan $tam(m)$ iteraciones internas. En total son $(tam(m))^2$ iteraciones. En cada una de ellas, puede ejecutarse el $Agregar(rec, c)$ con complejidad $O(log(\#res))$. $res$ solo contiene coordenadas recorridas por la iteracion, por lo que $\#res <= tam(m)$, es decir $O(log(\#res)) = O(log(tam(m)))$, por lo que la complejidad final es $O(log(tam(m))*(tam(m))^2)$.

\end{algorithmic}





\end{algorithm}



  
\end{Algoritmos}