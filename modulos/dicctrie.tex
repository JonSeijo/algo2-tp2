
\begin{Interfaz}

  \textbf{par\'ametros formales}\hangindent=2\parindent\\
  \parbox{1.7cm}{\textbf{g\'eneros}} $\alpha$
 
 
  \textbf{se explica con}: \tadNombre{dicc(string, $\alpha$)}, \tadNombre{conj(string)}.

  \textbf{g\'eneros}: \TipoVariable{diccTrie($\alpha$)}.

  \InterfazFuncion{Vacio}{}{diccTrie($\alpha$)}
  {$res$ $\igobs$ vac\'io}
  [$O(1)$]
  [genera un diccionario vac\'io.]

  \InterfazFuncion{Definir}{\Inout{d}{diccTrie($\alpha$)}, \In{s}{string}, \In{a}{$\alpha$}}{}
  [$d$ $\igobs$ $d_0$]
  {$d$ $\igobs$ definir($p$, $a$, $d$)}
  [$O(|P|)$ siendo P la clave mas larga.]
  [define $a$ en $d$ con la clave $s$.]
  [el elemento $a$ se define por copia.]

  \InterfazFuncion{Def?}{\In{p}{string}, \In{d}{diccTrie($\alpha$)}}{bool}
  {$res$ $\igobs$ def?($p$, $d$)}
  [$O(|P|)$ siendo P la clave mas larga.]
  [devuelve \texttt{true} si y s\'olo si la $p$ tiene una definicion en $d$.]

  \InterfazFuncion{Obtener}{\In{p}{string}, \In{d}{diccTrie($\alpha$)}}{$\alpha$}
  [def?($s$, $d$)]
  {alias($res$ $\igobs$ obtener($p$, $d$))}
  [$O(|P|)$ siendo P la clave mas larga.]
  [devuelve el significado de la la clave $p$ en $d$.]
  [$res$ es modificable si y s\'olo si $d$ es modificable.]

  \InterfazFuncion{Borrar}{\In{p}{string}, \Inout{d}{diccTrie($\alpha$)}}{}
  [$d$ $\igobs$ $d_0$ $\land$ def?($s$, $d$)]
  {$d$ $\igobs$ borrar($p$, $d_0$)}
  [$O(|P|)$ siendo P la clave mas larga.]
  [borra la clave $p$ y su significado.]

  \InterfazFuncion{Claves}{\In{d}{diccTrie($\alpha$)}}{conj(string)}
  {$res$ $\igobs$ claves($d$)}
  [$O(1)$]
  [devuelve del conjunto de claves de $d$.]


\end{Interfaz}

\begin{Representacion}
  
  \Title{Representaci\'on del diccTrie}  
  
	En este m\'odulo usamos un trie para definir un diccionario cuyas claves son string.
$ $\newline La idea es que la complejidad de definir y obtener no dependa de la cantidad de claves, si no de la longitud de la clave. Bajando asi la complejidad en peor caso.  
  
  \begin{Estructura}{diccTrie($\alpha$)}[estr]
    \begin{Tupla}[estr]
      \tupItem{raiz}{puntero(nodo)}%
      \tupItem{claves}{conj(string)}%
    \end{Tupla}

    \begin{Tupla}[nodo]
      \tupItem{definicion}{puntero($\alpha$)}%
      \tupItem{siguientes}{arreglo[256](puntero(nodo))}%
      \tupItem{itClave}{puntero(itConj(string))}%
    \end{Tupla}
  \end{Estructura}

\pagebreak

\Title{Invariante de representacion en castellano}
Si raiz es $NULL$ entonces el conjunto de claves es vac\'io. $ $\newline
Si la raiz no es $NULL$ entoncesw el conjunto de claves es no vac\'io. $ $\newline
Todos los elementos del conjunto de claves estan definidios en el diccTrie.
$ $\newline
 
  ~
 
  \AbsFc[]{}[d]{}


\end{Representacion}

\begin{Algoritmos}
  
  
%crear diccTrie
\begin{algorithm}[H]
{\textbf{Vacio}() $\to$ $res$ : diccTrie$(\alpha)$}
\begin{algorithmic}[1]

\State nodo $iRiaz$ $\gets $ $NULL$  \Comment $O(1)$
 
\State conj($string$) $iClaves$ $\gets$ Vacio() \Comment $O(1)$

\State $res$ $\gets$  $\langle$ $iRaiz$, $iClaves$ $\rangle$\Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$
\State \underline{Justificaion:} $O(1)$ $+$ $O(1)$ $+$ $O(1)$

\end{algorithmic}
\end{algorithm}
  

%DEFINIR
\begin{algorithm}[H]
{\textbf{Definir}(\Inout{d}{diccTrie($\alpha$)}, \In{p}{string}, \In{a}{$\alpha$})}
\begin{algorithmic}[1]

\State Puntero(nodo) $actual$ $\gets$ $raiz$ \Comment $O(1)$

\State Nat $i$ $\gets$ $0$ \Comment $O(1)$

\State bool $esNueva$ $\gets$ $true$ \Comment $O(1)$

\While{$i$ $<$ Longitud($p$)}   \Comment Se repite $|p|$ $O(1)$
	
	
	\If{$actual$.$siguientes$[ord($p$[$i$])] $=$ $NULL$} \Comment $O(1)$
		\State nodo $n$ $\gets$ $\langle$ $NULL$, arreglo[$256$]($NULL$), $NULL$ $\rangle$ \Comment $O(1)$
		\State $actual$.$siguientes$[ord($p$[$i$])] $\gets$	 $puntero(n)$ \Comment $O(1)$
		
		\State $esNueva$ $\gets$ $false$ \Comment $O(1)$	 
	
	\EndIf
	
	\State $actual$ $\gets$ $actual$.$siguientes$[ord($p$[$i$])] \Comment $O(1)$

	\State $i$ $\gets$ $i + 1$
\EndWhile 

\If{$actual$.definicion  $\neq$  $NULL$} \Comment $O(1)$
	\State $actual$.definicion $\gets$ $NULL$ \Comment se livera la memoria acupada por definicion $O(1)$
\EndIf
\State $actual$.$definicion$ $\gets$ puntero($a$) \Comment $O(1)$

\If{$esNueva$} \Comment $O(1)$
	\State itConj($string$) $it$ $\gets$  $claves.AgregarRapido(s)$ \Comment $O(1)$
	
	\State $actual$.$itClave$ $\gets$ puntero($it$) \Comment $O(1)$
\EndIf

\medskip
\State \underline{Complejidad:} $O(|P|)$
\State \underline{Justificaion:} Siendo $|P|$ el largo de la clave mas larga, sea cual sea $p$, $|p|$ $\leq$ $|P|$ entonces 	$O(|p|)$ $=$ $O(|P|)$


\end{algorithmic}
\end{algorithm}  
  
  
%DEFINIDO
\begin{algorithm}[H]
{\textbf{Def?}(\In{p}{string}) $\to$ $res$ : $bool$}
\begin{algorithmic}[1]

\State Nat $i$ $\gets$ $0$ \Comment $O(1)$

\State bool $pertenece$ $\gets$ $true$ \Comment $O(1)$

\State puntero(nodo) $actual$ $\gets$ $raiz$ \Comment $O(1)$ 

\While{$i$ $<$ Longitud($p$) $\land$  $pertenece$}   \Comment Se repite $|p|$ $O(1)$
		
	
	\If{$actual$.$siguientes$[ord($p$[$i$])] $=$ $NULL$} \Comment $O(1)$

		\State $pertenece$ $\gets$ $false$ \Comment $O(1)$	 
	
	\EndIf
	
	\State $actual$ $\gets$ $actual$.siguientes[$ord(p[i])$] \Comment $O(1)$

	\State $i$ $\gets$ $i + 1$
\EndWhile 

\If {$actual$.$significado$ $=$ $NULL$} \Comment $O(1)$ 
	\State $pertenece$ $\gets$ $false$ \Comment $O(1)$
\EndIf

\State $res$ $\gets$ $pertenece$ \Comment $O(1)$ 

\medskip
\State \underline{Complejidad:} $O(|P|)$
\State \underline{Justificaion:} Siendo $|P|$ el largo de la clave mas larga, sea cual sea $p$, $|p|$ $\leq$ $|P|$ entonces 	$O(|p|)$ $=$ $O(|P|)$

\end{algorithmic}
\end{algorithm}
  
%OBTENER
\begin{algorithm}[H]
{\textbf{Obtener}(\In{p}{string}, \In{d}{diccTrie($\alpha$)}}) $\to$ $res$ : $\alpha$
\begin{algorithmic}[1]

\State puntero(nodo) $n$ $\gets$ $raiz$ \Comment $O(1)$

\State nat $i$ $\gets$ $0$ \Comment $O(1)$


\While{$i$ $<$ Longitud($p$)}   \Comment Se repite $|p|$ $O(1)$
		

	\State $actual$ $\gets$ $actual$.$siguientes$[ord($p$[$i$])] \Comment $O(1)$

	\State $i$ $\gets$ $i + 1$ \Comment $O(1)$
\EndWhile 


\State $res$ $\gets$ $actual$.$definicion$ \Comment $O(1)$ 

\medskip
\State \underline{Complejidad:} $O(|P|)$
\State \underline{Justificaion:} Siendo $|P|$ el largo de la clave mas larga, sea cual sea $p$, $|p|$ $\leq$ $|P|$ entonces 	$O(|p|)$ $=$ $O(|P|)$

\end{algorithmic}
\end{algorithm}
  
%CLAVES
\begin{algorithm}[H]
{\textbf{Claves}(\In{d}{diccTrie($\alpha$)}}) $\to$ $res$ : $conj(\alpha)$
\begin{algorithmic}[1]

\State $res$ $\gets$ $d$.$claves$ \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$

\end{algorithmic}
\end{algorithm}
  
  
\end{Algoritmos}

