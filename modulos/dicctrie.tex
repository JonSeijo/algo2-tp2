
\begin{Interfaz}

  \textbf{par\'ametros formales}\hangindent=2\parindent\\
  \parbox{1.7cm}{\textbf{g\'eneros}} $\alpha$
 
 
  \textbf{se explica con}: \tadNombre{Diccionario$(string, \alpha)$}, \tadNombre{conj$(string)$}.

  \textbf{g\'eneros}: \TipoVariable{diccTrie$(\alpha)$}.

  \InterfazFuncion{Vacio}{}{diccTrie$(\alpha)$}
  {$res$ $\igobs$ vac\'io}
  [$\Theta(1)$]
  [genera un diccionario vac\'io.]

  \InterfazFuncion{Definir}{\Inout{d}{diccTrie($\alpha$)}, \In{s}{string}, \In{a}{$\alpha$}}{}
  [$d \igobs d_0$]
  {$d$ \igobs definir($s, a, p$)}
  [$\Theta(copy(a))$]
  [define $a$ en $d$ con la clave $s$.]
  [el elemento $a$ se define por copia.]

  \InterfazFuncion{Def?}{\In{s}{string}, \In{d}{diccTrie($\alpha$)}}{bool}
  {$res$ \igobs def?($s$, $p$)}
  [$\Theta(1)$]
  [devuelve \texttt{true} si y s\'olo si la $s$ tiene una definicion en $d$.]

  \InterfazFuncion{Obtener}{\In{s}{string}, \In{d}{diccTrie($\alpha$)}}{$\alpha$}
  [def?($s$, $d$)]
  {alias($res$ \igobs obtener($s$, $d$))}
  [$\Theta(1)$]
  [devuelve el significado de la la clave $s$ en $d$.]
  [$res$ es modificable si y s\'olo si $d$ es modificable.]

  \InterfazFuncion{Borrar}{\In{s}{string}, \Inout{d}{diccTrie($\alpha$)}}{}
  [$d \igobs d_0$ $\land$ def?($s$, $d$)]
  {$d$ \igobs borrar($s$, $d_0$)}
  [$\Theta(1)$]
  [borra la clave $s$ y su significado.]

  \InterfazFuncion{Claves}{\In{d}{diccTrie($\alpha$)}}{conj($string$)}
  {$res$ \igobs claves($d$)}
  [$\Theta(1)$]
  [devuelve del conjunto de claves de $d$.]


\end{Interfaz}

\begin{Representacion}
  
  \begin{Estructura}{diccTrie$(\alpha)$}[estr]
    \begin{Tupla}[estr]
      \tupItem{raiz}{puntero(nodo)}%
      \tupItem{claves}{conj(string)}%
    \end{Tupla}

    \begin{Tupla}[nodo]
      \tupItem{definicion}{puntero($\alpha$)}%
      \tupItem{siguientes}{arreglo[256](puntero(nodo))}%
      \tupItem{itClave}{puntero(itConj(string))}%
    \end{Tupla}
  \end{Estructura}



  \RepFc[]{true}

  ~

  \AbsFc[]{}

\end{Representacion}

\begin{Algoritmos}
  
  
%crear diccTrie
\begin{algorithm}[H]
{\textbf{Vacio}() $\to$ $res$ : diccTrie$(\alpha)$}
\begin{algorithmic}[1]

\State $nodo iRiaz$ $\gets $ $null$  \Comment $O(1)$
 
\State $conj(string) iClaves$ $\gets$ Vacio() \Comment $O(1)$

\State $res$ $\gets$ $<iRaiz, iClaves>$ \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$

\end{algorithmic}
\end{algorithm}
  


\begin{algorithm}[H]
{\textbf{Definir}(\Inout{d}{diccTrie($\alpha$)}, \In{s}{string}, \In{a}{$\alpha$})}
\begin{algorithmic}[1]

\State $Puntero(nodo) actual$ $\gets$ $raiz$ \Comment $O(1)$

\State $Nat i$ $\gets$ $0$ \Comment $O(1)$

\State $bool esNueva$ $\gets$ $true$ \Comment $O(1)$

\While{$i < Longitud(s)$}   \Comment $O()$
	
	
	
	\If{$actual.siguientes[ord(s[i])]$ $==$ $null$} \Comment $O(1)$
		\State $nodo n$ $\gets$ $<null, arreglo[256](null), null>$ \Comment $O(1)$
		\State $actual.siguientes[ord(s[i])]$ $\gets$		 $puntero(n)$ \Comment $O(1)$
		
		\State $esNueva$ $\gets$ $false$ \Comment $O(1)$	 
	
	\EndIf
	
	\State $actual$ $\gets$ $actual.siguientes[ord(s[i])]$ \Comment $O(1)$

	\State $i$ $\gets$ $i + 1$
\EndWhile 

\If{$esNueva$} \Comment $O(1)$
	\State $claves.Agregar(s)$ \Comment $O(1)$
\EndIf

\medskip
\State \underline{Complejidad:} $O(yoque)$

\end{algorithmic}
\end{algorithm}  
  
  
\end{Algoritmos}

