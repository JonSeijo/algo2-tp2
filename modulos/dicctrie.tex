
\begin{Interfaz}

  \textbf{parámetros formales}\hangindent=2\parindent\\
  \parbox{1.7cm}{\textbf{géneros}} $\alpha$\\
 
 
  \textbf{se explica con}: \tadNombre{Diccionario$(string, \alpha)$}, \tadNombre{conj$(string)$}.

  \textbf{géneros}: \TipoVariable{diccTrie$(\alpha)$}.

  \InterfazFuncion{Vacio}{}{diccTrie$(\alpha)$}%
  []%
  {$res$ $\igobs$ vac\'io}%
  [$\Theta(1)$]
  [genera un diccionario vac\'io.]

  \InterfazFuncion{Definir}{\Inout{d}{diccTrie($\alpha$)}, \In{s}{string}, \In{a}{$\alpha$}}{}
  [$d \igobs d_0$]
  {$d$ \igobs definir($s, a, p$)}
  [$\Theta(copy(a))$]
  [defini $a$ en $d$ con la clave $s$.]
  [el elemento $a$ se define por copia.]

  \InterfazFuncion{Def?}{\In{s}{string}, \In{d}{diccTrie($\alpha$)}}{bool}
  {$res$ \igobs def?($s$, $p$)}
  [$\Theta(1)$]
  [devuelve \texttt{true} si y sólo si la $s$ tiene una definicion en $d$.]

  \InterfazFuncion{Obtener}{\In{s}{string}, \In{d}{diccTrie($\alpha$)}}{$\alpha$}
  [def?($s$, $d$)]
  {alias($res$ \igobs obtener($s$, $d$))}
  [$\Theta(1)$]
  [devuelve el significado de la la clave $s$ en $d$.]
  [$res$ es modificable si y sólo si $d$ es modificable.]

  \InterfazFuncion{Borrar}{\In{s}{string}, \Inout{d}{diccTrie($\alpha$)}}{}
  [$d \igobs d_0$ $\land$ def?($s$, $d$)]
  {$d$ \igobs borrar($s$, $d_0$)}
  [$\Theta(1)$]
  [borra la clave $s$ y su significado.]

  \InterfazFuncion{Claves}{\In{d}{diccTrie($\alpha$)}}{conj($string$)}
  {$res$ \igobs claves($d$)}
  [$\Theta(1)$]
  [devuelve del conjjunto de claves de $d$.]


\end{Interfaz}

\begin{Representacion}
  
  \begin{Estructura}{diccTrie$(\alpha)$}[estr]
    \begin{Tupla}[estr]
      \tupItem{raiz}{puntero(nodo)}%
      \tupItem{claves}{conj(string)}%
    \end{Tupla}

    \begin{Tupla}[nodo]
      \tupItem{dato}{puntero($\alpha$)}%
      \tupItem{siguientes}{arreglo[256](puntero(nodo))}%
      \tupItem{itClave}{puntero(itConj(string))}%
    \end{Tupla}
  \end{Estructura}



  \RepFc[][]{true}

  ~

  \AbsFc[]{}[]{}

\end{Representacion}

\begin{Algoritmos}
  
  
%crear diccTrie
\begin{algorithm}[H]
{\textbf{Vacio}() $\to$ $res$ : diccTrie$(\alpha)$}
\begin{algorithmic}[1]

\State $iRiaz$ $\gets $ $null$  \Comment $O(1)$
 
\State $iClaves$ $\gets$ Vacio() \Comment $O(1)$

\State $res$ $\gets$ $<iRaiz, iClaves>$ \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$

\end{algorithmic}
\end{algorithm}
  


\begin{algorithm}[H]
{\textbf{Definir}(\Inout{d}{diccTrie($\alpha$)}, \In{s}{string}, \In{a}{$\alpha$})}
\begin{algorithmic}[1]

\State $Puntero(nodo) actual$ $\gets$ $raiz$ \Comment $O(1)$

\State $Nat i$ $\gets$ $0$ \Comment $O(1)$

\While{$i < Longitud(s)$}   \Comment $O()$
	
	\If{$actual.siguientes[ord(s[i])] \eq null$} \Comment $O()$
		
		
	
	\EndIf

	\State $i$ $\gets$ $i + 1$
\EndWhile 


\medskip
\State \underline{Complejidad:} $O(yoque)$

\end{algorithmic}
\end{algorithm}  
  
  
\end{Algoritmos}

