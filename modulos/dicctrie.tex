
\begin{Interfaz}

  \textbf{par\'ametros formales}\hangindent=2\parindent\\
  \parbox{1.7cm}{\textbf{g\'eneros}} $\alpha$
 
 
  \textbf{se explica con}: \tadNombre{dicc(string, $\alpha$)}, \tadNombre{conj(string)}.

  \textbf{g\'eneros}: \TipoVariable{diccTrie($\alpha$)}.

  \InterfazFuncion{Vacio}{}{diccTrie($\alpha$)}
  {$res$ $\igobs$ vac\'io}
  [$O(1)$]
  [genera un diccionario vac\'io.]

  \InterfazFuncion{Definir}{\Inout{d}{diccTrie($\alpha$)}, \In{s}{string}, \In{a}{$\alpha$}}{}
  [$d$ $\igobs$ $d_0$]
  {$d$ $\igobs$ definir($p$, $a$, $d$)}
  [$O(|P|)$ siendo P la clave mas larga.]
  [define $a$ en $d$ con la clave $s$.]
  [el elemento $a$ se define por copia.]

  \InterfazFuncion{Def?}{\In{p}{string}, \In{d}{diccTrie($\alpha$)}}{bool}
  {$res$ $\igobs$ def?($p$, $d$)}
  [$O(|P|)$ siendo P la clave mas larga.]
  [devuelve \texttt{true} si y s\'olo si la $p$ tiene una definicion en $d$.]

  \InterfazFuncion{Obtener}{\In{p}{string}, \In{d}{diccTrie($\alpha$)}}{$\alpha$}
  [def?($s$, $d$)]
  {alias($res$ $\igobs$ obtener($p$, $d$))}
  [$O(|P|)$ siendo P la clave mas larga.]
  [devuelve el significado de la la clave $p$ en $d$.]
  [$res$ es modificable si y s\'olo si $d$ es modificable.]

  \InterfazFuncion{Borrar}{\In{p}{string}, \Inout{d}{diccTrie($\alpha$)}}{}
  [$d$ $\igobs$ $d_0$ $\land$ def?($s$, $d$)]
  {$d$ $\igobs$ borrar($p$, $d_0$)}
  [$O(|P|)$ siendo P la clave mas larga.]
  [borra la clave $p$ y su significado.]

  \InterfazFuncion{Claves}{\In{d}{diccTrie($\alpha$)}}{conj(string)}
  {$res$ $\igobs$ claves($d$)}
  [$O(1)$]
  [devuelve del conjunto de claves de $d$.]



 
%\begin{tad}{\tadNombre{dicc(string, $\alpha$) Extension}}
%\tadExtiende{\tadNombre{dicc(string, $\alpha$)}}

%\tadTitulo{Otras operaciones}{}

%\tadOperacion{restaUno}{string$/s$, dicc(string, $\alpha$)/$d$}{dicc(string, $\alpha$)}{}


%\tadAxioma{restaUno(s, d)}{}




%\end{tad}


\end{Interfaz}

\pagebreak

\begin{Representacion}
  
  \Title{Representaci\'on del diccTrie}  
  
	En este m\'odulo usamos un trie para definir un diccionario cuyas claves son string.
$ $\newline La idea es que la complejidad de definir y obtener no dependa de la cantidad de claves, si no de la longitud de la clave. Bajando asi la complejidad en peor caso.  
  
  \begin{Estructura}{diccTrie($\alpha$)}[estr]
    \begin{Tupla}[estr]
      \tupItem{raiz}{puntero(nodo)}%
      \tupItem{claves}{conj(string)}%
    \end{Tupla}

    \begin{Tupla}[nodo]
      \tupItem{definicion}{puntero($\alpha$)}%
      \tupItem{siguientes}{arreglo[256](puntero(nodo))}%
      \tupItem{itClave}{puntero(itConj(string))}%
    \end{Tupla}
  \end{Estructura}


\Title{Invariante de representacion en castellano}
Si raiz es $NULL$ entonces el conjunto de claves es vac\'io. $ $\newline
Si la raiz no es $NULL$ entoncesw el conjunto de claves es no vac\'io. $ $\newline
Todos los elementos del conjunto de claves estan definidios en el diccTrie.
$ $\newline
 
 
  \AbsFc[estr]{dicc($\alpha$)}[e]{d : dicc(string, $\alpha$) / ($\forall s$: string)(c $\in$ claves($d$)) $\impluego$ $e$.Definido(s) $=$ $true$ $\land$ obtener($s$, $d$) $=$ $e$.Obtener($s$) }



\end{Representacion}

\begin{Algoritmos}
  
  
%crear diccTrie
\begin{algorithm}[H]
{\textbf{Vacio}() $\to$ $res$ : diccTrie$(\alpha)$}
\begin{algorithmic}[1]

\State puntero(nodo) $iRiaz$ $\gets $ $NULL$  \Comment $O(1)$
 
\State conj($string$) $iClaves$ $\gets$ Vacio() \Comment $O(1)$

\State $res$ $\gets$  $\langle$ $iRaiz$, $iClaves$ $\rangle$\Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$
\State \underline{Justificaion:} $O(1)$ $+$ $O(1)$ $+$ $O(1)$

\end{algorithmic}
\end{algorithm}  

%CLAVES
\begin{algorithm}[H]
{\textbf{Claves}(\In{d}{diccTrie($\alpha$)}}) $\to$ $res$ : $conj(\alpha)$
\begin{algorithmic}[1]

\State $res$ $\gets$ $d$.$claves$ \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$

\end{algorithmic}
\end{algorithm}
  
  
  
%OBTENER
\begin{algorithm}[H]
{\textbf{Obtener}(\In{p}{string}, \In{d}{diccTrie($\alpha$)}}) $\to$ $res$ : $\alpha$
\begin{algorithmic}[1]

\State puntero(nodo) $n$ $\gets$ $raiz$ \Comment $O(1)$

\State nat $i$ $\gets$ $0$ \Comment $O(1)$


\While{$i$ $<$ Longitud($p$)}   \Comment Se repite $|p|$ $O(1)$
		

	\State $actual$ $\gets$ (*$actual$).$siguientes$[ord($p$[$i$])] \Comment $O(1)$

	\State $i$ $\gets$ $i + 1$ \Comment $O(1)$
\EndWhile 


\State $res$ $\gets$ (*$actual$).$definicion$ \Comment $O(1)$ 

\medskip
\State \underline{Complejidad:} $O(|P|)$
\State \underline{Justificaion:} Siendo $|P|$ el largo de la clave mas larga, sea cual sea $p$, $|p|$ $\leq$ $|P|$ entonces 	$O(|p|)$ $=$ $O(|P|)$

\end{algorithmic}
\end{algorithm}
  

%DEFINIR
\begin{algorithm}[H]
{\textbf{Definir}(\Inout{d}{diccTrie($\alpha$)}, \In{p}{string}, \In{a}{$\alpha$})}
\begin{algorithmic}[1]

\State Puntero(nodo) $actual$ $\gets$ $raiz$ \Comment $O(1)$

\State Nat $i$ $\gets$ $0$ \Comment $O(1)$

\State bool $esNueva$ $\gets$ $true$ \Comment $O(1)$

\While{$i$ $<$ Longitud($p$)}   \Comment Se repite $|p|$ $O(1)$
	
	
	\If{$actual$.$siguientes$[ord($p$[$i$])] $=$ $NULL$} \Comment $O(1)$
		\State (*$actual$).$siguientes$[ord($p$[$i$])] $\gets$	 $\&$ $\langle$ $NULL$, arreglo[$256$]($NULL$), $NULL$ $\rangle$  \Comment $O(1)$
		
		\State $esNueva$ $\gets$ $false$ \Comment $O(1)$	 
	
	\EndIf
	
	\State $actual$ $\gets$ (*$actual$).$siguientes$[ord($p$[$i$])] \Comment $O(1)$

	\State $i$ $\gets$ $i + 1$
\EndWhile 

\If{$actual$.definicion  $\neq$  $NULL$} \Comment $O(1)$
	\State $actual$.definicion $\gets$ $NULL$ \Comment se libera la memoria acupada por definicion $O(1)$
\EndIf
\State (*$actual$).$definicion$ $\gets$ $\&$ $a$ \Comment $O(1)$

\If{$esNueva$} \Comment $O(1)$
	\State itConj($string$) $it$ $\gets$  $claves$.AgregarRapido($s$) \Comment $O(1)$
	
	\State (*$actual$).$itClave$ $\gets$ $\&$ $it$ \Comment $O(1)$
\EndIf

\medskip
\State \underline{Complejidad:} $O(|P|)$
\State \underline{Justificaion:} Siendo $|P|$ el largo de la clave mas larga, sea cual sea $p$, $|p|$ $\leq$ $|P|$ entonces 	$O(|p|)$ $=$ $O(|P|)$


\end{algorithmic}
\end{algorithm}  
  
  
%DEFINIDO
\begin{algorithm}[H]
{\textbf{Def?}(\In{p}{string}) $\to$ $res$ : $bool$}
\begin{algorithmic}[1]

\State Nat $i$ $\gets$ $0$ \Comment $O(1)$

\State bool $pertenece$ $\gets$ $true$ \Comment $O(1)$

\State puntero(nodo) $actual$ $\gets$ $raiz$ \Comment $O(1)$ 

\While{$i$ $<$ Longitud($p$) $\land$  $pertenece$}   \Comment Se repite $|p|$ $O(1)$
		
	
	\If{(*$actual$).$siguientes$[ord($p$[$i$])] $=$ $NULL$} \Comment $O(1)$

		\State $pertenece$ $\gets$ $false$ \Comment $O(1)$	 
	
	\EndIf
	
	\State $actual$ $\gets$ (*$actual$).siguientes[$ord(p[i])$] \Comment $O(1)$

	\State $i$ $\gets$ $i + 1$
\EndWhile 

\If {(*$actual$).$significado$ $=$ $NULL$} \Comment $O(1)$ 
	\State $pertenece$ $\gets$ $false$ \Comment $O(1)$
\EndIf

\State $res$ $\gets$ $pertenece$ \Comment $O(1)$ 

\medskip
\State \underline{Complejidad:} $O(|P|)$
\State \underline{Justificaion:} Siendo $|P|$ el largo de la clave mas larga, sea cual sea $p$, $|p|$ $\leq$ $|P|$ entonces 	$O(|p|)$ $=$ $O(|P|)$

\end{algorithmic}
\end{algorithm}



%CLAVES
\begin{algorithm}[H]
{\textbf{Borrar}(\In{p}{string}, \Inout{d}{diccTrie($\alpha$)}})
\begin{algorithmic}[1]

\State bool $borrarRaiz$ $\gets$ $d$.Claves() $=$ 1 \Comment $O(1)$

\State puntero(nodo) $reserva$ $\gets$ $raiz$ \Comment $O(1)$ 
\State nat $rindex$ $\gets$ 0 \Comment $O(1)$

\State puntero(nodo) $actual$ $\gets$ $raiz$ \Comment $O(1)$ 

\State nat $i$ $\gets$ 0 \Comment $O(1)$
\While{$i$ $<$ Longitud($p$) }   \Comment Se repite $|p|$ $O(1)$
		
	
	
	\State $actual$ $\gets$ (*$actual$).siguientes[$ord(p[i])$] \Comment $O(1)$

	\State bool $definido$ $\gets$ $i$ $\neq$ $|p|$ $-$ 1 $\land$ (*$actual$).definicion $\neq$ $NULL$ \Comment $O(1)$

	\If{CuentaHijos($actual$) $>$ 1 $\lor$ $definido$} \Comment $O(1)$

	\State $reserva$ $\gets$ $actual$ \Comment $O(1)$
	\State $rindex$ $\gets$ $i$ $+$ 1 \Comment $O(1)$
	
	\EndIf

	\State $i$ $\gets$ $i + 1$
\EndWhile 


\If{cuentaHijos($actual$) $>$ 1} \Comment $O(1)$

	\State (*$actual$).definicion $\gets$ $NULL$ \Comment se libera la memoria ocupada por la definicion $O(1)$

\EndIf 

\If{cuentaHijos($actual$) $=$ 0} \Comment $O(1)$
	\State BorrarDesde($reserva$, $rindex$) \Comment $O(|P|)$
\EndIf 


\If{borrarRaiz} \Comment $O(1)$
	\State $d$.raiz $\gets$ $NULL$ \Comment se libera la memori ocupada por raiz $O(1)$
\EndIf 





\medskip
\State \underline{Complejidad:} $O(|P|)$
\State \underline{Justificaion:} Siendo $|P|$ el largo de la clave mas larga, sea cual sea $p$, $|p|$ $\leq$ $|P|$ entonces $O(2*|p|)$ $=$	$O(|p|)$ $=$ $O(|P|)$

\end{algorithmic}
\end{algorithm}
  
%CLAVES
\begin{algorithm}[H]
{\textbf{BorrarDesde}(\Inout{desde}{puntero(nodo)}}, \In{a}{nat})
\begin{algorithmic}[1]

\State puntero(nodo) $temp$ $\gets$ raiz \Comment $O(1)$

\State $desde$ $\gets$ (*$desde$).$siguientes$[a] \Comment $O(1)$
\State (*$desde$).$siguientes$[a] $\gets$ $NULL$ \Comment Se libera la memoria ocupada por (*desde).siguientes[a] $O(1)$




\medskip
\State \underline{Complejidad:} $O(|P|)$
\State \underline{Justificaion:} Siendo $|P|$ el largo de la clave mas larga, sea cual sea $p$, $|p|$ $\leq$ $|P|$ entonces 	$O(|p|)$ $=$ $O(|P|)$

\end{algorithmic}
\end{algorithm}
  
  
  
\end{Algoritmos}

