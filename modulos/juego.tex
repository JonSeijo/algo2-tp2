\begin{Interfaz}


\textbf{se explica con}: \tadNombre{Juego}.

\textbf{g\'eneros}: \TipoVariable{juego}.

\Title{Operaciones b\'asicas de Juego}



% GENERADORES %


\InterfazFuncion{crearJuego}{\In{m}{map}}{juego}%
{$res \igobs crearJuego(m)$}%
[$\Theta(INFINITO, VER DESPUES)$]
[genera una juego con el mapa \texttt{m} y sin jugadores.]


\InterfazFuncion{agregarPok\'emon}{\In{p}{pokemon}, \In{c}{coord}, \Inout{j}{juego}}{}
[$j_0 \igobs j \land posExistente(c, mapa(j)) \land p \not \in pokemones(j) Y PUEDOAGREGARPOKEMON() QUE CHECKEE LAS DISTANCIAS $]  
{$j \igobs agregarPokemon(p, c, j_0)  \land p \in pokemones(j)$}
[$\Theta(¡¡completar!!)$]
[agrega pok\'emon \texttt{p} al juego \texttt{j} en la coordenada \texttt{c}.]


\InterfazFuncion{agregarJugador}{\In{j}{juego}}{nat}% REVISAR SI HAY QUE DEVOLVER NAT
[$ j_0 \igobs j $]
{$res \igobs ProxId(j_0) \land j \igobs agregarJugador(j_0)$}%
[$\Theta(\# jugadores(j) REVISAR)$]
[agrega un jugador al juego \texttt{j} con id igual a ProxId(j).]


\InterfazFuncion{conectarse}{\Inout{j}{juego}, \In{c}{coor}, \In{e}{jugador}}{}%
[$j \igobs j_0 \land e \in jugadores(j) \yluego \neg estaConectado(e, j) \land posExistente(c, mapa(j)) $]
{$estaConectado(e, j) Y cambian capturables y contadores y sarasa$}%
[$O(log(EC))$] % Es asi por enunciado
[Conecta al jugador e en la posicion c]


\InterfazFuncion{desconectarse}{\Inout{j}{juego}, \In{e}{jugador}}{}%
[$j \igobs j_0 \land e \in jugadores(j) \yluego estaConectado(e, j)$]
{$\neg estaConectado(e, j) Y cambian capturables y contadores y sarasa$}%
[$O(log(EC))$] % Es asi por enunciado
[Desconecta al jugador e del juego]


\InterfazFuncion{moverse}{\Inout{j}{juego}, \In{c}{coor}, \In{e}{jugador}}{}%
[$j \igobs j_0 \land e \in jugadores(j) \yluego estaConectado(e, j) \land posExistente(c, mapa(j)) $]
{$cambia posicion y cambian capturables y contadores y sarasa$}%
[$O((PC + PS) * |P| + EC * log(EC))$] % Es asi por enunciado
[Mueve al jugador e en la posicion c si es valido, sino sanciona o captura o sarasa]

% OBSERVADORES

%mapa : juego −→ map
\InterfazFuncion{mapa}{\In{j}{juego}}{map}%
[true]
{$res = mapa(j)$}%
[$O(1)$] % HAGAMOS QUE LO DEVUELVA POR REFERENCIA
[Devuelve el mapa del juego]
{Es por referencia, produce aliasing}


%jugadores : juego −→ conj(jugador)
\InterfazFuncion{jugadores}{\In{j}{juego}, \In{e}{jugador}}{ITERADOR}%
[true]
{$TENGO QUE DEVOLVER ITERADOR VER ENUNCIADO$}%
[$O(1)$] % por enunciado. "Ver que siguiente no tiene por que ser O(1)"
[Devuelve un iterador al jugador. Puede borrarse]



%estaConectado : jugador e × juego j −→ bool  {e ∈ jugadores(j)}
\InterfazFuncion{estaConectado}{\In{j}{juego}, \In{e}{jugador}}{bool}%
[$e \in jugadores(j)$]
{$res = estaConectado(e, j)$}%
[$O(1)$] % por enunciado. "Ver que siguiente no tiene por que ser O(1)"
[Devuelve true si el jugador esta conectado]



%sanciones : jugador e × juego j −→ nat {e ∈ jugadores(j)}
\InterfazFuncion{sanciones}{\In{j}{juego}, \In{e}{jugador}}{nat}%
[$e \in jugadores(j)$]
{$res = sanciones(e, j)$}%
[$O(1)$] % por enunciado. 
[Devuelve la cantidad de sanciones de un jugador]



%posicion : jugador e × juego j −→ coor  {e ∈ jugadores(j) ∧ L estaConectado(e, j)}
\InterfazFuncion{posicion}{\In{j}{juego}, \In{e}{jugador}}{coor}%
[$e \in jugadores(j)  \yluego estaConectado(e, j)$]
{$res = posicion(e, j)$}%
[$O(1)$] % por enunciado. 
[Devuelve la posicion actual de un jugador]



%pokémons : jugador e × juego j −→ multiconj(pokémon) {e ∈ jugadores(j)}
%VER
\InterfazFuncion{pokemons}{\In{j}{juego}, \In{e}{jugador}}{multiconj}%
[$e \in jugadores(j)$]
{$res = ITERADOR?? VER ENUNCIADO POCO CLARO$}%
[$O(1)$] % por enunciado. 
[FRUTA]
{TENEMOS QUE HACER EL MULTICONJUNTO? ITERADOR A TUPLA POR ENUNCIADO? VER SI ESTA EN MODS BASICOS SINO QUE SEA VECTOR Y CHAU}



%expulsados : juego −→ conj(jugador)
\InterfazFuncion{expulsados}{\In{j}{juego}}{conj(jugador)}%
[true]
{$res = expulsados(j)$}%
[$O(INFINITO)$] % VER COMO LA IMPLEMENTAMOS   SOSPECHO O(#jugadores). 
[Devuelve un conjunto con los jugadores expulsados]


%posConPokémons : juego −→ conj(coor)
\InterfazFuncion{posConPokemons}{\In{j}{juego}}{conj(coor)}%
[true]
{$res = posConPokemons(j)$}%
[$O(1)$] % Devuelve por referencia el conjunto, asi que habria que ir construyendolo
[Devuelve un conjunto con las posiciones del mapa que tienen pokemons. Aliasing: devuelve el conjunto por referencia]
% ACA DEVOLVEMOS LAS COORDENADAS DE LOS POKENODOS



%pokémonEnPos : coor c × juego j −→ pokémon {c ∈ posConPokémons(j)}
\InterfazFuncion{pokemonEnPos}{\In{j}{juego}, \In{c}{coor}}{pokemon}%
[$c \in posConPokemons(j)$]
{$res = pokemonEnPos(c, j)$}%
[$O(1)$] % Ibamos a guardar el pokemon en la tupla del pokenodo
[Devuelve el pokemon que se encuentra en la posicion c. Sin aliasing, devuelve por copia]


%cantMovimientosParaCaptura : coor c × juego j −→ nat {c ∈ posConPokémons(j)}
\InterfazFuncion{cantMovimientosParaCaptura}{\In{c}{coor}, \In{j}{juego}}{nat}%
[$c \in posConPokemons(j)$] %requiere que c sea pos de pokenodo
{$res = cantMovimientosParaCaptura(c, j)$}%
[$O(1)$] % Ibamos a guardar el contador en la tupla del pokenodo
[Devuelve el numero de movimientos que indican cuando se captura un pokemon]


% otras operaciones publicas

% puedoAgregarPokémon : coor c × juego j −→ bool

% hayPokémonCercano : coor c × juego j −→ bool

% posPókemonCercano : coor c × juego j −→ coor {hayPokémonCercano(c,j)}

% entrenadoresPosibles : coor c × conj(jugador) es × juego j −→ conj(jugador)
% {hayPokémonCercano(c,j) ∧ es ⊆ jugadoresConectados(j)}

% indiceRareza : pokémon p × juego j −→ nat  {p ∈ todosLosPokémons(j)}

% cantPokémonsTotales : juego −→ nat

% cantMismaEspecie : pokémon × multiconj(pokémon) −→ nat


\end{Interfaz}

\begin{Representacion}

% se representa con una tupla(variable, variable, pokenodos, )
 
  \begin{Estructura}{}[]
  \end{Estructura}

  \RepFc[]{true}

  

  \AbsFc[]{}

\end{Representacion}

\begin{Algoritmos}
  
\end{Algoritmos}