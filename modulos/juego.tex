\begin{Interfaz}


\textbf{se explica con}: \tadNombre{Juego}.

\textbf{g\'eneros}: \TipoVariable{juego}.

\Title{Operaciones b\'asicas de Juego}



% GENERADORES %


\InterfazFuncion{crearJuego}{\In{m}{map}}{juego}%
{$res \igobs crearJuego(m)$}%
[$O((Tam(m))^2)$]
[Genera una juego con el mapa \texttt{m} y sin jugadores.]


\InterfazFuncion{agregarPok\'emon}{\In{p}{pokemon}, \In{c}{coord}, \Inout{j}{juego}}{}
[$j_0 \igobs j \land posExistente(c, mapa(j)) \land p \not \in pokemones(j) Y PUEDOAGREGARPOKEMON() QUE CHECKEE LAS DISTANCIAS $]  
{$j \igobs agregarPokemon(p, c, j_0)  \land p \in pokemones(j)$}
[$\Theta(¡¡completar!!)$]
[agrega pok\'emon \texttt{p} al juego \texttt{j} en la coordenada \texttt{c}.]


\InterfazFuncion{agregarJugador}{\In{j}{juego}}{nat}% REVISAR SI HAY QUE DEVOLVER NAT
[$ j_0 \igobs j $]
{$res \igobs ProxId(j_0) \land j \igobs agregarJugador(j_0)$}%
[$O(1)$]
[agrega un jugador al juego \texttt{j} con id igual a ProxId(j).]


\InterfazFuncion{conectarse}{\Inout{j}{juego}, \In{c}{coor}, \In{e}{jugador}}{}%
[$j \igobs j_0 \land e \in jugadores(j) \yluego \neg estaConectado(e, j) \land posExistente(c, mapa(j)) $]
{$estaConectado(e, j) Y cambian capturables y contadores y sarasa$}%
[$O(log(EC))$] % Es asi por enunciado
[Conecta al jugador e en la posicion c]


\InterfazFuncion{desconectarse}{\Inout{j}{juego}, \In{e}{jugador}}{}%
[$j \igobs j_0 \land e \in jugadores(j) \yluego estaConectado(e, j)$]
{$\neg estaConectado(e, j) Y cambian capturables y contadores y sarasa$}%
[$O(log(EC))$] % Es asi por enunciado
[Desconecta al jugador e del juego]


\InterfazFuncion{moverse}{\Inout{j}{juego}, \In{c}{coor}, \In{e}{jugador}}{}%
[$j \igobs j_0 \land e \in jugadores(j) \yluego estaConectado(e, j) \land posExistente(c, mapa(j)) $]
{$cambia posicion y cambian capturables y contadores y sarasa$}%
[$O((PC + PS) * |P| + EC * log(EC))$] % Es asi por enunciado
[Mueve al jugador e en la posicion c si es valido, sino sanciona o captura o sarasa]

% OBSERVADORES

%mapa : juego −→ map
\InterfazFuncion{Mapa}{\In{j}{juego}}{map}%
[true]
{$res = mapa(j)$}%
[$O(1)$] % HAGAMOS QUE LO DEVUELVA POR REFERENCIA
[Devuelve el mapa del juego]
{Es por referencia, produce aliasing}


%jugadores : juego −→ conj(jugador)
\InterfazFuncion{Jugadores}{\In{j}{juego}, \In{e}{jugador}}{ITERADOR}%
[true]
{$TENGO QUE DEVOLVER ITERADOR VER ENUNCIADO$}%
[$O(1)$] % por enunciado. "Ver que siguiente no tiene por que ser O(1)"
[Devuelve un iterador al jugador. Puede borrarse]



%estaConectado : jugador e × juego j −→ bool  {e ∈ jugadores(j)}
\InterfazFuncion{EstaConectado}{\In{j}{juego}, \In{e}{jugador}}{bool}%
[$e \in jugadores(j)$]
{$res = estaConectado(e, j)$}%
[$O(1)$] % por enunciado. "Ver que siguiente no tiene por que ser O(1)"
[Devuelve true si el jugador esta conectado]



%sanciones : jugador e × juego j −→ nat {e ∈ jugadores(j)}
\InterfazFuncion{Sanciones}{\In{j}{juego}, \In{e}{jugador}}{nat}%
[$e \in jugadores(j)$]
{$res = sanciones(e, j)$}%
[$O(1)$] % por enunciado. 
[Devuelve la cantidad de sanciones de un jugador]



%posicion : jugador e × juego j −→ coor  {e ∈ jugadores(j) ∧ L estaConectado(e, j)}
\InterfazFuncion{Posicion}{\In{j}{juego}, \In{e}{jugador}}{coor}%
[$e \in jugadores(j)  \yluego estaConectado(e, j)$]
{$res = posicion(e, j)$}%
[$O(1)$] % por enunciado. 
[Devuelve la posicion actual de un jugador]



%pokémons : jugador e × juego j −→ multiconj(pokémon) {e ∈ jugadores(j)}
%VER
\InterfazFuncion{Pokemons}{\In{j}{juego}, \In{e}{jugador}}{multiconj}%
[$e \in jugadores(j)$]
{$res = ITERADOR?? VER ENUNCIADO POCO CLARO$}%
[$O(1)$] % por enunciado. 
[FRUTA]
{TENEMOS QUE HACER EL MULTICONJUNTO? ITERADOR A TUPLA POR ENUNCIADO? VER SI ESTA EN MODS BASICOS SINO QUE SEA VECTOR Y CHAU}



%expulsados : juego −→ conj(jugador)
\InterfazFuncion{Expulsados}{\In{j}{juego}}{conj(jugador)}%
[true]
{$res = expulsados(j)$}%
[$O(\#jugadores(j))$] % VER COMO LA IMPLEMENTAMOS   SOSPECHO O(#jugadores). 
[Devuelve un conjunto con los jugadores expulsados]


%posConPokémons : juego −→ conj(coor)
\InterfazFuncion{PosConPokemons}{\In{j}{juego}}{conj(coor)}%
[true]
{$res = posConPokemons(j)$}%
[$O(1)$] % Devuelve por referencia el conjunto, asi que habria que ir construyendolo
[Devuelve un conjunto con las posiciones del mapa que tienen pokemons. Aliasing: devuelve el conjunto por referencia]
% ACA DEVOLVEMOS LAS COORDENADAS DE LOS POKENODOS



%pokémonEnPos : coor c × juego j −→ pokémon {c ∈ posConPokémons(j)}
\InterfazFuncion{PokemonEnPos}{\In{j}{juego}, \In{c}{coor}}{pokemon}%
[$c \in posConPokemons(j)$]
{$res = pokemonEnPos(c, j)$}%
[$O(1)$] % Ibamos a guardar el pokemon en la tupla del pokenodo
[Devuelve el pokemon que se encuentra en la posicion c. Sin aliasing, devuelve por copia]


%cantMovimientosParaCaptura : coor c × juego j −→ nat {c ∈ posConPokémons(j)}
\InterfazFuncion{CantMovimientosParaCaptura}{\In{c}{coor}, \In{j}{juego}}{nat}%
[$c \in posConPokemons(j)$] %requiere que c sea pos de pokenodo
{$res = cantMovimientosParaCaptura(c, j)$}%
[$O(1)$] % Ibamos a guardar el contador en la tupla del pokenodo
[Devuelve el numero de movimientos que indican cuando se captura un pokemon]


% otras operaciones publicas

% puedoAgregarPokémon : coor c × juego j −→ bool
\InterfazFuncion{PuedoAgregarPokemon}{\In{c}{coor}, \In{j}{juego}}{bool}%
[true] 
{$res = puedoAgregarPokemon(c, j)$}  % Ver que mucho no me convence
[$O(1)$] 
[Devuelve verdadero si la coordenada es valida y no hay ningun pokemon en el territorio]


% hayPokémonCercano : coor c × juego j −→ bool
\InterfazFuncion{HayPokemonCercano}{\In{c}{coor}, \In{j}{juego}}{bool}%
[true] 
{$res = hayPokemonCercano(c, j)$}  % Ver que mucho no me convence
[$O(1)$] 
[Devuelve verdadero si hay algun pokemon en el territorio]


% posPókemonCercano : coor c × juego j −→ coor {hayPokémonCercano(c,j)}
\InterfazFuncion{PosPokemonCercano}{\In{c}{coor}, \In{j}{juego}}{coor}%
[hayPokemonCercano(c, j)] 
{$res = posPokemonCercano(c, j)$}  % Ver que mucho no me convence
[$O(1)$] 
[Devuelve la posicion del pokemon que esta en territorio]


% entrenadoresPosibles : coor c × conj(jugador) es × juego j −→ conj(jugador)
% {hayPokémonCercano(c,j) ∧ es ⊆ jugadoresConectados(j)}
\InterfazFuncion{EntrenadoresPosibles}{\In{c}{coor},\In{es}{conj(jugador)}, \In{j}{juego}}{coor}%
[hayPokemonCercano(c, j) $\land$ es $\subset$ jugadoresConectados(j)] 
{$res = entrenadoresPosibles(c, es, j)$}  % Ver que mucho no me convence
[$O(1)$] % Se supone que vamos a guardar los posibles en un "AVL" en la coordenada del pokenodo
[Devuelve un conjunto con los entrenadores que estan en condiciones de capturar el pokemon que se encuentra en el rango de c. Que esten en condiciones de capturar significa que estan en rango2 del pokemon y que existe un camino hacia el]


% indiceRareza : pokémon p × juego j −→ nat  {p ∈ todosLosPokémons(j)}
\InterfazFuncion{IndiceRareza}{\In{p}{pokemon}, \In{j}{juego}}{nat}%
[p $\in$ todosLosPokemons(j)] 
{$res = indiceRareza(p, j)$}  % Ver que mucho no me convence
[$O(|P|)$] % es una cuenta, obtener los numeros de p nos cuesta recorrer el trie
[Devuelve el indice de rareza del pokemon dado]


% cantPokémonsTotales : juego −→ nat
\InterfazFuncion{cantPokemonsTotales}{\In{j}{juego}}{nat}%
[true] 
{$res = cantPokemonsTotales(p, j)$}  % Ver que mucho no me convence
[$O(1)$] % tiene que ser O(1) para que el indice de rareza lo calculemos rapido, 
% Podemos guardar el dato como un valor de la estructura del juego
[Devuelve la cantidad de pokemons totales del juego]


% cantMismaEspecie : pokémon × multiconj(pokémon) −→ nat
VERVERVER \\
HAY DIFERENCIA ENTRE LA ESPECIFICACION Y SU SIGNATURA \\
\InterfazFuncion{cantMismaEspecie}{\In{j}{juego}}{nat}%
[true] 
{$res = cantMismaEspecie(j)$}  % Ver que mucho no me convence
[$O(iNFINITO)$] % tiene que ser O(1) para que el indice de rareza lo calculemos rapido, 
% Podemos guardar el dato como un valor de la estructura del juego
[Devuelve la cantidad de pokemons totales del juego]


\end{Interfaz}

~ 

\begin{Representacion}

% se representa con una tupla(variable, variable, pokenodos, )


NO ES DEFINITIVO, PERO PARA IR TENIENDO LA IDEA
 
\begin{Estructura}{Juego}[pokgo]

\begin{Tupla}[pokgo]  
	\tupItem{cantPokemon}{diccTrie}  % Tendria la cantidad total de cada pokemon
	\tupItem{\\ cantPokemonsTotales}{nat} % Para acceso O(1) al total
	\tupItem{\\ map}{mapa}  % Tendria el mapa con el que se crea
	\tupItem{\\ jugadores}{vector(jugStruc)}  % Tendria los datos de los jugadores, o iteradores, VER
	\tupItem{\\ grillaJugs}{vector(vector(lista(jugStruc)))} % Una grilla R2 del tamaño del mapa donde en cada posicion hay un vector de los jugadores que estan en esa posicion
	\tupItem{\\ pokenodos}{vector(vector(puntero(pokeStruc)))}  % Una grilla R2 del tamaño del mapa donde en cada coordenada puede haber un pokenodo (ver en REP que tienen que estar a cierta distancia)
\end{Tupla}
\end{Estructura}

    \begin{Tupla}[pokeStruc]
      \tupItem{poke}{pokemon}
      \tupItem{\\ contador}{nat}%
	  \tupItem{\\ entrenadores}{HEAP(JUGADOR)} % Deberia ser como sea que se llame el modulo, cola_de_prioridadJug o pokeHeap, nose, pero en el fondo seria un heap
    \end{Tupla}
    
    
    \begin{Tupla}[jugStruc]
      \tupItem{id}{nat}
      \tupItem{\\ sanciones}{nat}%
	  \tupItem{\\ conectado}{bool}
	  \tupItem{\\ pos}{coor}
 	  \tupItem{\\ pokemons}{VECTOR(TUPLA(POKEMON, CANTIDAD))} % Hay que ver como nos conviene mantener a los pokemones que capturo el jugador para que no nos arruine la complejidad    
	  \tupItem{\\ indiceEnPokenodo}{nat} % Solo me interesa el indice, un puntero es al pedo
	  \tupItem{\\ iteradorAPos}{itLista(nat)}   
	  \tupItem{\\ cantCapt}{nat}
		
    \end{Tupla}


\RepFc[]{true}

  

\AbsFc[]{}

\end{Representacion}

\begin{Algoritmos}


% crearJuego
\begin{algorithm}[H]
{\textbf{iCrearJuego}(\In{map}{mapa}) $\to$ $res$ : juego}
\begin{algorithmic}[1]

\State dictTrie $cantPokemon \gets $ Vacio()  \Comment $O(1)$
\State nat $cantPokemonsTotales \gets $ 0  \Comment $O(1)$
$ $\newline
\State vector(jugStruc)  $jugs \gets$ Vacio()     \Comment $O(1)$

% Creo la grilla de listas de posiciones (con las listas vacias)
\State vector(vector(lista(jugador)))   $grillaJugs$
$ $\newline
\For{$i \gets 0$ to Tam($map$) $-$ 1} \Comment Se repite Tam(map) veces $O(1)$
	
	\State vector(lista(jugador)) $vectorInterno \gets$ Vacio()  \Comment $O(1)$
	
	\For{$j \gets 0$ to Tam($map$) $-$ 1}  \Comment Se repite Tam(map) veces $O(1)$
		\State lista(jugador) $jugsVacia \gets$ Vacia()   \Comment $O(1)$
		\State AgregarAtras($vectorInterno$, $jugsVacia$) \Comment $O(1)$	 
	\EndFor
	
	AgregarAtras($jugs$, $vectorInterno$)   \Comment $O(1)$

\EndFor
$ $\newline
\State vector(vector(pokeStruc))  $pokenodos \gets$ Vacio()  \Comment $O(1)$

\For{$i \gets 0$ to Tam($map$) $-$ 1}		\Comment Se repite Tam(map) veces $O(1)$
	\State vector(puntero(pokeStruc)) $vectorInterno \gets$ Vacio()  \Comment $O(1)$
	\For{$j \gets 0$ to Tam($map$) $-$ 1}    \Comment Se repite Tam(map) veces $O(1)$
		\State puntero(pokeStruc) $pokePuntero \gets$ NULL   \Comment $O(1)$
		\State AgregarAtras($vectorInterno$, $pokePuntero$)	\Comment $O(1)$
	\EndFor
	AgregarAtras($pokenodos$, $vectorInterno$)   \Comment $O(1)$
\EndFor

\State $res \gets \langle cantPokemon$, $cantPokemonsTotales$, $map$, $jugs$, $grillaJugs$, $pokenodos \rangle$   \Comment $O(1)$

\medskip
\Statex \underline{Complejidad:} $O((Tam(map))^2)$
\Statex \underline{Justificaion:} Se crean 2 vectores de vectores, de Tam(map) elementos tanto el vector interno como el externo $O((Tam(map))^2) + O((Tam(map))^2) = O((Tam(map))^2)$. Crear vectores vacios cuesta O(1) y el mapa lo pasamos por referencia, $O(1) + O((Tam(map))^2) = O((Tam(map))^2)$

\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
{\textbf{iAgregarJugador}(\In{j}{juego}) $\to$ $res$ : nat}
\begin{algorithmic}[1]

\State nat $proxId$ $\gets$ Longitud($j$.jugadores)   \Comment $O(1)$

%\State $nat sanciones \gets 0$ 
%\State $bool conectado \gets false$

% Le pongo (0,0) pero en realidad no importa porque no tenemos que chequear la posicion si esta desconectado)
\State coor $pos$ $\gets$ CrearCoor(0,0) \Comment $O(1)$

\State vector($<$pokemon, nat$>$) $pokes$ $\gets$ Vacio() \Comment $O(1)$
 
% Le pongo 0 pero en realidad no nos importa porque no hay que usarlo si no tiene pokemon cerca
\State nat $indiceEnPokenodo$ $\gets$ 0  \Comment $O(1)$

% Creo el iterador de una lista vacia para poder crearlo
\State lista(nat) $listaDummy$ $\gets$ Vacia() \Comment $O(1)$
\State itLista(nat) $iteradorAPos$ $\gets$ CrearIt($listaDummy$) \Comment $O(1)$

\State $j$.jugadores.AgregarAtras($<proxId$, 0, $false$, $pos$, $pokes$, $indiceEnPokenodo$, $iteradorAPos>$) \Comment $O(1)$

\State $res \gets proxId$ \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$
\State \underline{Justificaion:} Todas las operaciones son O(1)

\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
{\textbf{iConectarse}(\Inout{p}{juego}, \In{c}{coordenada}, \In{j}{jugador})}
\begin{algorithmic}[1]

\State $p$.jugadores[\hspace{0.5mm}j\hspace{0.5mm}].conectado $\gets$ true \Comment $O(1)$
\State itLista(nat) $it$ $\gets$ AgregarAtras($p$.grillaJugs[latitud(c)][longitud(c)], $j$) \Comment $O(1)$
\State $p$.jugadores[j].iteradorAPos $\gets$ $it$ \Comment $O(1)$
\If {$HayPokemonCercano(c, p) \land HayCamino(c, PosPokemonCercano(c, p), Mapa(p))$} \Comment $O(1)$
	\State nat $latPok$ $\gets$ latitud(PosPokemonCercano($c$, $p$)) \Comment $O(1)$
	\State nat $lonPok$ $\gets$ longitud(PosPokemonCercano($c$, $p$)) \Comment $O(1)$
	\State $p$.pokenodos[$latPok$][$lonPok$].contador $\gets$ 0 \Comment $O(1)$
	\State nat $i$ $\gets$ Longitud($p$.pokenodos[$latPok$][$lonPok$] $\to$ entrenadores) \Comment $O(1)$
	\State AgregarAtras($p$.pokenodos[$latPok$][$lonPok$] $\to$ entrenadores, $j$) \Comment $O(1)$ Amortizado
	\While{$(i>0) \land \newline
	(($p$.pokenodos[$latPok$][$lonPok$] \to entrenadores[i].cantCapt < \newline 
	$p$.pokenodos[$latPok$][$lonPok$] \to entrenadores[(i-1)/2].cantCapt) \vee \newline
	(($p$.pokenodos[$latPok$][$lonPok$] \to entrenadores[i].cantCapt = \newline 
	$p$.pokenodos[$latPok$][$lonPok$] \to entrenadores[(i-1)/2].cantCapt) \Rightarrow \newline
	($p$.pokenodos[$latPok$][$lonPok$] \to entrenadores[i].id < \newline
	$p$.pokenodos[$latPok$][$lonPok$] \to entrenadores[(i-1)/2].id)))$} \Comment $O(log(EC))$
		\State jugStruc $aux$ $\gets$ ($p$.pokenodos[$latPok$][$lonPok$] $\to$ entrenadores[i]) \Comment $O(1)$
		\State ($p$.pokenodos[$latPok$][$lonPok$] $\to$ entrenadores[i]) $\gets$ \newline
		($p$.pokenodos[$latPok$][$lonPok$] $\to$ entrenadores[(i-1)/2]) \Comment $O(1)$
		\State ($p$.pokenodos[$latPok$][$lonPok$] $\to$ entrenadores[(i-1)/2]) $\gets$ $aux$ \Comment $O(1)$
		\State ($p$.jugadores[$p$.pokenodos[$latPok$][$lonPok$] $\to$ entrenadores[i].id]) $\gets$ $i$ \Comment $O(1)$
		\State $i$ $\gets$ (i-1)/2 \Comment $O(1)$
	\EndWhile
	\State $p$.jugadores[j].indiceEnPokenodo $\gets$ $i$ \Comment $O(1)$
\EndIf

\medskip
\State \underline{Complejidad:} $O(log(EC))$ Amortizado por uso de vector
\State \underline{Justificaion:} Todas las operaciones de asignaci\'on, acceso a posiciones de vectores y desreferenciaci\'on de punteros son O(1). Las funciones "HayPokemonCercano", "HayCamino", "PosPokemonCercano", "Mapa"\hspace{0.5mm}son O(1). La funci\'on AgregarAtras de lista enlazada es O(1) y AgregarAtras de vector es O(1) amortizado. Suma y divisi\'on entera de nats es O(1).
En el peor caso, el ciclo realiza O(log(EC)) iteraciones: \newline
Sea $n$ la cantidad de elementos del vector de entrenadores (en el peor caso n ser\'a EC), $i$ inicia el ciclo con el valor $n-1$. En el peor de los casos tiene que llegar a 0 para alcanzar la cota y terminar el ciclo. 
Por invariante del ciclo, despu\'es de la k-\'esima iteraci\'on \newline
\newline
$i = \tfrac{n-1}{2^{k}} - \sum_{j=0}^{k-1}\tfrac{1}{2^{k-j}}= \tfrac{n-1}{2^{k}} - \tfrac{2^{k}-1}{2^{k}} = \tfrac{n-2^{k}}{2^{k}}$ \newline
\newline
Calculando el valor de $k$ para que $i$ = 0 y se deje de cumplir la guarda se tiene que: \newline
0 = $\tfrac{n-2^{k}}{2^{k}}$ \newline
0 = $n-2^{k}$ \newline
$2^{k}$ = $n$ \newline
$k$ = $\log_{2}(n)$ \newline
Por lo tanto la cantidad de iteraciones que se necesitan para terminar el ciclo en el peor de los casos es $\log_{2}(EC)$ \newline
\newline
Por \'algebra de \'ordenes, sumando los costos de cada una de las operaciones, queda que la complejidad del algoritmo es $O(log(EC))$ amortizado.


\end{algorithmic}
\end{algorithm}


% cantPokemonsTotales

\begin{algorithm}[H]
{\textbf{iCantPokemonTotales}(\In{j}{juego}) $\to$ $res$ : nat}
\begin{algorithmic}[1]

\State $res \gets$ $j$.cantPokemonsTotales \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$

\end{algorithmic}
\end{algorithm}

% indiceRareza

\begin{algorithm}[H]
{\textbf{iIndiceRareza}(\In{p}{pokemon}, \In{j}{juego}) $\to$ $res$ : nat}
\begin{algorithmic}[1]

\State nat $pokecant \gets$ Obtener(j.cantPokemon, $p$) \Comment $O(|P|)$

\State $res \gets$ 100 $-$ (100 $*$ $pokecant$ $/$ j.cantPokemonsTotales) \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(|P|)$
\State \underline{Justificacion:} j.cantPokemon es un diccionario sobre trie. La complejidad de buscar (y obtener el significado) en peor caso es la longitud de la string mas larga entre sus claves, eso es O($|P|$). j.cantPokemonsTotales es un dato guardado en la estructura del juego, y se accede en O(1). El resto son una resta, multiplicacion y division, que tambien son O(1). O($|P|$) $+$ O(1) $=$ O($|P|$)

\end{algorithmic}
\end{algorithm}

  
\end{Algoritmos}