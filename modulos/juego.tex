\begin{Interfaz}


\textbf{se explica con}: \tadNombre{Juego}.

\textbf{g\'eneros}: \TipoVariable{juego}.

\Title{Operaciones b\'asicas de Juego}



% GENERADORES %


\InterfazFuncion{crearJuego}{\In{m}{map}}{juego}%
{$res \igobs crearJuego(m)$}%
[$\Theta(INFINITO, VER DESPUES)$]
[genera una juego con el mapa \texttt{m} y sin jugadores.]


\InterfazFuncion{agregarPok\'emon}{\In{p}{pokemon}, \In{c}{coord}, \Inout{j}{juego}}{}
[$j_0 \igobs j \land posExistente(c, mapa(j)) \land p \not \in pokemones(j) Y PUEDOAGREGARPOKEMON() QUE CHECKEE LAS DISTANCIAS $]  
{$j \igobs agregarPokemon(p, c, j_0)  \land p \in pokemones(j)$}
[$\Theta(¡¡completar!!)$]
[agrega pok\'emon \texttt{p} al juego \texttt{j} en la coordenada \texttt{c}.]


\InterfazFuncion{agregarJugador}{\In{j}{juego}}{nat}% REVISAR SI HAY QUE DEVOLVER NAT
[$ j_0 \igobs j $]
{$res \igobs ProxId(j_0) \land j \igobs agregarJugador(j_0)$}%
[$\Theta(\# jugadores(j) REVISAR)$]
[agrega un jugador al juego \texttt{j} con id igual a ProxId(j).]


\InterfazFuncion{conectarse}{\Inout{j}{juego}, \In{c}{coor}, \In{e}{jugador}}{}%
[$j \igobs j_0 \land e \in jugadores(j) \yluego \neg estaConectado(e, j) \land posExistente(c, mapa(j)) $]
{$estaConectado(e, j) Y cambian capturables y contadores y sarasa$}%
[$O(log(EC))$] % Es asi por enunciado
[Conecta al jugador e en la posicion c]


\InterfazFuncion{desconectarse}{\Inout{j}{juego}, \In{e}{jugador}}{}%
[$j \igobs j_0 \land e \in jugadores(j) \yluego estaConectado(e, j)$]
{$\neg estaConectado(e, j) Y cambian capturables y contadores y sarasa$}%
[$O(log(EC))$] % Es asi por enunciado
[Desconecta al jugador e del juego]


\InterfazFuncion{moverse}{\Inout{j}{juego}, \In{c}{coor}, \In{e}{jugador}}{}%
[$j \igobs j_0 \land e \in jugadores(j) \yluego estaConectado(e, j) \land posExistente(c, mapa(j)) $]
{$cambia posicion y cambian capturables y contadores y sarasa$}%
[$O((PC + PS) * |P| + EC * log(EC))$] % Es asi por enunciado
[Mueve al jugador e en la posicion c si es valido, sino sanciona o captura o sarasa]

% OBSERVADORES

%mapa : juego −→ map
\InterfazFuncion{mapa}{\In{j}{juego}}{map}%
[true]
{$res = mapa(j)$}%
[$O(1)$] % HAGAMOS QUE LO DEVUELVA POR REFERENCIA
[Devuelve el mapa del juego]
{Es por referencia, produce aliasing}


%jugadores : juego −→ conj(jugador)
\InterfazFuncion{jugadores}{\In{j}{juego}, \In{e}{jugador}}{ITERADOR}%
[true]
{$TENGO QUE DEVOLVER ITERADOR VER ENUNCIADO$}%
[$O(1)$] % por enunciado. "Ver que siguiente no tiene por que ser O(1)"
[Devuelve un iterador al jugador. Puede borrarse]



%estaConectado : jugador e × juego j −→ bool  {e ∈ jugadores(j)}
\InterfazFuncion{estaConectado}{\In{j}{juego}, \In{e}{jugador}}{bool}%
[$e \in jugadores(j)$]
{$res = estaConectado(j, e)$}%
[$O(1)$] % por enunciado. "Ver que siguiente no tiene por que ser O(1)"
[Devuelve true si el jugador esta conectado]



%sanciones : jugador e × juego j −→ nat {e ∈ jugadores(j)}

%posicion : jugador e × juego j −→ coor  {e ∈ jugadores(j) ∧ L estaConectado(e, j)}

%pokémons : jugador e × juego j −→ multiconj(pokémon) {e ∈ jugadores(j)}

%expulsados : juego −→ conj(jugador)

%posConPokémons : juego −→ conj(coor)

%pokémonEnPos : coor c × juego j −→ pokémon {c ∈ posConPokémons(j)}

%cantMovimientosParaCaptura : coor c × juego j −→ nat {c ∈ posConPokémons(j)}

\end{Interfaz}

\begin{Representacion}
 
  \begin{Estructura}{}[]
  \end{Estructura}

  \RepFc[]{true}

  

  \AbsFc[]{}

\end{Representacion}

\begin{Algoritmos}
  
\end{Algoritmos}