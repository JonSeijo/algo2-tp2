\begin{Interfaz}


\textbf{se explica con}: \tadNombre{Juego}.

\textbf{g\'eneros}: \TipoVariable{juego}.

\Title{Operaciones b\'asicas de Juego}



% GENERADORES %


\InterfazFuncion{crearJuego}{\In{m}{map}}{juego}%
{$res \igobs crearJuego(m)$}%
[$O((Tam(m))^2)$]
[Genera una juego con el mapa \texttt{m} y sin jugadores.]


\InterfazFuncion{agregarPok\'emon}{\In{p}{pokemon}, \In{c}{coord}, \Inout{j}{juego}}{}
[$j_0 \igobs j \land posExistente(c, mapa(j)) \land p \not \in pokemones(j) Y PUEDOAGREGARPOKEMON() QUE CHECKEE LAS DISTANCIAS $]  
{$j \igobs agregarPokemon(p, c, j_0)  \land p \in pokemones(j)$}
[$\Theta(¡¡completar!!)$]
[agrega pok\'emon \texttt{p} al juego \texttt{j} en la coordenada \texttt{c}.]


\InterfazFuncion{agregarJugador}{\In{j}{juego}}{nat}% REVISAR SI HAY QUE DEVOLVER NAT
[$ j_0 \igobs j $]
{$res \igobs ProxId(j_0) \land j \igobs agregarJugador(j_0)$}%
[$O(1)$]
[agrega un jugador al juego \texttt{j} con id igual a ProxId(j).]


\InterfazFuncion{conectarse}{\Inout{j}{juego}, \In{c}{coor}, \In{e}{jugador}}{}%
[$j \igobs j_0 \land e \in jugadores(j) \yluego \neg estaConectado(e, j) \land posExistente(c, mapa(j)) $]
{$estaConectado(e, j) Y cambian capturables y contadores y sarasa$}%
[$O(log(EC))$] % Es asi por enunciado
[Conecta al jugador e en la posicion c]


\InterfazFuncion{desconectarse}{\Inout{j}{juego}, \In{e}{jugador}}{}%
[$j \igobs j_0 \land e \in jugadores(j) \yluego estaConectado(e, j)$]
{$\neg estaConectado(e, j) Y cambian capturables y contadores y sarasa$}%
[$O(log(EC))$] % Es asi por enunciado
[Desconecta al jugador e del juego]


\InterfazFuncion{moverse}{\Inout{j}{juego}, \In{c}{coor}, \In{e}{jugador}}{}%
[$j \igobs j_0 \land e \in jugadores(j) \yluego estaConectado(e, j) \land posExistente(c, mapa(j)) $]
{$cambia posicion y cambian capturables y contadores y sarasa$}%
[$O((PC + PS) * |P| + EC * log(EC))$] % Es asi por enunciado
[Mueve al jugador e en la posicion c si es valido, sino sanciona o captura o sarasa]

% OBSERVADORES

%mapa : juego −→ map
\InterfazFuncion{Mapa}{\In{j}{juego}}{map}%
[true]
{$res = mapa(j)$}%
[$O(1)$] % HAGAMOS QUE LO DEVUELVA POR REFERENCIA
[Devuelve el mapa del juego]
{Es por referencia, produce aliasing}


%jugadores : juego −→ conj(jugador)
\InterfazFuncion{Jugadores}{\In{j}{juego}, \In{e}{jugador}}{ITERADOR}%
[true]
{$TENGO QUE DEVOLVER ITERADOR VER ENUNCIADO$}%
[$O(1)$] % por enunciado. "Ver que siguiente no tiene por que ser O(1)"
[Devuelve un iterador al jugador. Puede borrarse]



%estaConectado : jugador e × juego j −→ bool  {e ∈ jugadores(j)}
\InterfazFuncion{EstaConectado}{\In{j}{juego}, \In{e}{jugador}}{bool}%
[$e \in jugadores(j)$]
{$res = estaConectado(e, j)$}%
[$O(1)$] % por enunciado. "Ver que siguiente no tiene por que ser O(1)"
[Devuelve true si el jugador esta conectado]



%sanciones : jugador e × juego j −→ nat {e ∈ jugadores(j)}
\InterfazFuncion{Sanciones}{\In{e}{jugador}, \In{j}{juego}}{nat}%
[$e \in jugadores(j)$]
{$res = sanciones(e, j)$}%
[$O(1)$] % por enunciado. 
[Devuelve la cantidad de sanciones de un jugador]



%posicion : jugador e × juego j −→ coor  {e ∈ jugadores(j) ∧ L estaConectado(e, j)}
\InterfazFuncion{Posicion}{\In{j}{juego}, \In{e}{jugador}}{coor}%
[$e \in jugadores(j)  \yluego estaConectado(e, j)$]
{$res = posicion(e, j)$}%
[$O(1)$] % por enunciado. 
[Devuelve la posicion actual de un jugador]



%pokémons : jugador e × juego j −→ multiconj(pokémon) {e ∈ jugadores(j)}
%VER
\InterfazFuncion{Pokemons}{\In{j}{juego}, \In{e}{jugador}}{multiconj}%
[$e \in jugadores(j)$]
{$res = ITERADOR?? VER ENUNCIADO POCO CLARO$}%
[$O(1)$] % por enunciado. 
[FRUTA]
{TENEMOS QUE HACER EL MULTICONJUNTO? ITERADOR A TUPLA POR ENUNCIADO? VER SI ESTA EN MODS BASICOS SINO QUE SEA VECTOR Y CHAU}



%expulsados : juego −→ conj(jugador)
\InterfazFuncion{Expulsados}{\In{j}{juego}}{conj(jugador)}%
[true]
{$res = expulsados(j)$}%
[$O(J)$]  
[Devuelve un conjunto con los jugadores expulsados]


%posConPokémons : juego −→ conj(coor)
\InterfazFuncion{PosConPokemons}{\In{j}{juego}}{conj(coor)}%
[true]
{$res = posConPokemons(j)$}%
[$O(1)$] % Devuelve por referencia el conjunto, asi que habria que ir construyendolo
[Devuelve un conjunto con las posiciones del mapa que tienen pokemons. Aliasing: devuelve el conjunto por referencia]
% ACA DEVOLVEMOS LAS COORDENADAS DE LOS POKENODOS



%pokémonEnPos : coor c × juego j −→ pokémon {c ∈ posConPokémons(j)}
\InterfazFuncion{PokemonEnPos}{\In{j}{juego}, \In{c}{coor}}{pokemon}%
[$c \in posConPokemons(j)$]
{$res = pokemonEnPos(c, j)$}%
[$O(1)$] % Ibamos a guardar el pokemon en la tupla del pokenodo
[Devuelve el pokemon que se encuentra en la posicion c. Sin aliasing, devuelve por copia]


%cantMovimientosParaCaptura : coor c × juego j −→ nat {c ∈ posConPokémons(j)}
\InterfazFuncion{CantMovimientosParaCaptura}{\In{c}{coor}, \In{j}{juego}}{nat}%
[$c \in posConPokemons(j)$] %requiere que c sea pos de pokenodo
{$res = cantMovimientosParaCaptura(c, j)$}%
[$O(1)$] % Ibamos a guardar el contador en la tupla del pokenodo
[Devuelve el numero de movimientos que indican cuando se captura un pokemon]


% otras operaciones publicas

% puedoAgregarPokémon : coor c × juego j −→ bool
\InterfazFuncion{PuedoAgregarPokemon}{\In{c}{coor}, \In{j}{juego}}{bool}%
[true] 
{$res = puedoAgregarPokemon(c, j)$}  % Ver que mucho no me convence
[$O(1)$] 
[Devuelve verdadero si la coordenada es valida y no hay ningun pokemon en el territorio]


% hayPokémonCercano : coor c × juego j −→ bool
\InterfazFuncion{HayPokemonCercano}{\In{c}{coor}, \In{j}{juego}}{bool}%
[true] 
{$res = hayPokemonCercano(c, j)$}  % Ver que mucho no me convence
[$O(1)$] 
[Devuelve verdadero si hay algun pokemon en el territorio]


% posPókemonCercano : coor c × juego j −→ coor {hayPokémonCercano(c,j)}
\InterfazFuncion{PosPokemonCercano}{\In{c}{coor}, \In{j}{juego}}{coor}%
[hayPokemonCercano(c, j)] 
{$res = posPokemonCercano(c, j)$}  % Ver que mucho no me convence
[$O(1)$] 
[Devuelve la posicion del pokemon que esta en territorio]


% entrenadoresPosibles : coor c × conj(jugador) es × juego j −→ conj(jugador)
% {hayPokémonCercano(c,j) ∧ es ⊆ jugadoresConectados(j)}
\InterfazFuncion{EntrenadoresPosibles}{\In{c}{coor},\In{es}{conj(jugador)}, \In{j}{juego}}{conj(jugador)}%
[hayPokemonCercano(c, j) $\land$ es $\subset$ jugadoresConectados(j)] 
{$res = entrenadoresPosibles(c, es, j)$}  % Ver que mucho no me convence
[$O(1)$] % Se supone que vamos a guardar los posibles en un "AVL" en la coordenada del pokenodo
[Devuelve un conjunto con los entrenadores que estan en condiciones de capturar el pokemon que se encuentra en el rango de c. Que esten en condiciones de capturar significa que estan en rango2 del pokemon y que existe un camino hacia el]


% indiceRareza : pokémon p × juego j −→ nat  {p ∈ todosLosPokémons(j)}
\InterfazFuncion{IndiceRareza}{\In{p}{pokemon}, \In{j}{juego}}{nat}%
[p $\in$ todosLosPokemons(j)] 
{$res = indiceRareza(p, j)$}  % Ver que mucho no me convence
[$O(|P|)$] % es una cuenta, obtener los numeros de p nos cuesta recorrer el trie
[Devuelve el indice de rareza del pokemon dado]


% cantPokémonsTotales : juego −→ nat
\InterfazFuncion{cantPokemonsTotales}{\In{j}{juego}}{nat}%
[true] 
{$res = cantPokemonsTotales(p, j)$}  % Ver que mucho no me convence
[$O(1)$] % tiene que ser O(1) para que el indice de rareza lo calculemos rapido, 
% Podemos guardar el dato como un valor de la estructura del juego
[Devuelve la cantidad de pokemons totales del juego]


% cantMismaEspecie : pokémon × multiconj(pokémon) −→ nat
VERVERVER \\
HAY DIFERENCIA ENTRE LA ESPECIFICACION Y SU SIGNATURA \\
\InterfazFuncion{cantMismaEspecie}{\In{j}{juego}}{nat}%
[true] 
{$res = cantMismaEspecie(j)$}  % Ver que mucho no me convence
[$O(iNFINITO)$] % tiene que ser O(1) para que el indice de rareza lo calculemos rapido, 
% Podemos guardar el dato como un valor de la estructura del juego
[Devuelve la cantidad de pokemons totales del juego]


\end{Interfaz}

~ 

\begin{Representacion}

% se representa con una tupla(variable, variable, pokenodos, )
 
\begin{Estructura}{Juego}[pokgo]

\begin{Tupla}[pokgo]  
    \tupItem{cantPokemon}{diccTrie}  % Tendria la cantidad total de cada pokemon
    \tupItem{\\ cantPokemonsTotales}{nat} % Para acceso O(1) al total
    \tupItem{\\ map}{mapa}  % Tendria el mapa con el que se crea
    \tupItem{\\ jugadores}{vector(jugStruc)}  % Tendria los datos de los jugadores, o iteradores, VER
    \tupItem{\\ grillaJugs}{vector(vector(lista(jugador)))} % Una grilla R2 del tamaño del mapa donde en cada posicion hay una lista de los jugadores que estan en esa posicion
    \tupItem{\\ pokenodos}{vector(vector(puntero(pokeStruc)))}  % Una grilla R2 del tamaño del mapa donde en cada coordenada puede haber un pokenodo (ver en REP que tienen que estar a cierta distancia)
\end{Tupla}
\end{Estructura}

    \begin{Tupla}[pokeStruc]
      \tupItem{poke}{pokemon}
      \tupItem{\\ contador}{nat}%
      \tupItem{\\ entrenadores}{Heap(tupla<id: nat, cantCapt: nat>)} % Deberia ser como sea que se llame el modulo, cola_de_prioridadJug o pokeHeap, nose, pero en el fondo seria un heap
    \end{Tupla}
    
    
    \begin{Tupla}[jugStruc]
      \tupItem{id}{nat}
      \tupItem{\\ sanciones}{nat}%
      \tupItem{\\ conectado}{bool}
      \tupItem{\\ pos}{coor}
      \tupItem{\\ pokemons}{lista(tupla<pokemon, cantidad>)} % Hay que ver como nos conviene mantener a los pokemones que capturo el jugador para que no nos arruine la complejidad    
      \tupItem{\\ iteradorAHeap}{itHeap(tupla<id: nat, cantCapt: nat>)} % Iterador al heap
      \tupItem{\\ iteradorAPos}{itLista(nat)}   
      \tupItem{\\ cantCapt}{nat}
    \end{Tupla}


\RepFc[]{true}

  

\AbsFc[]{}

\end{Representacion}

\begin{Algoritmos}


% crearJuego
\begin{algorithm}[H]
{\textbf{iCrearJuego}(\In{map}{mapa}) $\to$ $res$ : juego}
\begin{algorithmic}[1]

\State dictTrie $cantPokemon \gets $ Vacio()  \Comment $O(1)$
\State nat $cantPokemonsTotales \gets $ 0  \Comment $O(1)$
$ $\newline
\State vector(jugStruc)  $jugs \gets$ Vacio()     \Comment $O(1)$

% Creo la grilla de listas de posiciones (con las listas vacias)
\State vector(vector(lista(jugador)))   $grillaJugs$
$ $\newline
\For{$i \gets 0$ to Tam($map$) $-$ 1} \Comment Se repite Tam(map) veces $O(1)$
    
    \State vector(lista(jugador)) $vectorInterno \gets$ Vacio()  \Comment $O(1)$
    
    \For{$j \gets 0$ to Tam($map$) $-$ 1}  \Comment Se repite Tam(map) veces $O(1)$
        \State lista(jugador) $jugsVacia \gets$ Vacia()   \Comment $O(1)$
        \State AgregarAtras($vectorInterno$, $jugsVacia$) \Comment $O(1)$    
    \EndFor
    
    AgregarAtras($jugs$, $vectorInterno$)   \Comment $O(1)$

\EndFor
$ $\newline
\State vector(vector(pokeStruc))  $pokenodos \gets$ Vacio()  \Comment $O(1)$

\For{$i \gets 0$ to Tam($map$) $-$ 1}       \Comment Se repite Tam(map) veces $O(1)$
    \State vector(puntero(pokeStruc)) $vectorInterno \gets$ Vacio()  \Comment $O(1)$
    \For{$j \gets 0$ to Tam($map$) $-$ 1}    \Comment Se repite Tam(map) veces $O(1)$
        \State puntero(pokeStruc) $pokePuntero \gets$ NULL   \Comment $O(1)$
        \State AgregarAtras($vectorInterno$, $pokePuntero$) \Comment $O(1)$
    \EndFor
    AgregarAtras($pokenodos$, $vectorInterno$)   \Comment $O(1)$
\EndFor

\State $res \gets \langle cantPokemon$, $cantPokemonsTotales$, $map$, $jugs$, $grillaJugs$, $pokenodos \rangle$   \Comment $O(1)$

\medskip
\Statex \underline{Complejidad:} $O((Tam(map))^2)$
\Statex \underline{Justificaion:} Se crean 2 vectores de vectores, de Tam(map) elementos tanto el vector interno como el externo $O((Tam(map))^2) + O((Tam(map))^2) = O((Tam(map))^2)$. Crear vectores vacios cuesta O(1) y el mapa lo pasamos por referencia, $O(1) + O((Tam(map))^2) = O((Tam(map))^2)$

\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
{\textbf{iAgregarJugador}(\In{j}{juego}) $\to$ $res$ : nat}
\begin{algorithmic}[1]

\State nat $proxId$ $\gets$ Longitud($j$.jugadores)   \Comment $O(1)$

%\State $nat sanciones \gets 0$ 
%\State $bool conectado \gets false$

% Le pongo (0,0) pero en realidad no importa porque no tenemos que chequear la posicion si esta desconectado)
\State coor $pos$ $\gets$ CrearCoor(0,0) \Comment $O(1)$

\State vector($<$pokemon, nat$>$) $pokes$ $\gets$ Vacio() \Comment $O(1)$
 
% Le pongo 0 pero en realidad no nos importa porque no hay que usarlo si no tiene pokemon cerca
\State nat $indiceEnPokenodo$ $\gets$ 0  \Comment $O(1)$

% Creo el iterador de una lista vacia para poder crearlo
\State lista(nat) $listaDummy$ $\gets$ Vacia() \Comment $O(1)$
\State itLista(nat) $iteradorAPos$ $\gets$ CrearIt($listaDummy$) \Comment $O(1)$

\State $j$.jugadores.AgregarAtras($<proxId$, 0, $false$, $pos$, $pokes$, $indiceEnPokenodo$, $iteradorAPos>$) \Comment $O(1)$

\State $res \gets proxId$ \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$
\State \underline{Justificaion:} Todas las operaciones son O(1)

\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
{\textbf{iConectarse}(\Inout{p}{juego}, \In{c}{coordenada}, \In{j}{jugador})}
\begin{algorithmic}[1]

\State $p$.jugadores[\hspace{0.5mm}j\hspace{0.5mm}].conectado $\gets$ true \Comment $O(1)$
\State itLista(nat) $it$ $\gets$ AgregarAtras($p$.grillaJugs[latitud(c)][longitud(c)], $j$) \Comment $O(1)$
\State $p$.jugadores[j].iteradorAPos $\gets$ $it$ \Comment $O(1)$
\State $p$.jugadores[j].pos $\gets$ $c$
\If {$HayPokemonCercano(c, p) \land HayCamino(c, PosPokemonCercano(c, p), Mapa(p))$} \Comment $O(1)$
    \State nat $latPok$ $\gets$ latitud(PosPokemonCercano($c$, $p$)) \Comment $O(1)$
    \State nat $lonPok$ $\gets$ longitud(PosPokemonCercano($c$, $p$)) \Comment $O(1)$
    \State ($p$.pokenodos[$latPok$][$lonPok$] $\rightarrow$ contador) $\gets$ 0 \Comment $O(1)$
    \State tupla<id: nat, cantCap: nat> $t \gets$ <j, $p$.jugadores[j].camtCap> 
    \State $itpokenodo \gets Encolar((p.pokenodos[latPok][lonPok] \rightarrow entrenadores) , t)$
\Comment $O(log(EC))$
    \State $p$.jugadores[j].iteradorAHeap $\gets$ $itpokenodo$ \Comment $O(1)$
\EndIf

\medskip
\State \underline{Complejidad:} $O(log(EC))$ 
\State \underline{Justificaion:} Todas las operaciones de asignaci\'on, acceso a posiciones de vectores y desreferenciaci\'on de punteros son O(1). Las funciones "HayPokemonCercano", "HayCamino", "PosPokemonCercano", "Mapa"\hspace{0.5mm}son O(1). La funci\'on AgregarAtras de lista enlazada es O(1). La funci\'on de Heap Encolar es $O(log(EC))$ en el peor caso, y como 1 $\leq$ $log(EC)$, por \'algebra de \'ordenes, sumando todos los costos da que el algoritmo es $O(log(EC))$. Donde EC es la cantidad m\'axima de jugadores esperando a capturar un pokemon, y por lo tanto, la cantidad m\'axima de elementos del heap.


\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
{\textbf{iDesconectarse}(\Inout{p}{juego}, \In{j}{jugador})}
\begin{algorithmic}[1]

\State $p$.jugadores[\hspace{0.5mm}j\hspace{0.5mm}].conectado $\gets$ false \Comment $O(1)$
\State EliminarSiguiente($p$.jugadores[j].iteradorAPos) \Comment $O(1)$
\State $it \gets$ $<NULL, NULL>$ \Comment $O(1)$
\State $p$.jugadores[j].iteradorAPos $\gets$ $it$ \Comment $O(1)$
\State $c \gets$ $p$.jugadores[j].pos 
\If {$HayPokemonCercano(c, p) \land HayCamino(c, PosPokemonCercano(c, p), Mapa(p))$} \Comment $O(1)$
    \State nat $latPok$ $\gets$ latitud(PosPokemonCercano($c$, $p$)) \Comment $O(1)$
    \State nat $lonPok$ $\gets$ longitud(PosPokemonCercano($c$, $p$)) \Comment $O(1)$
    \State Borrar($p$.jugadores[j].iteradorAHeap, ($p$.pokenodos[latPok][lonPok] $\rightarrow$ entrenadores)) \Comment $O(log(EC))$
    \State itHeap(tupla<id: nat, cantCap: nat>) $ith \gets$ $<NULL, NULL>$ \Comment $O(1)$
    \State $p$.jugadores[j].iteradorAHeap $\gets ith$ \Comment $O(1)$
\EndIf
\medskip
\State \underline{Complejidad:} $O(log(EC))$ 
\State \underline{Justificaion:} Todas las operaciones de asignaci\'on, acceso a posiciones de vectores y desreferenciaci\'on de punteros son O(1). Las funciones "HayPokemonCercano", "HayCamino", "PosPokemonCercano", "Mapa"\hspace{0.5mm}son O(1). La funci\'on EliminarSiguiente del iterador de lista es $O(1)$. La funci\'on de itHeap Borrar es $O(log(EC))$ en el peor caso, y como 1 $\leq$ $log(EC)$, por \'algebra de \'ordenes, sumando todos los costos da que el algoritmo es $O(log(EC))$. Donde EC es la cantidad m\'axima de jugadores esperando a capturar un pokemon, y por lo tanto, la cantidad m\'axima de elementos del heap.


\end{algorithmic}
\end{algorithm}

% cantPokemonsTotales

\begin{algorithm}[H]
{\textbf{iCantPokemonTotales}(\In{j}{juego}) $\to$ $res$ : nat}
\begin{algorithmic}[1]

\State $res \gets$ $j$.cantPokemonsTotales \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$

\end{algorithmic}
\end{algorithm}

% indiceRareza

\begin{algorithm}[H]
{\textbf{iIndiceRareza}(\In{p}{pokemon}, \In{j}{juego}) $\to$ $res$ : nat}
\begin{algorithmic}[1]

\State nat $pokecant \gets$ Obtener(j.cantPokemon, $p$) \Comment $O(|P|)$

\State $res \gets$ 100 $-$ (100 $*$ $pokecant$ $/$ j.cantPokemonsTotales) \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(|P|)$
\State \underline{Justificacion:} j.cantPokemon es un diccionario sobre trie. La complejidad de buscar (y obtener el significado) en peor caso es la longitud de la string mas larga entre sus claves, eso es O($|P|$). j.cantPokemonsTotales es un dato guardado en la estructura del juego, y se accede en O(1). El resto son una resta, multiplicacion y division, que tambien son O(1). O($|P|$) $+$ O(1) $=$ O($|P|$)

\end{algorithmic}
\end{algorithm}

% Posicion

\begin{algorithm}[H]
{\textbf{iPosicion}(\In{j}{juego}, \In{e}{jugador}) $\to$ $res$ : coor}
\begin{algorithmic}[1]

\State $res \gets$ $j$.jugadores[$e$].pos \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$
\State \underline{Justificacion:} Todas las operaciones son $O(1)$


\end{algorithmic}
\end{algorithm}


% Sanciones

\begin{algorithm}[H]
{\textbf{iSanciones}(\In{e}{jugador}, \In{j}{juego}) $\to$ $res$ : nat}
\begin{algorithmic}[1]

\State $res \gets$ $j$.jugadores[$e$].sanciones \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$
\State \underline{Justificacion:} Todas las operaciones son $O(1)$


\end{algorithmic}
\end{algorithm}

% entrenadoresPosibles
% por precondicion estan conectados

\begin{algorithm}[H]
{\textbf{iEntrenadoresPosibles}(\In{c}{coor}, \In{ec}{conj(jugador)}, \In{j}{juego}) $\to$ $res$ : conj(jugador)}
\begin{algorithmic}[1]

\State coor $pokeCoor \gets$ PosPokemonCercano($c$, $j$) \Comment $O(1)$
\State puntero(pokeStruc) $pokePuntero \gets j.pokeNodos[longitud(pokeCoor)][latitud(pokeCoor)]$ \Comment $O(1)$

\State itConj(jugador) $itPosibles \gets$ CrearIt($ec$) \Comment $O(1)$

\While{HaySiguiente($itPosibels$)}   \Comment O($Cardinal(ec) * O(HaySiguiente) * Cardinal(jugsEnNodo)$)
    
    % Asumo que tengo una forma de recorrer el heap
    \State itHeap $itJugsEnNodo \gets$ CrearIt(($*pokePuntero$).entrenadores)     \Comment Depende del HEAP $O(Inifinito)$
    
    \While{HaySiguiente($itJugsEnNodo$)}   \Comment O($HaySiguiente * \#jugsEnNodo$)

        \If{Siguiente($itPosibles$) = Siguiente($itJugsEnNodo$)}   \Comment Depende del HEAP $O(Inifinito)$
        
            \State Agregar($res$, Siguiente($itPosible$))
    
        \EndIf
        
        \State Avanzar($itJugsEnNodo$))
    
    \EndWhile
    
    \State Avanzar($itPosible$)   \Comment()



\EndWhile


\medskip
\State \underline{Complejidad:} $O(|P|)$
\State \underline{Justificacion:} 

\end{algorithmic}
\end{algorithm}


$ $\newline
$ $\newline
$ $\newline
% hayPokemonCercano
%\begin{algorithm}[H]
{\textbf{iHayPokemonCercano}(\In{c}{coor}, \In{j}{juego}) $\to$ $res$ : coor}
\begin{algorithmic}[1]

\State nat $x \gets$ latitud(c)    \Comment $O(1)$
\State nat $y \gets$ longitud(c)   \Comment $O(1)$

% j.pokenodos[x][y] != NULL   =>  pos con pokemon

\State bool $hayPokemon \gets$ false    \Comment $O(1)$

\If{j.pokenodos[$x$][$y$] $\neq$ NULL}     \Comment $O(1)$
    \State $hayPokemon \gets$ true
\EndIf

\If{$x > 0$}
    \If{j.pokenodos[$x-1$][$y$] $\neq$ NULL}     \Comment $O(1)$
        \State $hayPokemon \gets$ true
    \EndIf

    \If{$y > 0$}

        \If{j.pokenodos[$x-1$][$y-1$] $\neq$ NULL}     \Comment $O(1)$
            \State $hayPokemon \gets$ true
        \EndIf

    \EndIf

    % tam(m) no puede ser 0 porque existe una coordenada al menos (x,y)
    \If{$y < tam(m) - 1$}
        \If{j.pokenodos[$x-1$][$y+1$] $\neq$ NULL}     \Comment $O(1)$
            \State $hayPokemon \gets$ true
        \EndIf
    \EndIf

    \If{$x-1 > 0$}
        \If{j.pokenodos[$x-2$][$y$] $\neq$ NULL}     \Comment $O(1)$
            \State $hayPokemon \gets$ true
        \EndIf
    \EndIf

\EndIf

\If{$y > 0$}

    \If{j.pokenodos[$x$][$y-1$] $\neq$ NULL}     \Comment $O(1)$
        \State $hayPokemon \gets$ true
    \EndIf

    \If{$y-1 > 0$}

        \If{j.pokenodos[$x$][$y-2$] $\neq$ NULL}     \Comment $O(1)$
            \State $hayPokemon \gets$ true
        \EndIf

    \EndIf

\EndIf

\If{$y < tam(m) - 1$}

    \If{j.pokenodos[$x$][$y+1$] $\neq$ NULL}     \Comment $O(1)$
        \State $hayPokemon \gets$ true
    \EndIf


    \If{$tam(m) > 1 \land y < tam(m) - 2$}
        \If{j.pokenodos[$x$][$y+2$] $\neq$ NULL}     \Comment $O(1)$
            \State $hayPokemon \gets$ true
        \EndIf


    \EndIf

\EndIf

\If{$x < tam(m) - 1$}
    \If{j.pokenodos[$x+1$][$y$] $\neq$ NULL}     \Comment $O(1)$
        \State $hayPokemon \gets$ true
        \EndIf

    \If{$y > 0$}
        \If{j.pokenodos[$x+1$][$y-1$] $\neq$ NULL}     \Comment $O(1)$
            \State $hayPokemon \gets$ true
        \EndIf
    \EndIf

    \If{$y < tam(m)-1$}
        \If{j.pokenodos[$x+1$][$y+1$] $\neq$ NULL}     \Comment $O(1)$
            \State $hayPokemon \gets$ true
        \EndIf

    \EndIf
\EndIf

\If{$tam(m) > 1 \land x < tam(m) - 2$}
    \If{j.pokenodos[$x+2$][$y$] $\neq$ NULL}     \Comment $O(1)$
        \State $hayPokemon \gets$ true
    \EndIf
\EndIf

\State $res \gets hayPokemon$

\medskip
\State \underline{Complejidad:} $O(1)$ % por enunciado
\State \underline{Justificacion:} Reviso 13 posiciones O(1)

\end{algorithmic}
%\end{algorithm}

$ $\newline
$ $\newline
$ $\newline


% posPokemonCercano

%\begin{algorithm}[H]
{\textbf{iPosPokemonCercano}(\In{c}{coor}, \In{j}{juego}) $\to$ $res$ : coor}
\begin{algorithmic}[1]

\State nat $x \gets$ latitud(c)    \Comment $O(1)$
\State nat $y \gets$ longitud(c)   \Comment $O(1)$

% j.pokenodos[x][y] != NULL   =>  pos con pokemon

\State coor $coorConPokemon$    \Comment $O(1)$

\If{j.pokenodos[$x$][$y$] $\neq$ NULL}     \Comment $O(1)$
    \State $coorConPokemon \gets CrearCoor(x, y)$    \Comment $O(1)$
\EndIf

\If{$x > 0$}
    \If{j.pokenodos[$x-1$][$y$] $\neq$ NULL}     \Comment $O(1)$
        \State $coorConPokemon \gets CrearCoor(x, y)$    \Comment $O(1)$
    \EndIf

    \If{$y > 0$}

        \If{j.pokenodos[$x-1$][$y-1$] $\neq$ NULL}     \Comment $O(1)$
            \State $coorConPokemon \gets CrearCoor(x, y)$    \Comment $O(1)$
        \EndIf

    \EndIf

    % tam(m) no puede ser 0 porque existe una coordenada al menos (x,y)
    \If{$y < tam(m) - 1$}
        \If{j.pokenodos[$x-1$][$y+1$] $\neq$ NULL}     \Comment $O(1)$
            \State $coorConPokemon \gets CrearCoor(x, y)$    \Comment $O(1)$
        \EndIf
    \EndIf

    \If{$x-1 > 0$}
        \If{j.pokenodos[$x-2$][$y$] $\neq$ NULL}     \Comment $O(1)$
            \State $coorConPokemon \gets CrearCoor(x, y)$    \Comment $O(1)$
        \EndIf
    \EndIf

\EndIf

\If{$y > 0$}

    \If{j.pokenodos[$x$][$y-1$] $\neq$ NULL}     \Comment $O(1)$
        \State $coorConPokemon \gets CrearCoor(x, y)$    \Comment $O(1)$
    \EndIf

    \If{$y-1 > 0$}

        \If{j.pokenodos[$x$][$y-2$] $\neq$ NULL}     \Comment $O(1)$
            \State $coorConPokemon \gets CrearCoor(x, y)$    \Comment $O(1)$
        \EndIf

    \EndIf

\EndIf

\If{$y < tam(m) - 1$}

    \If{j.pokenodos[$x$][$y+1$] $\neq$ NULL}     \Comment $O(1)$
        \State $coorConPokemon \gets CrearCoor(x, y)$    \Comment $O(1)$
    \EndIf


    \If{$tam(m) > 1 \land y < tam(m) - 2$}
        \If{j.pokenodos[$x$][$y+2$] $\neq$ NULL}     \Comment $O(1)$
            \State $coorConPokemon \gets CrearCoor(x, y)$    \Comment $O(1)$
        \EndIf


    \EndIf

\EndIf

\If{$x < tam(m) - 1$}
    \If{j.pokenodos[$x+1$][$y$] $\neq$ NULL}     \Comment $O(1)$
        \State $coorConPokemon \gets CrearCoor(x, y)$    \Comment $O(1)$
        \EndIf

    \If{$y > 0$}
        \If{j.pokenodos[$x+1$][$y-1$] $\neq$ NULL}     \Comment $O(1)$
            \State $coorConPokemon \gets CrearCoor(x, y)$    \Comment $O(1)$
        \EndIf
    \EndIf

    \If{$y < tam(m)-1$}
        \If{j.pokenodos[$x+1$][$y+1$] $\neq$ NULL}     \Comment $O(1)$
            \State $coorConPokemon \gets CrearCoor(x, y)$    \Comment $O(1)$
        \EndIf

    \EndIf
\EndIf

\If{$tam(m) > 1 \land x < tam(m) - 2$}
    \If{j.pokenodos[$x+2$][$y$] $\neq$ NULL}     \Comment $O(1)$
        \State $coorConPokemon \gets CrearCoor(x, y)$    \Comment $O(1)$
    \EndIf
\EndIf

\State $res \gets coorConPokemon$

\medskip
\State \underline{Complejidad:} $O(1)$ % por enunciado
\State \underline{Justificacion:} Reviso 13 posiciones O(1)

\end{algorithmic}
%\end{algorithm}



% puedoAgregarPokemon

\begin{algorithm}[H]
{\textbf{iPuedoAgregarPokemon}(\In{c}{coor}, \In{j}{juego}) $\to$ $res$ : bool}
\begin{algorithmic}[1]

\State bool $puedo \gets$ false  \Comment $O(1)$

\If{PosExistente(c, j.mapa)}   \Comment $O(1)$
    \If{$\neg$ HayPokemonCercano(c, j)}   \Comment $O(1)$
        \State $puedo \gets$ true        \Comment $O(1)$
    \EndIf
\EndIf

\State $res \gets puedo$  \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$
\State \underline{Justificacion:} Todas las operaciones son O(1)

\end{algorithmic}
\end{algorithm}


% cantMovimientosParaCaptura

\begin{algorithm}[H]
{\textbf{iCantMovimientosParaCaptura}(\In{c}{coor}, \In{j}{juego}) $\to$ $res$ :    nat}
\begin{algorithmic}[1]

\State puntero(pokeStruc) $pokenodo \gets$ j.pokenodos[latitud($c$)][longitud($c$)] \Comment $O(1)$
\State $res \gets$ (*pokenodo).contador  \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$
\State \underline{Justificacion:} Todas las operaciones son O(1)

\end{algorithmic}
\end{algorithm}


% expulsados

\begin{algorithm}[H]
{\textbf{iExpulsados}(\In{j}{juego}) $\to$ $res$ : conj(jugador)}
\begin{algorithmic}[1]

\For{$nat i \gets$ 0 to Longitud(j.jugadores) $-$ 1}   \Comment $O(J)$
    \If{j.jugadores[$i$].sanciones $\geq$ 5}   \Comment $O(1)$
        AgregarRapido(res, j.jugadores[$i$].id)  \Comment $O(1)$        
    \EndIf
\EndFor

\medskip
\State \underline{Complejidad:} $O(J)$
\State \underline{Justificacion:} Aplico operaciones que son O(1) la cantidad de veces que ejecuto el ciclo. El ciclo se ejecuta J veces (porque j.jugadores tiene todos los jugadores que fueron agregados) Entonces es O(J), siendo J la cantidad de jugadores que fueron agregados.

\end{algorithmic}
\end{algorithm}


% pokemons

VER TODO EL TEMILLA DEL MULTICONJUNTO... HAY QUE HACERLO?? 

\begin{algorithm}[H]
{\textbf{iPokemons}(\In{e}{jugador}, \In{j}{juego}) $\to$ $res$ : multiconj(jugador)}
\begin{algorithmic}[1]

\State $res \gets $ CrearIt(j.jugadores[e].pokemons) \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$
\State \underline{Justificacion:} Devuelvo un iterador

\end{algorithmic}
\end{algorithm}

  
\end{Algoritmos}