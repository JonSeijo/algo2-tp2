\begin{Interfaz}
\subsection{Interfaz}

\textbf{se explica con}: \tadNombre{Juego}.

\textbf{g\'eneros}: \TipoVariable{juego}.

\Title{Operaciones b\'asicas de Juego}



% GENERADORES %


\InterfazFuncion{CrearJuego}{\In{m}{map}}{juego}%
{$res \igobs crearJuego(m)$}%
[$O((tam(m))^2)$]
[Genera una juego con el mapa \texttt{m} y sin jugadores.]


\InterfazFuncion{agregarPok\'emon}{\In{p}{pokemon}, \In{c}{coord}, \Inout{j}{juego}}{}
[$j_0$ $\igobs$ $j$ $\land$ posExistente($c$, mapa($j$)) $\land$ $p$ $\not \in$ pokemones($j$) $\land$ PuedoAgregarPokemon($c$, $j$)]  
{$j \igobs agregarPokemon(p, c, j_0)  \land p \in pokemones(j)$}
[$O(|P| + EC*log(EC))$ ]
[Agrega pok\'emon \texttt{p} al juego \texttt{j} en la coordenada \texttt{c}.]


\InterfazFuncion{AgregarJugador}{\In{j}{juego}}{nat}
[$ j_0 \igobs j $]
{$res$ $\igobs$ ProxId($j_0$) $\land$ $j$ $\igobs$ agregarJugador($j_0$)}%
[$O(J)$]
[Agrega un jugador al juego \texttt{j} con id igual a ProxId($j$).]


\InterfazFuncion{Conectarse}{\In{e}{jugador}, \In{c}{coor}, \Inout{j}{juego}}{}%
[$j_0$ $\igobs$ $j$ $\land$ $e$ $\in$ jugadores($j$) $\yluego$ $\neg$ estaConectado($e$, $j$) $\land $ posExistente($c$, mapa($j$))]
{$j$ $\igobs$ conectarse($e$, $c$, $j_0$)}%
[$O(log(EC))$] % Es asi por enunciado
[Conecta al jugador e en la posicion c.]


\InterfazFuncion{Desconectarse}{\In{e}{jugador}, \Inout{j}{juego}}{}%
[$j_0$ $\igobs$ $j$ $\land$ $e$ $\in$ jugadores($j$) $\yluego$ estaConectado($e$, $j$)]
{$j$ $\igobs$ desconectarse($e$, $j_0$)}%
[$O(log(EC))$] % Es asi por enunciado
[Desconecta al jugador e del juego.]


\InterfazFuncion{Moverse}{\In{e}{jugador}, \In{c}{coor}, \Inout{j}{juego}}{}%
[$j_0 \igobs j \land e \in jugadores(j) \yluego estaConectado(e, j) \land posExistente(c, mapa(j)) $]
{$j$ $\igobs$ moverse($e$, $c$, $j_0$)}%
[$O((PC + PS) * |P| + log(EC))$] % Es asi por enunciado
[Mueve al jugador e en la posicion c si es valido y captura si debe, sino sanciona o expulsa.]

% OBSERVADORES

%mapa : juego −→ map
\InterfazFuncion{Mapa}{\In{j}{juego}}{map}%
{$res$ $=$ mapa($j$)}%
[$O(1)$] % HAGAMOS QUE LO DEVUELVA POR REFERENCIA
[Devuelve el mapa del juego.]
[Es por referencia, produce aliasing.]


%jugadores : juego −→ conj(jugador)
\InterfazFuncion{Jugadores}{\In{j}{juego}}{itConj(jugador)}%
{$res$ $\igobs$ jugadores($j$)}%
[$O(1)$] % por enunciado. "Ver que siguiente no tiene por que ser O(1)"
[Devuelve un iterador a los jugadores del juego]
[Modificar el conjunto que se devuelve modifica la estructura del juego.]



%estaConectado : jugador e × juego j −→ bool  {e ∈ jugadores(j)}
\InterfazFuncion{EstaConectado}{\In{j}{juego}, \In{e}{jugador}}{bool}%
[$e$ $\in$ jugadores($j$)]
{$res$ $=$ estaConectado($e$, $j$)}%
[$O(1)$] % por enunciado. "Ver que siguiente no tiene por que ser O(1)"
[Devuelve true si el jugador esta conectado.]



%sanciones : jugador e × juego j −→ nat {e ∈ jugadores(j)}
\InterfazFuncion{Sanciones}{\In{e}{jugador}, \In{j}{juego}}{nat}%
[$e$ $\in$ jugadores($j$)]
{$res$ $=$ sanciones($e$, $j$)}%
[$O(1)$] % por enunciado. 
[Devuelve la cantidad de sanciones de un jugador.]



%posicion : jugador e × juego j −→ coor  {e ∈ jugadores(j) ∧ L estaConectado(e, j)}
\InterfazFuncion{Posicion}{\In{j}{juego}, \In{e}{jugador}}{coor}%
[$e$ $\in$ jugadores($j$)  $\yluego$ estaConectado($e$, $j$)]
{$res$ $=$ posicion($e$, $j$)}%
[$O(1)$] % por enunciado. 
[Devuelve la posicion actual de un jugador.]



%pokémons : jugador e × juego j −→ multiconj(pokémon) {e ∈ jugadores(j)}
%VER
\InterfazFuncion{Pokemons}{\In{j}{juego}, \In{e}{jugador}}{iterDiccString(nat)}%
[$e$ $\in$ jugadores($j$)]
{$res$ $\igobs$ crearIt($j$.jugadores[$e$].pokemons)}%
[$O(1)$] % por enunciado. 
[Devuelve un iterador a los pokemons capturados por el jugador.]
[El iterador se invalida si el conjunto de claves del DiccString (que contiene a los pokemons del jugador) cambia.]



%expulsados : juego −→ conj(jugador)
\InterfazFuncion{Expulsados}{\In{j}{juego}}{conj(jugador)}%
{$res$ $=$ expulsados($j$)}%
[$O(J)$]  
[Devuelve un conjunto con los jugadores expulsados.]


%posConPokémons : juego −→ conj(coor)
\InterfazFuncion{PosConPokemons}{\In{j}{juego}}{conj(coor)}%
{alias($res$ $\igobs$ posConPokemons($j$))}%
[$O(1)$] % Devuelve por referencia el conjunto, asi que habria que ir construyendolo
[Devuelve un conjunto con las posiciones del mapa que tienen pokemons.]
[El conjunto es devuelto por referencia.]


%pokémonEnPos : coor c × juego j −→ pokémon {c ∈ posConPokémons(j)}
\InterfazFuncion{PokemonEnPos}{\In{j}{juego}, \In{c}{coor}}{pokemon}%
[$c$ $\in$ posConPokemons($j$)]
{$res = pokemonEnPos(c, j)$}%
[$O(1)$] % Ibamos a guardar el pokemon en la tupla del pokenodo
[Devuelve el pokemon que se encuentra en la posicion c.]


%cantMovimientosParaCaptura : coor c × juego j −→ nat {c ∈ posConPokémons(j)}
\InterfazFuncion{CantMovimientosParaCaptura}{\In{c}{coor}, \In{j}{juego}}{nat}%
[$c$ $\in$ posConPokemons($j$)] %requiere que c sea pos de pokenodo
{$res$ $=$ cantMovimientosParaCaptura($c$, $j$)}%
[$O(1)$] % Ibamos a guardar el contador en la tupla del pokenodo
[Devuelve el numero de movimientos que indican cuando se captura un pokemon.]


% otras operaciones publicas

% puedoAgregarPokémon : coor c × juego j −→ bool
\InterfazFuncion{PuedoAgregarPokemon}{\In{c}{coor}, \In{j}{juego}}{bool}%
{$res$ $=$ puedoAgregarPokemon($c$, $j$)}  % Ver que mucho no me convence
[$O(1)$] 
[Devuelve verdadero si la coordenada es valida y no hay ningun pokemon en el territorio.]


% hayPokémonCercano : coor c × juego j −→ bool
\InterfazFuncion{HayPokemonCercano}{\In{c}{coor}, \In{j}{juego}}{bool}%
{$res$ $=$ hayPokemonCercano($c$, $j$)}  % Ver que mucho no me convence
[$O(1)$] 
[Devuelve verdadero si hay algun pokemon en el territorio.]


% posPókemonCercano : coor c × juego j −→ coor {hayPokémonCercano(c,j)}
\InterfazFuncion{PosPokemonCercano}{\In{c}{coor}, \In{j}{juego}}{coor}%
[hayPokemonCercano(c, j)] 
{$res$ $=$ posPokemonCercano($c$, $j$)}  % Ver que mucho no me convence
[$O(1)$] 
[Devuelve la posicion del pokemon que esta en territorio.]


% entrenadoresPosibles : coor c × conj(jugador) es × juego j −→ conj(jugador)
% {hayPokémonCercano(c,j) ∧ es ⊆ jugadoresConectados(j)}

\InterfazFuncion{EntrenadoresPosibles}{\In{c}{coor}, \In{es}{conj(jugador)}, \In{j}{juego}}{conj(jugador)}%
[hayPokemonCercano(c, j) $\land$ es $\subset$ jugadoresConectados(j)] 
{$res$ $=$ entrenadoresPosibles($c$, $es$, $j$)}  % Ver que mucho no me convence
[$O$(Longitud($ec$) * $EC$)] 
[De todos los jugadores de la entrada ec, devuelve un conjunto con los entrenadores que estan en condiciones de capturar el pokemon que se encuentra en el rango de c. Que esten en condiciones de capturar significa que estan en rango2 del pokemon y que existe un camino hacia el.]


% indiceRareza : pokémon p × juego j −→ nat  {p ∈ todosLosPokémons(j)}
\InterfazFuncion{IndiceRareza}{\In{p}{pokemon}, \In{j}{juego}}{nat}%
[$p$ $\in$ todosLosPokemons($j$)] 
{$res = indiceRareza(p, j)$}  % Ver que mucho no me convence
[$O(|P|)$] % es una cuenta, obtener los numeros de p nos cuesta recorrer el trie
[Devuelve el indice de rareza del pokemon dado.]


% cantPokémonsTotales : juego −→ nat
\InterfazFuncion{cantPokemonsTotales}{\In{j}{juego}}{nat}%
{$res$ $=$ cantPokemonsTotales($p$, $j$)}  % Ver que mucho no me convence
[$O(1)$] % tiene que ser O(1) para que el indice de rareza lo calculemos rapido, 
% Podemos guardar el dato como un valor de la estructura del juego
[Devuelve la cantidad de pokemons totales del juego.]


% cantMismaEspecie : pokémon × multiconj(pokémon) −→ nat

\InterfazFuncion{cantMismaEspecie}{\In{p}{pokemon}, \In{j}{juego}}{nat}
[$p$ $\in$ todosLosPokemons($j$)] 
{$res$ = cantMismaEspecie($p$, $j$)}  % Ver que mucho no me convence
[$O(|p|)$] % tiene que ser O(1) para que el indice de rareza lo calculemos rapido, 
% Podemos guardar el dato como un valor de la estructura del juego
[Devuelve la cantidad de pokemons totales del juego.]


\end{Interfaz}

~ 

\begin{Representacion}
\subsection{Representacion}

``cantPokemonnos'' nos dice, dado un pokemon, la cantidad total de ese pokemon que hay en el juego: salvajes y capturados por jugadores no eliminados. \\
La cantidad total de pokemons puede obtenerse sumando las cantidades de los pokemons individualmente, pero manteni\'endolo de forma separada (cantPokemonsTotales) se puede tener un acceso r\'apido, \'util para calcular el \'indice de rareza. \\

Los jugadores est\'an representados por un vector de jugadores: ``jugadores'', aprovechando que agregar jugador tiene que ser O(J), y usamos que cada id del jugador se corresponde con el \'indice de su posici\'on en el vector. \\
Los elementos en este vector de jugadores son tuplas que las llamamos ``jugStruc'', que contienen todos los datos que son relevantes para un jugador. \\
Ademas de este vector de jugadores, que contiene los datos de todos los jugadores (est\'en eliminados o no), tenemos tambien ``jugadoresNoEliminados'', que es un conjunto de, justamente, los jugadoresNoEliminados. De esta manera podemos devolver en O(1) un iterador a estos jugadores, usando el iterador ya existente de un conjunto, y no tenemos que procuparnos por ir filtrando los eliminados mientras el usuario usa el iterador. Un problema que surge es que cuando se elimina un jugador, necesitamos eliminar el jugador de esta lista (r\'apidamente). Es por esto que para cada jugador, mantenemos un iterador a la posicion del jugador en ese conjunto: ``iterAJuego''. \\

Los pokemons que captur\'o estan representados por un diccionario, donde para cada pokemon capturado dice la cantidad capturada de esa especie. ``cantCapt'' es la cantidad total de pokemones capturados. Puede obtenerse sumando la cantidad capturada de cada pokemon, pero decidimos mantenerla as\'i para poder armar rapidamente la cola de prioridades en la zona de captura.\\

En caso que est\'e conectado, podemos comprobar su posici\'on, pero para cumplir complejidades pedidas, muchas veces necesitamos acceder r\'apidamente a los jugadores desde una posici\'on. Recorrer todos los jugadores y filtrarlos por la coordenada buscada no es eficiente, y por este motivo existe ``grillaJugs''.  \\

En ``grillaJugs'', dada una posici\'on nos d\'a una lista con los jugadores que tienen esa posici\'on. Cuando el jugador deja de estar en esa posici\'on, queremos sacarlo de esa lista, pero puede pasar que en una misma posici\'on haya muchos jugadores, y para eliminar al que queremos no ser\'ia barato, porque habria que recorrer la lista. Para solucionar esto, guardamos un iterador a la posici\'on del jugador en esa lista (``iteradorAPos'') aprovechando que borrar con este iterador de lista es O(1). \\

Algo similar sucede con los pokemons salvajes, queremos acceder a ellos por coordenada, para saber por ejemplo, si hay alguno en un rango cercano. Por este motivo los guardamos en ``pokenodos'', una grilla que los contiene. ``pokenodos'' es en realidad una grilla de punteros, donde el puntero es NULL si no hay pokemon en esa coordenada.\\
Si no es NULL, el puntero apunta a un ``pokeStruc'', que contiene el pokemon salvaje, un contador para saber cuanto falta para la captura, y una cola de entrenadores. Los entrenadores de la cola son todos aquellos jugadores en condiciones de capturar al pokemon. Es una cola de prioridades porque queremos obtener el m\'inimo de forma eficiente, para poder tener r\'apido al jugador que queremos actualizar en caso de captura. \\

Si el jugador elegido para que capture sale del radio, necesitamos el siguiente m\'inimo de forma eficiente, y esta es la principal raz\'on por la que elegimos tener una cola de prioridad y no una variable el pokeStruc que indique quien es el elegido para capturar. \\

La situaci\'on no es tan feliz si un jugador cualquiera se va del radio, puesto que habria que buscarlo en la cola, y esto rompe las complejidades pedidas. Para resolver esto, en cada jugador (en caso que este en condiciones de capturar) mantenemos un iterador a su posicion correspondiente en esa cola (``itAEntrenadores''). De esta manera, dado un jugador podemos eliminarlo de los entrenadores del pokeStruc de forma eficiente (en tiempo logaritmico, por la forma en que implementamos la cola), cumpliendo las complejidades pedidas.\\


\begin{Estructura}{Juego}[pokgo]

\begin{Tupla}[pokgo]  
    \tupItem{cantPokemon}{diccString(nat)}  % Tendria la cantidad total de cada pokemon
    \tupItem{\\ cantPokemonsTotales}{nat} % Para acceso O(1) al total
    \tupItem{\\ map}{mapa}  % Tendria el mapa con el que se crea
    \tupItem{\\ jugadores}{vector(jugStruc)}  % Tendria los datos de TODOS los jugadores
    \tupItem{\\ jugadoresNoEliminados}{conj(jugador)}  % Tiene los jugadores que no fueron eliminados
    \tupItem{\\ grillaJugs}{vector(vector(lista(jugador)))} % Una grilla R2 del tamaño del mapa donde en cada posicion hay una lista de los jugadores que estan en esa posicion
    \tupItem{\\ pokenodos}{vector(vector(puntero(pokeStruc)))}  % Una grilla R2 del tamaño del mapa donde en cada coordenada puede haber un pokenodo (ver en REP que tienen que estar a cierta distancia)
    \tupItem{\\ posPokemons}{conj(coor)}
\end{Tupla}
\end{Estructura}

    \begin{Tupla}[pokeStruc]
      \tupItem{poke}{pokemon}
      \tupItem{\\ contador}{nat}%
      \tupItem{\\ entrenadores}{colaEntr} % Deberia ser como sea que se llame el modulo, cola_de_prioridadJug o pokeHeap, nose, pero en el fondo seria un heap
    \end{Tupla}
    
    
    \begin{Tupla}[jugStruc]
      \tupItem{id}{nat}
      \tupItem{\\ sanciones}{nat}%
      \tupItem{\\ conectado}{bool}
      \tupItem{\\ pos}{coor}
      \tupItem{\\ pokemons}{diccString(nat)} % Hay que ver como nos conviene mantener a los pokemones que capturo el jugador para que no nos arruine la complejidad    
      \tupItem{\\ iteradorAEntrenadores}{itcolaEntrenador} % Iterador al heap
      \tupItem{\\ iteradorAPos}{itLista(nat)}   
      \tupItem{\\ iteradorAJuego}{itConj(jugador)}   
      \tupItem{\\ cantCapt}{nat}
    \end{Tupla}


$ $\newline
$ $\newline

\Title{Invariante de representacion}

$ $\newline

(0) El indice de la posicion del vector es igual al id del juegador en ese indice (de esto se desprende que los ids son unicos) $ $\newline

($\forall i$: nat)((i $<$ Longitud(j.jugadores)) $\impluego$ j.jugadores[$i$].id = i )
$ $\newline


(1) El jugador e esta en j.jugadoresNoEliminados sii no esta eliminado $ $\newline
($\forall e$: jugador)($e \in$ $j$.jugadoresNoEliminados $\iff$ ($e$ < longitud($j$.jugadores) $\land$ $j$.jugadores[$e$].sanciones < 5)
$ $\newline

(2) Todo jugador de j.jugadores que este conectado, tiene una posicion que es una coordenada existente en el mapa $ $\newline

%($\forall e$: jugador) ((esJugadorConectado($e$)) $\impluego$ PosExistente(j.jugadores[$e$].pos, j.mapa))
($\forall jug$: jugStruc) ((esJugadorConectado($jug$)) $\impluego$ PosExistente($jug$.pos, j.mapa))
$ $\newline


(3) Dimensiones de la grillaJugs (vector de vectores) es igual al tama\~no del mapa $ $\newline

Longitud($j$.grillaJugs) = Tam($j$.mapa) $\yluego$ 
($\forall i$: nat) (($i <$ Logitud(j.grillaJugs)) Longitud($j$.grillaJugs[i]) = Tam($j$.mapa)) 
$ $\newline


(4) No hay elementos repetidos en las listas de grillaJugs  $ $\newline

($\forall x, y$: nat) ((enRango($x$, $y$, $j$.mapa) $\impluego$ sinRepetidos($j$.grillaJugs[$x$][$y$]))
$ $\newline

(5) Todo jugador que esta conectado tiene su id en la lista que se encuentra en grillaJugs para su posicion  $ $\newline

%($\forall e:$ jugador) (esJugadorConectado($e$, $j$) $\impluego$ \\
% $j$.jugadores[$e$].id $\in$ $j$.grillaJugs[latitud($j$.jugadores[$e$])][longitud($j$.jugadores[$e$])])

($\forall jug:$ jugStruc) (esJugadorConectado($jug$, $j$) $\impluego$ \\
  $jug$.id $\in$ $j$.grillaJugs[latitud($jug$.pos)][longitud($jug$.pos)])
  
$ $\newline

(6) Toda id en toda lista de grillaJugs es un de un jugador del juego que este conectado  $ $\newline

($\forall x, y:$ nat) (enRango($x$, $y$, $j$.mapa) $\impluego$ \\
  ($\forall i:$ nat) ($i \leq$ Longitud($j$.grillaJugs[$x$][$y$]) \\
    $j$.jugadores($j$.grillaJugs[$x$][$y$][$i$]).conectado

$ $\newline

(7) iteradorAPos apunta al elemento correcto (misma id) en la lista de grillaJugs correspondiente a su pos $ $\newline

($\forall jug:$ jugStruc) ( esJugadorConectado($jug$, $j$) $\impluego$ Siguiente($jug$.iteradorAPos) = $jug$.id )

$ $\newline

(8) cantCapt es consistente con las cantidades de su lista de pokemons capturados $ $\newline
$ $\newline
($\forall jug:$ jugStruc) (esJugadorNoEliminado($jug$, $j$) $\impluego$ $jug$.cantCapt = sumaSignif($jug$.pokemons))
$ $\newline


(9) cantPokemonTotales es igual a la sumatoria de todos los significados del diccionario $ $\newline
$j$.cantPokemonTotales = sumaSignif($j$.cantPokemon)
$ $\newline
%(MMMMM NO, creo que se deduce) Los pokemons que un jugador (NO eliminado) capturo, esta en las claves del diccionario del juego con un significado $>$ 0 $ $\newline

(10) Para todo pokemon del diccionario, la cantidad que hay es igual a la suma de los salvajes mas los capturados por jugadores (no eliminados) $ $\newline
($\forall p: $ pokemon) (($p \in$ Claves($j$.cantPokemon)) $\impluego$ \\
  Obtener($p$, $j$.cantPokemon) = cantSalvajes($p$, $j$) $+$ sumaPokesCapturados($p$, $j$))

$ $\newline

(11) Para todo pokemon salvaje, su cantidad es la resta entre la cantidad total en el diccionario menos los capturados por jugadores (no eliminados) $ $\newline

($\forall p: $ pokemon) (($p \in$ Claves($j$.cantPokemon)) $\impluego$ \\ 
  (cantSalvajes($p$, $j$) = Obtener($p$, $j$.cantPokemon) $-$ sumaPokesCapturados($p$, $j$)))
$ $\newline


(12) Dimensiones de pokenodos (vector de vectores) es igual al tama\~no del mapa $ $\newline

longitud($j$.pokenodos) = tam($j$.mapa) $\yluego$ 
($\forall i$: nat) (($i <$ Logitud(j.pokenodos)) Longitud($j$.pokenodos[i]) = Tam($j$.mapa)) 
$ $\newline

(13) Todo pokenodo que tenga un pokestruc, esta en una coordenada valida del mapa y es coherente con j.posPokemons$ $\newline

($\forall x, y$: nat) ((enRango($x$, $y$, $j.mapa$) $\yluego$ $j$.pokenodos[$x$][$y$] $\neg$ NULL) \\
  $\impluego$ (posExistente(crearCoordenada($x$, $y$), $j$.mapa) $\land$ crearCoordenada($x$, $y$) $\in$ $j$.posPokemons)) $\land$ \\
($\forall c$: coor) (($c \in j$.posPokemons) $\impluego$ (enRango(latitud($c$), longitud($c$), $j.mapa$) \\
$\yluego$ $j$.pokenodos[latitud($c$)][longitud($c$)] $\neg$ NULL))
$ $\newline


(14) No hay pokenodos con pokestrucs que esten a distancia menor a 5 $ $\newline

($\forall x, y$: nat) ((enRango($x$, $y$, $j.mapa$) $\yluego$ $j$.pokenodos[$x$][$y$] $\neq$ NULL) $ \land$\\
($\forall z, w$: nat) ((enRango($z$, $w$, $j.mapa$) $\yluego$ $j$.pokenodos[$z$][$w$] $\neq$ NULL) $\land$ \\
($x \neq z \land y \neq w$) $\impluego$  distEuclidea(crearCoordenada($x$, $y$), crearCoordenada($z$, $w$)) > 25)

$ $\newline

(15) El contador de todo pokenodo es $<$ 10 $ $\newline

($\forall x, y$: nat) ((enRango($x$, $y$, $j.mapa$) $\yluego$ $j$.pokenodos[$x$][$y$] $\neq$ NULL) \\
  $\impluego$ (*($j$.pokenodos[$x$][$y$])).contador < 10)

$ $\newline

(16) Todo pokestruc tiene un pokemon que esta bien definido $ $\newline
($\forall x, y$: nat) ((enRango($x$, $y$, $j.mapa$) $\yluego$ $j$.pokenodos[$x$][$y$] $\neq$ NULL) \\
  $\impluego$ Def?((*($j$.pokenodos[$x$][$y$])).poke), $j$.cantPokemon)

$ $\newline

% jonathan: creo que con solo hablar del minimo del heap es suficiente, porque es lo unico que necesitamos en realidad. El resto de los jugadores del heap estan solo para poder actualizar al minimo rapido

(17) Para todas los pokenodos con pokemons, de todos jugadores validos, conectados, que esten en un radio menor a 2, con un camino a la posicion del pokemon, el que tiene menos cantidad de pokemons capturados (y menor id en caso de empate) se corresponde con el Proximo de la Cola de entrenadores $ $\newline

($\forall x, y$: nat) ((enRango($x$, $y$, $j.mapa$) $\yluego$ $j$.pokenodos[$x$][$y$] $\neq$ NULL) \\
  (minJ(entrenadoresPosibles(crearCoordenada($x$, $y$), jugadoresConectados($j$), $j$) = \\
  (proximo(*($j$.pokenodos[$x$][$y$]).entrenadores)).id) $\land$ \\
  ((proximo(*($j$.pokenodos[$x$][$y$]).entrenadores)).cant = $j$.jugadores[proximo(*($j$.pokenodos[$x$][$y$]).entrenadores)).id].cantcapt))
  
$ $\newline

(18) Todo jugador valido conectado que tenga un pokemon cercano, si tiene un camino hacia ese pokemon entonces su iterador a entrenadores esta bien definido $ $\newline

($\forall jug$: jugStruc) (esJugadorConectado($jug$, $j$) $\land$ hayPokemonCercano($jug$.pos, $j$) $\impluego$ \\
hayCamino(posPokemonCercano($j.pos$, $j$), $j$) $\implies$ \\
siguiente($jug$.iterAEntrenadores).id = $jug$.id $\land$ siguiente($jug$.iterAEntrenadores).cant = $j$.cantCapt) 

$ $\newline

% Auxiliares

%\tadOperacion{esContigua}{nat$/x$, nat$/y$}{bool}{}%
%\tadAxioma{esContigua($x, y$)}{contenido} 
%$ $\newline

\tadOperacion{esJugadorConectado}{jugStruc$/jug$, juego$/j$}{bool}{}%
\tadAxioma{esJugadorConectado($jug, j$)}
{$jug \in j$.jugadores $\yluego$ $jug$.conectado} 
$ $\newline

\tadOperacion{esJugadorNoEliminado}{jugStruc$/jug$, juego$/j$}{bool}{}%
\tadAxioma{esJugadorNoEliminado($jug$, $j$)}
{$jug \in j$.jugadores $\yluego$ $jug$.sanciones < 5} 
$ $\newline

\tadOperacion{enRango}{nat$/x$, nat$/y$, juego$/j$}{bool}{}%
\tadAxioma{enRango($x, y, j$)}
{posExistente(crearCoordenada($x$, $y$), $j$.mapa)}
%{$x$ < tam($j$.mapa) $\land$ $y$ < tam($j$.mapa) $\land$} 
$ $\newline

\tadOperacion{sumaSignif}{dicc(string, nat)}{nat}{}%
\tadAxioma{sumaSignif($d$)}{sumaSignifAux(claves($d$), $d$)} 
$ $\newline

\tadOperacion{sumaSignifAux}{conj(string), dicc(string, nat)}{nat}{}%
\tadAxioma{sumaSignifAux($cs$, $d$)}
{\IF $\emptyset$?(cs) THEN 0 ELSE obtener(dameUno($cs$), $d$) + sumaSignifAux(sinUno($cs$), $d$) FI} 
$ $\newline

\tadOperacion{cantSalvajes}{pokemon$/p$, juego$/j$}{nat}{}%
\tadAxioma{cantSalvajes($p, j$)}
{$\#$($p$, pokemonsSalvajes(posConPokemons($j$)))} 
$ $\newline

\tadOperacion{sumaPokesCapturados}{pokemon$/p$, juego$/j$}{nat}{}%
\tadAxioma{sumaPokesCapturados($p$, $j$)}{sumaPokesCapturadosAux($p$, $j$, jugadoresConectados($j$))} 
$ $\newline

\tadOperacion{sumaPokesCapturadosAux}{pokemon$/p$, juego$/j$, conj(jugador)$/js$}{nat}{}%
\tadAxioma{sumaPokesCapturadosAux($p$, $j$, $js$)}
{\IF $\emptyset$?($js$) THEN 0 ELSE  
{\IF def?($p$, dameUno($js$).pokemons) THEN Obtener($p$, dameUno($js$).pokemons) ELSE 0 FI}  + sumaPokesCapturadosAux($p$, $j$, sinUno($js$))
FI} 
$ $\newline

% REP  
% REVISAR LOS YLUEGOS

\tadOperacion{Rep}{juego$/j$}{bool}{}%
\tadAxioma{Rep($j$)}
{(0) $\yluego$ (1) $\yluego$ (2) $\land$ (3) $\yluego$ (4) $\land$ (5) $\land$ (6) $\yluego$ (7) $\land$ (8) $\land$ (9) $\yluego$\\
 (10) $\land$ (11) $\land$ (12) $\yluego$ (13) $\land$ (14) $\land$ (15) $\land$ (16) $\yluego$ (17) $\yluego$ (18)}
%{{(1) $\yluego$ (2) $\yluego$ (3) $\land$ (4) $\land$ (5) $\land$ (6)}} 

$ $\newline
$ $\newline


% ABS

\tadOperacion{Abs}{juego$/j$}{Juego}{Rep($j$)}%
\tadAxioma{Abs($j$)}
{
$jue$ : Juego / \\
  mapa($jue$) $\igobs$ $j$.map $\land$ \\
  jugadores($jue$) $\igobs$ $j$.jugadoresNoExpulsados $\land$ \\ 

  ($\forall e$: jugador) (($e \in$ jugadores($jue$) $\impluego$ \\
    estaConectado($e$, $jue$) $\igobs$ $j$.jugadores[$e$].conectado $\land$ \\
    sanciones($e$, $jue$) $\igobs$ $j$.jugadores[$e$].sanciones $\land$ \\
    pokemons($e$, $jue$) $\igobs$ $j$.jugadores[$e$].pokemons $\land$ \\
    estaConectado($e$, $jue$) $\implies$ posicion($e$, $jue$) $\igobs$ $j$.jugadores[$e$].pos)) $\land$ \\

  expulsados($jue$) $\igobs$ expulsadosAux($j$.jugadores) $\land$ \\
  posConPokemon($jue$) $\igobs$ $j$.posConPokemon $\land$ \\
  
  ($\forall c:$ coor) (($c \in$ posConPokemon($jue$)) $\impluego$ \\
    pokemonEnPos($c$, $jue$) $\igobs$ (($j$.pokenodos[latitud($c$)][longitud($c$)])$ \rightarrow$ poke) $\land$ \\
    cantMovimientosParaCaptura($c$, $jue$) $\igobs$ (($j$.pokenodos[latitud($c$)][longitud($c$)])$ \rightarrow$ contador))
}%

\end{Representacion}

\begin{Algoritmos}
\subsection{Algoritmos}

% crearJuego
\begin{algorithm}[H]
{\textbf{iCrearJuego}(\In{map}{mapa}) $\to$ $res$ : juego}
\begin{algorithmic}[1]

\State dictString $cantPokemon \gets $ Vacio()  \Comment $O(1)$
\State nat $cantPokemonsTotales \gets $ 0  \Comment $O(1)$
$ $\newline
\State vector(jugStruc)  $jugs \gets$ Vacio()     \Comment $O(1)$
\State conj(jugador) $jugsNoElim \gets$ Vacio()     \Comment $O(1)$
\State conj(coor) $posPokes \gets$ Vacio()     \Comment $O(1)$

% Creo la grilla de listas de posiciones (con las listas vacias)
\State vector(vector(lista(jugador)))   $grillaJugs$
$ $\newline
\For{$i \gets 0$ to Tam($map$) $-$ 1} \Comment $O((Tam(m))^2)$
    
    \State vector(lista(jugador)) $vectorInterno \gets$ Vacio()  \Comment $O(1)$
    
    \For{$j \gets 0$ to Tam($map$) $-$ 1}  \Comment $O((Tam(m)))$
        \State lista(jugador) $jugsVacia \gets$ Vacia()   \Comment $O(1)$
        \State AgregarAtras($vectorInterno$, $jugsVacia$) \Comment $O(1)$ amortizado
    \EndFor
    
    AgregarAtras($jugs$, $vectorInterno$)   \Comment $O(1)$ amortizado

\EndFor
$ $\newline
\State vector(vector(pokeStruc))  $pokenodos \gets$ Vacio()  \Comment $O(1)$

\For{$i \gets 0$ to Tam($map$) $-$ 1}       \Comment Se repite Tam(map) veces $O(1)$
    \State vector(puntero(pokeStruc)) $vectorInterno \gets$ Vacio()  \Comment $O(1)$
    \For{$j \gets 0$ to Tam($map$) $-$ 1}    \Comment Se repite Tam(map) veces $O(1)$
        \State puntero(pokeStruc) $pokePuntero \gets$ NULL   \Comment $O(1)$
        \State AgregarAtras($vectorInterno$, $pokePuntero$) \Comment $O(1)$
    \EndFor
    AgregarAtras($pokenodos$, $vectorInterno$)   \Comment $O(1)$
\EndFor

\State $res \gets \langle cantPokemon$, $cantPokemonsTotales$, $map$, $jugs$, $jugsNoElim$, $grillaJugs$, $pokenodos$, $posPokes$ $\rangle$   \Comment $O(1)$

\medskip
\Statex \underline{Complejidad:} $O((Tam(map))^2)$
\Statex \underline{Justificaion:} Se crean 2 vectores de vectores, de Tam(map) elementos tanto el vector interno como el externo $O((Tam(map))^2) + O((Tam(map))^2) = O((Tam(map))^2)$. Se crean varios contenedores vacios que cuestan O(1). El mapa lo pasamos por referencia. La tupla tiene una cantidad constante de elementos. $O(1)$ + .. + $O(1) + O((Tam(map))^2) = O((Tam(map))^2)$

\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
{\textbf{iAgregarJugador}(\In{j}{juego}) $\to$ $res$ : nat}
\begin{algorithmic}[1]

\State nat $proxId$ $\gets$ Longitud($j$.jugadores)   \Comment $O(1)$

%\State $nat sanciones \gets 0$ 
%\State $bool conectado \gets false$

% Le pongo (0,0) pero en realidad no importa porque no tenemos que chequear la posicion si esta desconectado)
\State coor $pos$ $\gets$ CrearCoor(0,0) \Comment $O(1)$

\State diccString(nat) $pokes$ $\gets$ Vacio() \Comment $O(1)$
 
% JONATHAN: COSA TURBIA, No tengo forma de crear un iterador a un heap si hacer encolar. Lo declaro pero no lo inicializo, no importaria porque solo lo usamos bajo ciertas precondiciones, peeeeero ... 
\State itcolaEntrenador $itEntrenadores$  \Comment $O(1)$

% Creo el iterador de una lista vacia para poder crearlo
\State lista(nat) $listaDummy$ $\gets$ Vacia() \Comment $O(1)$
\State itLista(nat) $iteradorAPos$ $\gets$ CrearIt($listaDummy$) \Comment $O(1)$
\State itConj(jugador) $iteradorAJuego$ $\gets$ AgregarRapido($proxId$, $j$.jugadoresNoEliminados) \Comment $O(1)$

\State AgregarRapido($j$.jugadoresNoEliminados, $e$) \Comment $O(1)$
\State AgregarAtras($j$.jugadores, $<proxId$, 0, $false$, $pos$, $pokes$, $itEntregadores$, $iteradorAPos$, $iteradorAJuego$, $0>$) \Comment $O(J)$

\State $res \gets proxId$ \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(J)$
\State \underline{Justificaci\'on:} En el peor caso, hay que redimensionar el vector y eso cuesta O(cantElementosEnVector) = O(J) pues son todos los jugadores del juego.

\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
{\textbf{iConectarse}(\Inout{p}{juego}, \In{c}{coordenada}, \In{e}{jugador})}
\begin{algorithmic}[1]

\State $j$.jugadores[\hspace{0.5mm}j\hspace{0.5mm}].conectado $\gets$ true \Comment $O(1)$
\State $j$.jugadores[$e$].iteradorAPos $\gets$ $it$ AgregarAtras($j$.grillaJugs[latitud(c)][longitud(c)], $e$) \Comment $O(1)$
\State $j$.jugadores[$e$].pos $\gets$ $c$
\If {HayPokemonCercano($c$, $j$) }

  \If{HayCamino($c$, PosPokemonCercano($c$, $j$), Mapa($j$))} \Comment $O(1)$
      \State nat $latPok$ $\gets$ latitud(PosPokemonCercano($c$, $j$)) \Comment $O(1)$
      \State nat $lonPok$ $\gets$ longitud(PosPokemonCercano($c$, $j$)) \Comment $O(1)$
      \State ($j$.pokenodos[$latPok$][$lonPok$] $\rightarrow$ contador) $\gets$ 0 \Comment $O(1)$
      \State tupla <nat, nat> $t \gets$ <$e$, $j$.jugadores[$e$].cantCap> 
      \State $j$.jugadores[$e$].iteradorAEntrenadores $\gets$ Encolar(($j$.pokenodos[$latPok$][$lonPok$] $\rightarrow$ entrenadores) , t) \Comment $O(log(EC))$

  \EndIf

\EndIf

\medskip
\State \underline{Complejidad:} $O(log(EC))$ 
\State \underline{Justificaion:} Todas las operaciones de asignaci\'on, acceso a posiciones de vectores y desreferenciaci\'on de punteros son O(1). Las funciones ``HayPokemonCercano'', ``HayCamino'', ``PosPokemonCercano'', ``Mapa''\hspace{0.5mm}son O(1). La funci\'on AgregarAtras de lista enlazada es O(1). La funci\'on de Cola de entrenadores Encolar es $O(log(EC))$ en el peor caso, y como 1 $\leq$ $log(EC)$, por \'algebra de \'ordenes, sumando todos los costos, el costo final el algoritmo es $O(log(EC))$, donde EC es la cantidad m\'axima de jugadores esperando a capturar un pokemon, (la cantidad m\'axima de elementos de la cola).


\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
{\textbf{iDesconectarse}(\Inout{j}{juego}, \In{e}{jugador})}
\begin{algorithmic}[1]

\State $j$.jugadores[$e$].conectado $\gets$ false \Comment $O(1)$
\State EliminarSiguiente($j$.jugadores[$e$].iteradorAPos) \Comment $O(1)$

% Si no esta conectado no haria falta ponerlo a null porque por precondicion nunca lo usariamos
% Ademas me parece que esta mal asignarle una tupla porque el juego no puede saber que el iter es una tupla
%\State $it \gets$ $<NULL, NULL>$ \Comment $O(1)$
%\State $j$.jugadores[$e$].iteradorAPos $\gets$ $it$ \Comment $O(1)$

\State $c \gets$ $j$.jugadores[$e$].pos 
\If {HayPokemonCercano($c$, $j$) $\land$ HayCamino($c$, PosPokemonCercano($c$, $j$), Mapa($j$))} \Comment $O(1)$
    \State nat $latPok$ $\gets$ latitud(PosPokemonCercano($c$, $j$)) \Comment $O(1)$
    \State nat $lonPok$ $\gets$ longitud(PosPokemonCercano($c$, $j$)) \Comment $O(1)$
    \State Borrar($j$.jugadores[$e$].iteradorAEntrenadores, ($j$.pokenodos[latPok][lonPok] $\rightarrow$ entrenadores)) \Comment $O(log(EC))$
    % Si no esta conectado no haria falta ponerlo a null porque por precondicion nunca lo usariamos 
    % Ademas me parece que esta mal asignarle una tupla porque el juego no puede saber que el iter es una tupla    
    %\State itcolaEntrenador $ith \gets$ $<NULL, NULL>$ \Comment $O(1)$
    %\State $j$.jugadores[$e$].iteradorAEntrenadores $\gets ith$ \Comment $O(1)$
\EndIf
\medskip
\State \underline{Complejidad:} $O(log(EC))$ 
\State \underline{Justificaion:} Todas las operaciones de asignaci\'on, acceso a posiciones de vectores y desreferenciaci\'on de punteros son O(1). Las funciones ``HayPokemonCercano'', ``HayCamino'', ``PosPokemonCercano'', ``Mapa''\hspace{0.5mm}son O(1). La funci\'on EliminarSiguiente del iterador de lista es $O(1)$. La funci\'on de itcolaEntrenadores Borrar es $O(log(EC))$ en el peor caso, y como 1 $\leq$ $log(EC)$, por \'algebra de \'ordenes, sumando todos los costos da que el algoritmo es $O(log(EC))$. Donde EC es la cantidad m\'axima de jugadores esperando a capturar un pokemon, y por lo tanto, la cantidad m\'axima de elementos de la cola.


\end{algorithmic}
\end{algorithm}

% agregarPokemon

\begin{algorithm}[H]
{\textbf{iAgregarPokemon}(\In{p}{pokemon}, \In{c}{coord}, \Inout{j}{juego})}
\begin{algorithmic}[1]

\State $j$.cantPokemonsTotales $\gets$ $j$.cantPokemonsTotales + 1 \Comment $O(1)$
\State AgregarRapido($j$.posPokemons) \Comment Por precondicion puedoAgregarPokemon $O(1)$

% Lo defino bien
\If{Def?($p$, $j$.cantPokemon)} \Comment $O(|P|)$
  \State Definir($j$.cantPokemon, $p$, Obtener($p$, $j$.cantPokemon) + 1) \Comment $O(|P|)$
\EndIf
\If{$\neg$ Def?($p$, $j$.cantPokemon)}  \Comment $O(|P|)$
  \State Definir($j$.cantPokemon, $p$, 1)  \Comment $O(|P|)$
\EndIf

\State colaEntr $h \gets$ Vacia() \Comment $O(1)$
\State vector<jugador> \hspace{0.5mm} posiblesCapturadores $\gets$ DameJugadoresEnPokerango(j, c) \Comment $O(EC)$
\State nat $i \gets$ 0 \Comment $O(1)$

\While{$i$ <\hspace{0.5mm} Longitud($posiblesCapturadores$)} \Comment $O(EC*log(EC))$
  \State $aInsertar$ $\gets$ <posiblesCapturadores[$i$], $j$.jugadores[posiblesCapturadores[$i$]].cantCapt> \Comment $O(1)$
  \State itcolaEntrenador it $\gets$ Encolar($h$, $aInsertar$) \Comment $O(log(EC))$
  \State $j$.jugadores[posiblesCapturadores[$i$]].iteradorAEntrenadores $\gets$ $it$ \Comment $O(1)$
  \State $i \gets i$ + 1 \Comment $O(1)$
\EndWhile

\State pokeStruc $pok$ $\gets$ <$p$, 0, $h$> \Comment $O(1)$
\State puntero(pokeStruc) puntPok $\gets$ $pok$ \Comment $O(1)$
\State $j$.pokenodos[latitud($c$)][longitud($c$)] $\gets$ puntPok \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(EC*log(EC) + |P|)$ 
\State \underline{Justificacion:} Las operaciones de asignaci\'on, acceso a posiciones y desreferenciaci\'on de punteros son $O(1)$. La funci\'ones Def, Definir y Obtener son $O(|P|)$ donde |P| es la longitud del pokemon m\'as largo. La operaci\'on Encolar de la cola de entrenadores es $O(log(EC))$ donde EC es la cantidad m\'axima de jugadores en un pokenodo, y por ende, la cantidad m\'axima de elementos de la cola. DameJugadoresEnPokerango es $O(EC)$ y devuelve un vector de EC elementos como m\'aximo. En el while se realiza una iteaci\'on por cada elemento de dicho vector, por lo tanto en el peor caso se realizan EC iteraciones, y como dentro del ciclo hay 3 funciones $O(1)$ y una $O(log(EC))$, la cantidad de operaciones que realiza el while hasta terminar, en el peor caso es $O(EC*log(EC))$. Sumando los costos de las operaciones independientes, por \'algebra de \'ordenes queda que el costo del algoritmo es de $O(1)$ + $O(|P|)$ + $O(1)$ + $O(EC)$ + $O(1)$ + $O(EC*log(EC))$ + $O(1)$ + $O(1)$ + $O(1)$ = $O(|P|)$ + $O(EC)$ + $O(EC*log(EC))$ = $O(|P|)$ + $O(EC*log(EC))$ (ya que EC $\leq$ EC*log(EC)) = $O(|P| + EC*log(EC))$

\end{algorithmic}
\end{algorithm}


$ $\newline
$ $\newline
%\begin{algorithm}[H]
{\textbf{iMoverse}(\In{e}{jugador}, \In{c}{coord}, \Inout{j}{juego})}
\begin{algorithmic}[1]

% Si el movimiento es invalido, tengo que sancionarle y posiblemente eliminarlo
\If{$\neg$MovValido($e$, $c$, $j$)}
  
  \State $j$.jugadores[$e$].sanciones $\gets$ $j$.jugadores[$e$].sanciones $+$ 1 \Comment $O(1)$
  
  \If{$j$.jugadores[$e$].sanciones $\geq$ 5}
  
    \State $j$.jugadores[$e$].conectado $\gets$ false \Comment $O(1)$
    \State EliminarSiguiente($j$.jugadores[$e$].iterAPos) \Comment $O(1)$
    \State EliminarSiguiente($j$.jugadores[$e$].iterAJuego) \Comment $O(1)$
  % \State itDiccString $pokesJug \gets$ crearIterador($j$.jugadores[$e$].pokemons) \Comment $O(1)$
  
    \State itConj $pokesJug \gets$ Claves($j$.jugadores[$e$].pokemons) \Comment $O(1)$  
    
    \While{HaySiguiente($pokesJug$)}   \Comment El jugador pudo haber capturado PC pokemons $O(PC*|P|)$
      % PokesJug es un iterador para el conjuntp de claves
      \State pokemon $pokeActual \gets$ Siguiente($pokesJug$).poke  \Comment $O(1)$
      \State nat $cantActual \gets$ Obtener($j$.jugadores[$e$].pokemons, $pokeActual$) \Comment $O(|P|)$
      
      \State Definir($j$.cantPokemon, $pokeActual$, Obtener($pokeActual$, $j$.cantPokemon)$-cantActual$) \Comment $O(|P|)$
    \EndWhile
    
    \State $j$.cantPokemonTotales $\gets$ $j$.cantPokemonTotales - $j$.jugadores[$e$].cantCapt \Comment $O(1)$
    
    \If{HayPokemonCerca($j$.jugadores[$e$].pos)}   \Comment $O(1)$
      \State Borrar($j$.jugadores[$e$].iterAEntrenadores) \Comment $O(log(EC))$
    \EndIf
    
    \State Avanzar($pokesJug$) \Comment $O(1)$

  \EndIf

\EndIf


% Ahora tengo que hacer los movimientos propiamente dichos (solo si el jugador no fue eliminado)
\If{$j$.jugadores[$e$].sanciones $<$ $5$}
  
  \State coor $posAntes \gets$ Copiar($j$.jugadores[$e$].pos)  \Comment $O(1)$
  \State bool $hayPokAntes \gets$ HayPokemonCercano($posAntes$, $j$)  \Comment $O(1)$
  \State bool $hayPokDesp \gets$ HayPokemonCercano($c$, $j$)  \Comment $O(1)$ 
  
  \Statex $ $
  
  \If{$hayPokDesp$}
  
    \If{$\neg$ $hayPokAntes$} 
      \State CasoMov3($e$, $posAntes$, $c$, $j$)  \Comment $O((PS *|P|) + log(EC))$ 
          
    \Else %Hay Antes
      \If{PosPokemonCercano($posAntes$, $j$) = PosPokemonCercano($c$, $j$)}  \Comment $O(1)$
        \State CasoMov1($e$, $posAntes$, $c$, $j$) \Comment $O(PS *|P|)$ 
      \Else

        \State CasoMov5($e$, $posAntes$, $c$, $j$) \Comment  $O((PS *|P|) + log(EC))$ 
      \EndIf    
    \EndIf
  \Else %If no hay despues
    \If{$hayPokAntes$}
      
      \State CasoMov2($e$, $posAntes$, $c$, $j$) \Comment  $O((PS *|P|) + log(EC))$ 
    \Else
      \State CasoMov4($e$, $posAntes$, $c$, $j$) \Comment  $O(PS *|P|)$ 
    \EndIf    
    
  \EndIf
  
  % En cualquier caso, hay que actualizar las nuevas posiciones
  \Statex $ $
  \Statex $ $
  % Borro la posicion de la lista de posiciones y asigno una nueva
  \State Borrar($j$.jugadores[$e$].iterAPos) \Comment $O(1)$
  \State $j$.jugadores[$e$].iterAPos $\gets$ AgregarAtras($j$.grillaJugs[Latitud($c$)][Longitud($c$)]) \Comment $O(1)$
  \State $j$.jugadores[$e$].pos $\gets$ $c$ \Comment $O(1)$ 
  
\EndIf

\medskip
\State \underline{Complejidad:} $O((PS + PC)*|P| + log(EC))$ 
\State \underline{Justificaci\'on:} Si el movimiento no fue valido, en el peor caso hay que eliminar al jugador. Esto cuesta $O((PC *|P|) + log(EC))$ pues se ejecuta el ciclo. La segunda parte del algoritmo no se ejecuta si el jugador fue eliminado (pues no entra en el if de sanciones menores a 5), sin embargo, en caso que no fue eliminado el peor caso cuesta $O((PS *|P|) + log(EC))$ si tomo la rama con mayor complejidad. Esto nos da que la complejidad total del algoritmo en peor caso, es la ``rama'' que mayor complejidad tenga, osea $O(max((PC *|P|) + log(EC), (PS *|P|) + log(EC)))$. Por \'algebra de \'ordenes, usando que el m\'aximo es la suma, esa complejidad es igual a $O((PC *|P|) + log(EC) + (PS *|P|) + log(EC))$ = $O((PC *|P|) + (PS *|P|) + log(EC))$ = $O((PC + PS) *|P|) + log(EC))$

\end{algorithmic}
%\end{algorithm}



$ $\newline
$ $\newline

% CASO 1

% Es casi igual al caso 2, si esta mal una esta mal la otra
%\begin{algorithm}[H]
{\textbf{iCasoMov1}(\In{e}{jugador}, \In{ant}{coor} \In{desp}{coor}, \Inout{j}{juego}))}
\begin{algorithmic}[1]

\Statex \underline{CasoMov1} : Funci\'on privada 
\Statex \underline{Descripci\'on} : Este es el caso en donde el jugador estaba cerca de un pokemon y se movi\'o dentro del mismo radio 
\Statex \underline{Pre}: $j$ = $j_0$ $\land$ hayPokemonCercano($ant$, $j$) $\land$ hayPokemonCercano($desp$, $j$) $\yluego$ posPokemonCercano($ant$, $j$) = posPokemonCercano($desp$, $j$) 
\Statex \underline{Post}: $j_0$ = moverse($e$, $desp$, $j$) 
\Statex \underline{Complejidad}: $O(PS *|P|)$ 
\Statex \underline{Aliasing}: Produce aliasing, el juego es modificable

$ $\newline

\State coor $pokePos \gets$ PosPokemonCercano($desp$, $j$) \Comment $O(1)$
\State itConj $iterPos \gets$ CrearIter($j$.posPokemons) \Comment $O(1)$ 

\While{HaySiguente($iterPos$)}  \Comment $O(PS * |P|)$

  \State nat $x \gets$ Latitud(Siguiente($iterPos$)) \Comment $O(1)$
  \State nat $y \gets$ Longitud(Siguiente($iterPos$)) \Comment $O(1)$   
  
  \If{Siguiente($iterPos$) $\neq$ $pokepos$}
    \State ($j$.pokenodos[$x$][$y$])$\rightarrow$ contador $\gets$ (($j$.pokenodos[$x$][$y$])$\rightarrow$ contador) $+ 1$) \Comment($O(1)$)
  \EndIf
  
  \If{$j$.pokenodos[$x$][$y$])$\rightarrow$ contador $= 10$}
    \State SumarUnoEnJug($j$.pokenodos[$x$][$y$])$\rightarrow$ poke, Proximo($j$.pokenodos[$x$][$y$])$\rightarrow$ entrenadores)) \Comment $O(|P|)$
    \State EliminarSiguiente($iterPos$) \Comment $O(1)$
    \State $j$.pokenodos[$x$][$y$] $\gets$ NULL \Comment Libero la memoria $O(1)$
  \Else 
    \State Avanzar($iterPos$) \Comment $O(1)$ 
  \EndIf

\EndWhile 

\medskip
\Statex \underline{Complejidad:} $O((PS *|P|) + log(EC))$ 
\Statex \underline{Justificaci\'on:} Recorro todos los pokemons salvajes: $O(PC)$, y por cada pokemon en peor caso el contador es mayor o igual a 10, por lo que hay que agregar el pokemon al diccionario del jugador: $O(|P|)$. Este ciclo en total cuesta $O(PC*|P|)$. El resto de las operaciones son $O(1)$ y no agregan complejidad. 
\end{algorithmic}
%\end{algorithm}

$ $\newline
$ $\newline

% CASO 2

%\begin{algorithm}[H]
% Es casi igual al caso 1, si esta mal una esta mal la otra
{\textbf{iCasoMov2}(\In{e}{jugador}, \In{ant}{coor} \In{desp}{coor}, \Inout{j}{juego}))}
\begin{algorithmic}[1]

\Statex \underline{CasoMov2} : Funci\'on privada 
\Statex \underline{Descripci\'on} : Este es el caso en donde el jugador estaba cerca de un pokemon y se movi\'o fuera del radio
\Statex \underline{Pre}: $j$ = $j_0$ $\land$ hayPokemonCercano($ant$, $j$) $\land$ $\neg$hayPokemonCercano($desp$, $j$) 
\Statex \underline{Post}: $j_0$ = moverse($e$, $desp$, $j$) 
\Statex \underline{Complejidad}:  $O((PS *|P|) + log(EC))$ 
\Statex \underline{Aliasing}: Produce aliasing, el juego es modificable

$ $\newline

% tengo que borrarme del pokenodo del que sali
% borro al jugador del pokestruc
\State Eliminar($j$.jugadores[$e$].iterAEntrenadores) \Comment $O(log(EC))$

\State itConj $iterPos \gets$ CrearIter($j$.posPokemons) \Comment $O(1)$ 

\While{HaySiguente($iterPos$)}  \Comment $O(PS * |P|)$

  \State nat $x \gets$ Latitud(Siguiente($iterPos$)) \Comment $O(1)$
  \State nat $y \gets$ Longitud(Siguiente($iterPos$)) \Comment $O(1)$   
  
  % Los actualizo todos pues me sali fuera
  \State ($j$.pokenodos[$x$][$y$])$\rightarrow$ contador $\gets$ (($j$.pokenodos[$x$][$y$])$\rightarrow$ contador) $+ 1$) \Comment($O(1)$)
  
  \If{$j$.pokenodos[$x$][$y$])$\rightarrow$ contador $= 10$}
    \State SumarUnoEnJug($j$.pokenodos[$x$][$y$])$\rightarrow$ poke, Proximo($j$.pokenodos[$x$][$y$])$\rightarrow$ entrenadores)) \Comment $O(|P|)$
    \State EliminarSiguiente($iterPos$) \Comment $O(1)$
    \State $j$.pokenodos[$x$][$y$] $\gets$ NULL \Comment Libero la memoria $O(1)$
  \Else 
    \State Avanzar($iterPos$) \Comment $O(1)$ 
  \EndIf

\EndWhile 



\medskip
\Statex \underline{Complejidad:} $O((PS *|P|) + log(EC))$ 
\Statex \underline{Justificaci\'on:} Se elimina al jugador de la cola de entrenadores del pokestruc en el que se encontraba: $O(log(EC))$. Luego recorro todos los pokemons salvajes: $O(PC)$, y por cada pokemon en peor caso el contador es mayor o igual a 10, por lo que hay que agregar el pokemon al diccionario del jugador: $O(|P|)$. Este ciclo en total cuesta $O(PC*|P|)$. El resto de las operaciones son $O(1)$ y no agregan complejidad. La complejidad en peor caso del algoritmo es $O((PS *|P|) + log(EC))$ por algebra de ordenes.
\end{algorithmic}
%\end{algorithm}

$ $\newline
$ $\newline


% CASO 3

% Es casi igual al caso 1, si esta mal una esta mal la otra
%\begin{algorithm}[H]
{\textbf{iCasoMov3}(\In{e}{jugador}, \In{ant}{coor} \In{desp}{coor}, \Inout{j}{juego}))}
\begin{algorithmic}[1]

\Statex \underline{CasoMov3} : Funci\'on privada 
\Statex \underline{Descripci\'on} : Este es el caso en donde el jugador no estaba cerca de ninguno y se movi\'o dentro de algun radio de pokemon
\Statex \underline{Pre}: $j$ = $j_0$ $\land$ $\neg$hayPokemonCercano($ant$, $j$) $\land$ hayPokemonCercano($desp$, $j$) 
\Statex \underline{Post}: $j_0$ = moverse($e$, $desp$, $j$) 
\Statex \underline{Complejidad}: $O(PS *|P|)$ 
\Statex \underline{Aliasing}: Produce aliasing, el juego es modificable

$ $\newline

\State coor $pokePos \gets$ PosPokemonCercano($desp$, $j$) \Comment $O(1)$
\State itConj $iterPos \gets$ CrearIter($j$.posPokemons) \Comment $O(1)$ 

\State $j$.jugadores[$e$].iterAEntrenadores $\gets$ Encolar(\\
$   $\hspace*{2cm}  $j$.pokenodos[Latitud($pokePos$)][Longitud($pokePos$)], <$e$, $j$.jugadores[$e$].cantCapt>\\
$   $\hspace*{1cm}) \Comment $O(log(EC))$

\While{HaySiguente($iterPos$)} \Comment $O(PS * |P|)$

  \State nat $x \gets$ Latitud(Siguiente($iterPos$)) \Comment $O(1)$
  \State nat $y \gets$ Longitud(Siguiente($iterPos$)) \Comment $O(1)$   
  
  % A donde me movi lo pongo en 0
  \If{Siguiente($iterPos$) $\neq$ $pokepos$}
    \State ($j$.pokenodos[$x$][$y$])$\rightarrow$ contador $\gets$ 0) \Comment($O(1)$)
  \EndIf
  
  \If{$j$.pokenodos[$x$][$y$])$\rightarrow$ contador $= 10$}
    \State SumarUnoEnJug($j$.pokenodos[$x$][$y$])$\rightarrow$ poke, Proximo($j$.pokenodos[$x$][$y$])$\rightarrow$ entrenadores)) \Comment $O(|P|)$
    \State EliminarSiguiente($iterPos$) \Comment $O(1)$
    \State $j$.pokenodos[$x$][$y$] $\gets$ NULL \Comment Libero la memoria $O(1)$
  \Else 
    \State Avanzar($iterPos$) \Comment $O(1)$ 
  \EndIf

\EndWhile 

\medskip
\Statex \underline{Complejidad:} $O((PS *|P|) + log(EC))$ 
\Statex \underline{Justificaci\'on:} Modifico la cola de entrenadores del pokestruc al cual el jugador se mueve agregando el jugador a la cola: $O(log(EC))$. Recorro todos los pokemons salvajes: $O(PC)$, y por cada pokemon en peor caso el contador es mayor o igual a 10, por lo que hay que agregar el pokemon al diccionario del jugador: $O(|P|)$. Este ciclo en total cuesta $O(PC*|P|)$. El resto de las operaciones son $O(1)$ y no agregan complejidad. La complejidad en peor caso del algoritmo es $O((PS *|P|) + log(EC))$ por algebra de ordenes.
\end{algorithmic}
%\end{algorithm}

$ $\newline
$ $\newline

% CASO 4

%\begin{algorithm}[H]
% Es casi igual al caso 2, si esta mal una esta mal la otra
{\textbf{iCasoMov4}(\In{e}{jugador}, \In{ant}{coor} \In{desp}{coor}, \Inout{j}{juego}))}
\begin{algorithmic}[1]

\Statex \underline{CasoMov4} : Funci\'on privada 
\Statex \underline{Descripci\'on} : Este es el caso en donde el jugador estaba lejos de todo pokemon y se movi\'o lejos de todo pokemon
\Statex \underline{Pre}: $j$ = $j_0$ $\land$ $\neg$hayPokemonCercano($ant$, $j$) $\land$ $\neg$hayPokemonCercano($desp$, $j$) 
\Statex \underline{Post}: $j_0$ = moverse($e$, $desp$, $j$) 
\Statex \underline{Complejidad}: $O(PS *|P|)$ 
\Statex \underline{Aliasing}: Produce aliasing, el juego es modificable

$ $\newline

% la diferencia es que no borro desde ningun pokenodo

\State itConj $iterPos \gets$ CrearIter($j$.posPokemons) \Comment $O(1)$ 

\While{HaySiguente($iterPos$)} \Comment $O(PS * |P|)$

  \State nat $x \gets$ Latitud(Siguiente($iterPos$)) \Comment $O(1)$
  \State nat $y \gets$ Longitud(Siguiente($iterPos$)) \Comment $O(1)$   
  
  % Los actualizo todos pues me sali fuera
  \State ($j$.pokenodos[$x$][$y$])$\rightarrow$ contador $\gets$ (($j$.pokenodos[$x$][$y$])$\rightarrow$ contador) $+ 1$) \Comment($O(1)$)
  
  \If{$j$.pokenodos[$x$][$y$])$\rightarrow$ contador $= 10$}
    \State SumarUnoEnJug($j$.pokenodos[$x$][$y$])$\rightarrow$ poke, Proximo($j$.pokenodos[$x$][$y$])$\rightarrow$ entrenadores)) \Comment $O(|P|)$
    \State EliminarSiguiente($iterPos$) \Comment $O(1)$
    \State $j$.pokenodos[$x$][$y$] $\gets$ NULL \Comment Libero la memoria $O(1)$
  \Else 
    \State Avanzar($iterPos$) \Comment $O(1)$ 
  \EndIf

\EndWhile 



\medskip
\Statex \underline{Complejidad:} $O((PS *|P|))$ 
\Statex \underline{Justificaci\'on:} Recorro todos los pokemons salvajes: $O(PC)$, y por cada pokemon en peor caso el contador es mayor o igual a 10, por lo que hay que agregar el pokemon al diccionario del jugador: $O(|P|)$. Este ciclo en total cuesta $O(PC*|P|)$. El resto de las operaciones son $O(1)$ y no agregan complejidad. La complejidad en peor caso del algoritmo es $O((PS *|P|) + log(EC))$ por algebra de ordenes.
\end{algorithmic}
%\end{algorithm}

$ $\newline
$ $\newline

% CASO 5

%\begin{algorithm}[H]
% Es casi igual al caso 2 + 3, si esta mal una esta mal la otra
{\textbf{iCasoMov5}(\In{e}{jugador}, \In{ant}{coor} \In{desp}{coor}, \Inout{j}{juego}))}
\begin{algorithmic}[1]

\Statex \underline{CasoMov5} : Funci\'on privada 
\Statex \underline{Descripci\'on} : Este es el caso en donde el jugador estaba cerca de un pokemon y se movi\'o hacias las cercanias de otro pokemon distinto
\Statex \underline{Pre}: $j$ = $j_0$ $\land$ hayPokemonCercano($ant$, $j$) $\land$ $\neg$hayPokemonCercano($desp$, $j$) $\yluego$ posPokemonCercano($ant$, $j$) $\neq$ posPokemonCercano($desp$, $j$)
\Statex \underline{Post}: $j_0$ = moverse($e$, $desp$, $j$) 
\Statex \underline{Complejidad}:  $O((PS *|P|) + log(EC))$ 
\Statex \underline{Aliasing}: Produce aliasing, el juego es modificable

$ $\newline

% tengo que borrarme del pokenodo del que sali
% borro al jugador del pokestruc
\State Eliminar($j$.jugadores[$e$].iterAEntrenadores) \Comment $O(log(EC))$

% Actualizo el iter al nuevo pokenodo
\State coor $pokePos \gets$ PosPokemonCercano($desp$, $j$) \Comment $O(1)$

\State $j$.jugadores[$e$].iterAEntrenadores $\gets$ Encolar(\\
$   $\hspace*{2cm}  $j$.pokenodos[Latitud($pokePos$)][Longitud($pokePos$)], <$e$, $j$.jugadores[$e$].cantCapt>\\
$   $\hspace*{1cm}) \Comment $O(log(EC))$


\State itConj $iterPos \gets$ CrearIter($j$.posPokemons) \Comment $O(1)$ 

\While{HaySiguente($iterPos$)} \Comment $O(PS * |P|)$

  \State nat $x \gets$ Latitud(Siguiente($iterPos$)) \Comment $O(1)$
  \State nat $y \gets$ Longitud(Siguiente($iterPos$)) \Comment $O(1)$   

  % A donde me movi lo pongo en 0
  \If{Siguiente($iterPos$) $\neq$ $pokepos$}
    \State ($j$.pokenodos[$x$][$y$])$\rightarrow$ contador $\gets$ 0) \Comment($O(1)$)
  \EndIf

  
  % Los actualizo todos pues me sali fuera
  \State ($j$.pokenodos[$x$][$y$])$\rightarrow$ contador $\gets$ (($j$.pokenodos[$x$][$y$])$\rightarrow$ contador) $+ 1$) \Comment($O(1)$)
  
  \If{$j$.pokenodos[$x$][$y$])$\rightarrow$ contador $= 10$}
    \State SumarUnoEnJug($j$.pokenodos[$x$][$y$])$\rightarrow$ poke, Proximo($j$.pokenodos[$x$][$y$])$\rightarrow$ entrenadores)) \Comment $O(|P|)$
    \State EliminarSiguiente($iterPos$) \Comment $O(1)$
    \State $j$.pokenodos[$x$][$y$] $\gets$ NULL \Comment Libero la memoria $O(1)$
  \Else 
    \State Avanzar($iterPos$) \Comment $O(1)$ 
  \EndIf

\EndWhile 



\medskip
\Statex \underline{Complejidad:} $O((PS *|P|) + log(EC))$ 
\Statex \underline{Justificaci\'on:} Se elimina al jugador de la cola de entrenadores del pokestruc en el que se encontraba: $O(log(EC))$. Inserto el jugador en la ola de entrenadores del nuevo pokenodo: $O(log(EC))$. En total hasta ahora cuesta $2*O(log(EC)) = O(log(EC))$. Luego recorro todos los pokemons salvajes: $O(PC)$, y por cada pokemon en peor caso el contador es mayor o igual a 10, por lo que hay que agregar el pokemon al diccionario del jugador: $O(|P|)$. Este ciclo en total cuesta $O(PC*|P|)$. El resto de las operaciones son $O(1)$ y no agregan complejidad. La complejidad en peor caso del algoritmo, teniendo en cuenta la complejidad acumulada antes de ciclo, es $O((PS *|P|) + log(EC))$ por algebra de ordenes.
\end{algorithmic}
%\end{algorithm}

$ $\newline
$ $\newline



% cantPokemonsTotales
\begin{algorithm}[H]
{\textbf{iCantPokemonTotales}(\In{j}{juego}) $\to$ $res$ : nat}
\begin{algorithmic}[1]

\State $res \gets$ $j$.cantPokemonsTotales \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$

\end{algorithmic}
\end{algorithm}

% indiceRareza

\begin{algorithm}[H]
{\textbf{iIndiceRareza}(\In{p}{pokemon}, \In{j}{juego}) $\to$ $res$ : nat}
\begin{algorithmic}[1]

\State nat $pokecant \gets$ Obtener(j.cantPokemon, $p$) \Comment $O(|P|)$

\State $res \gets$ 100 $-$ (100 $*$ $pokecant$ $/$ j.cantPokemonsTotales) \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(|P|)$
\State \underline{Justificacion:} j.cantPokemon es un dicciString. La complejidad de buscar (y obtener el significado) en peor caso es la longitud de la string mas larga entre sus claves, eso es O($|P|$). j.cantPokemonsTotales es un dato guardado en la estructura del juego, y se accede en O(1). El resto son una resta, multiplicacion y division, que tambien son O(1). O($|P|$) $+$ O(1) $=$ O($|P|$)

\end{algorithmic}
\end{algorithm}



% posConPokemons 

\begin{algorithm}[H]
{\textbf{iPosConPokemons}(\In{j}{juego}) $\to$ $res$ : conj(coor)}
\begin{algorithmic}[1]

\State $res \gets$ $j$.posPokemons \Comment Por referencia $O(1)$
 
\medskip
\Statex \underline{Complejidad:} $O(1)$
\end{algorithmic}
\end{algorithm}


% pokemonEnPos 

\begin{algorithm}[H]
{\textbf{iPokemonEnPos}(\In{j}{juego}, \In{c}{coor}) $\to$ $res$ : pokemon}
\begin{algorithmic}[1]

\State $res \gets$ (($j$.pokenodos[Latitud($c$)][Longitud($c$)]) $\rightarrow$ poke) \Comment $O(1)$
 
\medskip
\Statex \underline{Complejidad:} $O(1)$
\end{algorithmic}
\end{algorithm}



% Posicion

\begin{algorithm}[H]
{\textbf{iPosicion}(\In{j}{juego}, \In{e}{jugador}) $\to$ $res$ : coor}
\begin{algorithmic}[1]

\State $res \gets$ $j$.jugadores[$e$].pos \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$
\State \underline{Justificacion:} Todas las operaciones son $O(1)$


\end{algorithmic}
\end{algorithm}


% Sanciones

\begin{algorithm}[H]
{\textbf{iSanciones}(\In{e}{jugador}, \In{j}{juego}) $\to$ $res$ : nat}
\begin{algorithmic}[1]

\State $res \gets$ $j$.jugadores[$e$].sanciones \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$
\State \underline{Justificacion:} Todas las operaciones son $O(1)$


\end{algorithmic}
\end{algorithm}

% entrenadoresPosibles
% por precondicion estan conectados

\begin{algorithm}[H]
{\textbf{iEntrenadoresPosibles}(\In{c}{coor}, \In{aRevisar}{conj(jugador)}, \In{j}{juego}) $\to$ $res$ : conj(jugador)}
\begin{algorithmic}[1]

\State coor $pokeCoor \gets$ PosPokemonCercano($c$, $j$) \Comment $O(1)$
\State puntero(pokeStruc) $pokePuntero \gets j.pokeNodos[longitud(pokeCoor)][latitud(pokeCoor)]$ \Comment $O(1)$

\State itConj(jugador) $itPosibles \gets$ CrearIt($aRevisar$) \Comment $O(1)$

\While{HaySiguiente($itPosibles$)}   \Comment O($Longitud(aRevisar) * EC$)
    
    % Asumo que tengo una forma de recorrer el heap
    \State vector(jugador) $jugsEnNodo \gets$ CrearIt(DameJugadoresEnPokerango($c$, $j$))     \Comment $O(EC)$
    
    \For{nat $i \gets$ 0 to Longitud($jugsEnNodo - 1$)} \Comment $O(EC)$
        \If{Siguiente($itPosibles$) = $itJugsEnNodo$[$i$]}   \Comment $O(1)$
            \State Agregar($res$, Siguiente($itPosible$))    
        \EndIf
        
        \State Avanzar($itJugsEnNodo$)) \Comment()
    
    %\EndWhile
    \EndFor
    
    \State Avanzar($itPosible$)   \Comment $O(1)$


\EndWhile


\medskip
\State \underline{Complejidad:}  O(Longitud($aRevisar$) * $EC$)
\State \underline{Justificacion:}  Son todas operaciones O(1) excepto aquella en la que se crea un vector con los jugadores en rango y el for que lo recorre que son O(EC). El while principal se itera O(Longitud(aRevisar)) veces, y la operaci\'on m\'as costosa dentro de este mismo es O(EC), por lo tanto el while entero cuesta O(Longitud(aRevisar)*EC) operaciones elementales.

\end{algorithmic}
\end{algorithm}



$ $\newline
$ $\newline
$ $\newline
% hayPokemonCercano
%\begin{algorithm}[H]
{\textbf{iHayPokemonCercano}(\In{c}{coor}, \In{j}{juego}) $\to$ $res$ : coor}
\begin{algorithmic}[1]

\State nat $x \gets$ latitud(c)    \Comment $O(1)$
\State nat $y \gets$ longitud(c)   \Comment $O(1)$

% j.pokenodos[x][y] != NULL   =>  pos con pokemon

\State bool $hayPokemon \gets$ false    \Comment $O(1)$

\If{j.pokenodos[$x$][$y$] $\neq$ NULL}     \Comment $O(1)$
    \State $hayPokemon \gets$ true
\EndIf

\If{$x > 0$}
    \If{j.pokenodos[$x-1$][$y$] $\neq$ NULL}     \Comment $O(1)$
        \State $hayPokemon \gets$ true
    \EndIf

    \If{$y > 0$}

        \If{j.pokenodos[$x-1$][$y-1$] $\neq$ NULL}     \Comment $O(1)$
            \State $hayPokemon \gets$ true
        \EndIf

    \EndIf

    % tam(m) no puede ser 0 porque existe una coordenada al menos (x,y)
    \If{$y < tam(m) - 1$}
        \If{j.pokenodos[$x-1$][$y+1$] $\neq$ NULL}     \Comment $O(1)$
            \State $hayPokemon \gets$ true
        \EndIf
    \EndIf

    \If{$x-1 > 0$}
        \If{j.pokenodos[$x-2$][$y$] $\neq$ NULL}     \Comment $O(1)$
            \State $hayPokemon \gets$ true
        \EndIf
    \EndIf

\EndIf

\If{$y > 0$}

    \If{j.pokenodos[$x$][$y-1$] $\neq$ NULL}     \Comment $O(1)$
        \State $hayPokemon \gets$ true
    \EndIf

    \If{$y-1 > 0$}

        \If{j.pokenodos[$x$][$y-2$] $\neq$ NULL}     \Comment $O(1)$
            \State $hayPokemon \gets$ true
        \EndIf

    \EndIf

\EndIf

\If{$y < tam(m) - 1$}

    \If{j.pokenodos[$x$][$y+1$] $\neq$ NULL}     \Comment $O(1)$
        \State $hayPokemon \gets$ true
    \EndIf


    \If{$tam(m) > 1 \land y < tam(m) - 2$}
        \If{j.pokenodos[$x$][$y+2$] $\neq$ NULL}     \Comment $O(1)$
            \State $hayPokemon \gets$ true
        \EndIf


    \EndIf

\EndIf

\If{$x < tam(m) - 1$}
    \If{j.pokenodos[$x+1$][$y$] $\neq$ NULL}     \Comment $O(1)$
        \State $hayPokemon \gets$ true
        \EndIf

    \If{$y > 0$}
        \If{j.pokenodos[$x+1$][$y-1$] $\neq$ NULL}     \Comment $O(1)$
            \State $hayPokemon \gets$ true
        \EndIf
    \EndIf

    \If{$y < tam(m)-1$}
        \If{j.pokenodos[$x+1$][$y+1$] $\neq$ NULL}     \Comment $O(1)$
            \State $hayPokemon \gets$ true
        \EndIf

    \EndIf
\EndIf

\If{$tam(m) > 1 \land x < tam(m) - 2$}
    \If{j.pokenodos[$x+2$][$y$] $\neq$ NULL}     \Comment $O(1)$
        \State $hayPokemon \gets$ true
    \EndIf
\EndIf

\State $res \gets hayPokemon$

\medskip
\State \underline{Complejidad:} $O(1)$ % por enunciado
\State \underline{Justificacion:} Reviso 13 posiciones O(1)

\end{algorithmic}
%\end{algorithm}

$ $\newline
$ $\newline
$ $\newline


% posPokemonCercano

%\begin{algorithm}[H]
{\textbf{iPosPokemonCercano}(\In{c}{coor}, \In{j}{juego}) $\to$ $res$ : coor}
\begin{algorithmic}[1]

\State nat $x \gets$ latitud(c)    \Comment $O(1)$
\State nat $y \gets$ longitud(c)   \Comment $O(1)$

% j.pokenodos[x][y] != NULL   =>  pos con pokemon

\State coor $coorConPokemon$    \Comment $O(1)$

\If{j.pokenodos[$x$][$y$] $\neq$ NULL}     \Comment $O(1)$
    \State $coorConPokemon \gets$ CrearCoor($x$, $y$)    \Comment $O(1)$
\EndIf

\If{$x > 0$}
    \If{j.pokenodos[$x-1$][$y$] $\neq$ NULL}     \Comment $O(1)$
        \State $coorConPokemon \gets$ CrearCoor($x-1$, $y$)    \Comment $O(1)$
    \EndIf

    \If{$y > 0$}

        \If{j.pokenodos[$x-1$][$y-1$] $\neq$ NULL}     \Comment $O(1)$
            \State $coorConPokemon \gets$ CrearCoor($x-1$, $y-1$)    \Comment $O(1)$
        \EndIf

    \EndIf

    % tam(m) no puede ser 0 porque existe una coordenada al menos (x,y)
    \If{$y < tam(m) - 1$}
        \If{j.pokenodos[$x-1$][$y+1$] $\neq$ NULL}     \Comment $O(1)$
            \State $coorConPokemon \gets$ CrearCoor($x-1$, $y+1$)    \Comment $O(1)$
        \EndIf
    \EndIf

    \If{$x-1 > 0$}
        \If{j.pokenodos[$x-2$][$y$] $\neq$ NULL}     \Comment $O(1)$
            \State $coorConPokemon \gets$ CrearCoor($x-1$, $y$)    \Comment $O(1)$
        \EndIf
    \EndIf

\EndIf

\If{$y > 0$}

    \If{j.pokenodos[$x$][$y-1$] $\neq$ NULL}     \Comment $O(1)$
        \State $coorConPokemon \gets$ CrearCoor($x$, $y-1$)    \Comment $O(1)$
    \EndIf

    \If{$y-1 > 0$}

        \If{j.pokenodos[$x$][$y-2$] $\neq$ NULL}     \Comment $O(1)$
            \State $coorConPokemon \gets$ CrearCoor($x$, $y-2$)    \Comment $O(1)$        
        \EndIf

    \EndIf

\EndIf

\If{$y < tam(m) - 1$}

    \If{j.pokenodos[$x$][$y+1$] $\neq$ NULL}     \Comment $O(1)$
        \State $coorConPokemon \gets$ CrearCoor($x$, $y+1$)    \Comment $O(1)$    
    \EndIf


    \If{$tam(m) > 1 \land y < tam(m) - 2$}
        \If{j.pokenodos[$x$][$y+2$] $\neq$ NULL}     \Comment $O(1)$
            \State $coorConPokemon \gets$ CrearCoor($x$, $y+2$)    \Comment $O(1)$
        \EndIf


    \EndIf

\EndIf

\If{$x < tam(m) - 1$}
    \If{j.pokenodos[$x+1$][$y$] $\neq$ NULL}     \Comment $O(1)$
        \State $coorConPokemon \gets$ CrearCoor($x+1$, $y$)    \Comment $O(1)$
    \EndIf

    \If{$y > 0$}
        \If{j.pokenodos[$x+1$][$y-1$] $\neq$ NULL}     \Comment $O(1)$
            \State $coorConPokemon \gets$ CrearCoor($x+1$, $y-1$)    \Comment $O(1)$
        \EndIf
    \EndIf

    \If{$y < tam(m)-1$}
        \If{j.pokenodos[$x+1$][$y+1$] $\neq$ NULL}     \Comment $O(1)$
            \State $coorConPokemon \gets$ CrearCoor($x+1$, $y+1$)    \Comment $O(1)$
        \EndIf

    \EndIf
\EndIf

\If{$tam(m) > 1 \land x < tam(m) - 2$}
    \If{j.pokenodos[$x+2$][$y$] $\neq$ NULL}     \Comment $O(1)$
        \State $coorConPokemon \gets$ CrearCoor($x+2$, $y$)    \Comment $O(1)$
    \EndIf
\EndIf

\State $res \gets coorConPokemon$

\medskip
\State \underline{Complejidad:} $O(1)$ % por enunciado
\State \underline{Justificacion:} Reviso 13 posiciones O(1)

\end{algorithmic}
%\end{algorithm}



% puedoAgregarPokemon

\begin{algorithm}[H]
{\textbf{iPuedoAgregarPokemon}(\In{c}{coor}, \In{j}{juego}) $\to$ $res$ : bool}
\begin{algorithmic}[1]

\State bool $puedo \gets$ false  \Comment $O(1)$

\If{PosExistente(c, j.mapa)}   \Comment $O(1)$
    \If{$\neg$ HayPokemonCercano(c, j)}   \Comment $O(1)$
        \State $puedo \gets$ true        \Comment $O(1)$
    \EndIf
\EndIf

\State $res \gets puedo$  \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$
\State \underline{Justificacion:} Todas las operaciones son O(1)

\end{algorithmic}
\end{algorithm}


% cantMovimientosParaCaptura

\begin{algorithm}[H]
{\textbf{iCantMovimientosParaCaptura}(\In{c}{coor}, \In{j}{juego}) $\to$ $res$ :    nat}
\begin{algorithmic}[1]

\State puntero(pokeStruc) $pokenodo \gets$ j.pokenodos[latitud($c$)][longitud($c$)] \Comment $O(1)$
\State $res \gets$ (*pokenodo).contador  \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$
\State \underline{Justificacion:} Todas las operaciones son O(1)

\end{algorithmic}
\end{algorithm}


% expulsados

\begin{algorithm}[H]
{\textbf{iExpulsados}(\In{j}{juego}) $\to$ $res$ : conj(jugador)}
\begin{algorithmic}[1]

\For{$nat i \gets$ 0 to Longitud(j.jugadores) $-$ 1}   \Comment $O(J)$
    \If{j.jugadores[$i$].sanciones $\geq$ 5}   \Comment $O(1)$
        AgregarRapido(res, j.jugadores[$i$].id)  \Comment $O(1)$        
    \EndIf
\EndFor

\medskip
\State \underline{Complejidad:} $O(J)$
\State \underline{Justificacion:} Aplico operaciones que son O(1) la cantidad de veces que ejecuto el ciclo. El ciclo se ejecuta J veces (porque j.jugadores tiene todos los jugadores que fueron agregados) Entonces es O(J), siendo J la cantidad de jugadores que fueron agregados.

\end{algorithmic}
\end{algorithm}


% pokemons

\begin{algorithm}[H]
{\textbf{iPokemons}(\In{e}{jugador}, \In{j}{juego}) $\to$ $res$ : iterDiccString(nat)}
\begin{algorithmic}[1]

\State $res \gets $ CrearIt(j.jugadores[e].pokemons) \Comment $O(1)$

\medskip
\State \underline{Complejidad:} $O(1)$
\State \underline{Justificacion:} Devuelvo un iterador en O(1)

\end{algorithmic}
\end{algorithm}



\begin{algorithm}[H]
{\textbf{iCantMismaEspecie}(\In{p}{pkemon}, \In{j}{juego}) $\to$ $res$ : nat}
\begin{algorithmic}[1]

\State $res$ $\gets$ $j$.cantPokemon.Obtener($p$)  \Comment $O(|p|)$

\medskip
\Statex \underline{Complejidad:} $O(|p|)$
\Statex \underline{Justificaion:} La unica operacion es $O(|p|)$

\end{algorithmic}
\end{algorithm}  



\begin{algorithm}[H]
{\textbf{iExpulsados}(\In{j}{juego}) $\to$ $res$ : conj(jugador)}
\begin{algorithmic}[1]

\State nat $i$ $\gets$ 0 \Comment $O(1)$

\State conj(jugador) $js$ $\gets$ Vac\'io() \Comment $O(1)$

\While{$i$ $<$ Longitud($j$.jugadores) $-$ 1} \Comment se repite Longitud($j$.jugadores) veces $O(1)$
  \If{$j$.jugadores[$i$].sanciones $\geq$ 5} \Comment $O(1)$
    \State AgregarRapido($js$, $j$.jugadores[$i$].id) \Comment $O(1)$
  \EndIf
\EndWhile

\State $res$ $\gets$ $js$ \Comment $O(1)$

\medskip
\Statex \underline{Complejidad:} $O(J)$
\Statex \underline{Justificaion:} Siendo $J$ la cantidad total de jugadores, se los recorre todos buscando los expulsados.

\end{algorithmic}
\end{algorithm}  
  

% movValido

\begin{algorithm}[H]
{\textbf{iMovValido}(\In{e}{jugador}, \In{c}{coor}, \In{j}{juego}) $\to$ $res$ : bool}
\begin{algorithmic}[1]

\Statex \underline{MovValido} : Funci\'on privada 
\Statex \underline{Descripci\'on} : Dice si el movimiento entre la posicion del jugador y la nueva coordenada c, es valido 
\Statex \underline{Pre}: $e \in$ jugadoresConctados($j$) $\land$ posExistente($c$, $j$.mapa) 
\Statex \underline{Post}: $res$ = hayCamino($c$, $j$.jugadores[$e$].pos, $j$.mapa) $\land$ 
\Statex $ $\hspace*{2cm} DistEuclidea($c$, $j$.jugadores[$e$].pos) $\leq$ 100
\Statex \underline{Complejidad}: $O(1)$ 

\State bool $camino \gets$ HayCamino($c$, $j$.jugadores[$e$].pos, $j$.mapa) \Comment $O(1)$
\State bool $distancia \gets$ (DistEuclidea($c$, $j$.jugadores[$e$].pos) $\leq$ 100) \Comment $O(1)$
\State $res$ $\gets$ $camino \land distancia$ \Comment $O(1)$

\medskip
\Statex \underline{Complejidad:} $O(1)$
\Statex \underline{Justificaion:} Todas las operaciones usadas son O(1): O(1) + O(1) + O(1) = O(1)

\end{algorithmic}
\end{algorithm}  
  

% sumarUnoEnJug

\begin{algorithm}[H]
{\textbf{iSumarUnoEnJug}(\In{e}{jugador}, \In{c}{coor}, \Inout{j}{juego})}
\begin{algorithmic}[1]

\Statex \underline{SumarUnoEnJug} : Funci\'on privada 
\Statex \underline{Descripci\'on} : Suma uno a la cantidad de pokemons p que tiene el jugador 
\Statex \underline{Pre}: $j = j_0$ $\land$  $e \in$ jugadores($j$)
\Statex \underline{Post}: $\#$pokemons($p$, $j_0$.jugadores[$e$].pokemons) = $\#$pokemons($p$, $j$.jugadores[$e$].pokemons) + 1
\Statex \underline{Complejidad}: $O(|P|)$ 

% Lo defino bien
\If{Def?($p$, $j$.cantPokemon)} \Comment $O(|P|)$
  \State Definir($j$.cantPokemon, $p$, Obtener($p$, $j$.cantPokemon) + 1) \Comment $O(|P|)$
\Else
  \State Definir($j$.cantPokemon, $p$, 1)  \Comment $O(|P|)$
\EndIf


\medskip
\Statex \underline{Complejidad:} $O(|P|)$
\Statex \underline{Justificaion:} Se ejecuta la guarda en $O(|P|)$ y en cualquier rama hay una operacion $O(|P|)$. $O(|P|)$ + $O(|P|)$ = $O(|P|)$

\end{algorithmic}
\end{algorithm}  
  

$ $\newline
$ $\newline
$ $\newline


% dameJugadoresEnPokerango

%\begin{algorithm}[H]
{\textbf{iDameJugadoresEnPokerango}(\In{c}{coor}, \In{j}{juego}) $\to$ $res$ : vector(jugador)}
\begin{algorithmic}[1]

\Statex \underline{DameJugadoresEnPokerango} : Funci\'on privada 
\Statex \underline{Descripci\'on} : Devuelve un vector con todos los jugadores que pueden esperar captura que estan en el rango de c 
\Statex \underline{Pre}: posValida($c$, $j$.mapa)
\Statex \underline{Post}: $res \igobs$ entrenadoresPosibles($c$, jugadores($j$), $j$)
\Statex \underline{Complejidad}: $O(EC)$ 
\Statex \underline{Aliasing}: Devuelve el vector por referencia 

\State vector(jugador) $jugsRadio \gets$ Vacio() \Comment $O(1)$

\State nat $x \gets$ latitud(c)    \Comment $O(1)$
\State nat $y \gets$ longitud(c)   \Comment $O(1)$

\State coor $coorConPokemon$    \Comment $O(1)$

\If{j.pokenodos[$x$][$y$] $\neq$ NULL}     \Comment $O(1)$
    \State AgregarAtrasJugsQueEstanEnPos($jugsRadio$, crearCoordenada($x$, $y$), $c$, $j$)    \Comment $O(EC)$
\EndIf

\If{$x > 0$}
    \If{j.pokenodos[$x-1$][$y$] $\neq$ NULL}     \Comment $O(1)$
        \State AgregarAtrasJugsQueEstanEnPos($jugsRadio$, crearCoordenada($x-1$, $y$), $c$, $j$)    \Comment $O(EC)$
    \EndIf

    \If{$y > 0$}

        \If{j.pokenodos[$x-1$][$y-1$] $\neq$ NULL}     \Comment $O(1)$
            \State AgregarAtrasJugsQueEstanEnPos($jugsRadio$, crearCoordenada($x-1$, $y-1$), $c$, $j$)    \Comment $O(EC)$
        \EndIf

    \EndIf

    % tam(m) no puede ser 0 porque existe una coordenada al menos (x,y)
    \If{$y < tam(m) - 1$}
        \If{j.pokenodos[$x-1$][$y+1$] $\neq$ NULL}     \Comment $O(1)$
            \State AgregarAtrasJugsQueEstanEnPos($jugsRadio$, crearCoordenada($x-1$, $y+1$), $c$, $j$)    \Comment $O(EC)$
        \EndIf
    \EndIf

    \If{$x-1 > 0$}
        \If{j.pokenodos[$x-2$][$y$] $\neq$ NULL}     \Comment $O(1)$
            \State AgregarAtrasJugsQueEstanEnPos($jugsRadio$, crearCoordenada($x-2$, $y$), $c$, $j$)    \Comment $O(EC)$
        \EndIf
    \EndIf

\EndIf

\If{$y > 0$}

    \If{j.pokenodos[$x$][$y-1$] $\neq$ NULL}     \Comment $O(1)$
        \State AgregarAtrasJugsQueEstanEnPos($jugsRadio$, crearCoordenada($x$, $y-1$), $c$, $j$)    \Comment $O(EC)$
    \EndIf

    \If{$y-1 > 0$}

        \If{j.pokenodos[$x$][$y-2$] $\neq$ NULL}     \Comment $O(1)$
            \State AgregarAtrasJugsQueEstanEnPos($jugsRadio$, crearCoordenada($x$, $y-2$), $c$, $j$)    \Comment $O(EC)$
        \EndIf

    \EndIf

\EndIf

\If{$y < tam(m) - 1$}

    \If{j.pokenodos[$x$][$y+1$] $\neq$ NULL}     \Comment $O(1)$
        \State AgregarAtrasJugsQueEstanEnPos($jugsRadio$, crearCoordenada($x$, $y+1$), $c$, $j$)    \Comment $O(EC)$
    \EndIf


    \If{$tam(m) > 1 \land y < tam(m) - 2$}
        \If{j.pokenodos[$x$][$y+2$] $\neq$ NULL}     \Comment $O(1)$
            \State AgregarAtrasJugsQueEstanEnPos($jugsRadio$, crearCoordenada($x$, $y+2$), $c$, $j$)    \Comment $O(EC)$
        \EndIf


    \EndIf

\EndIf

\If{$x < tam(m) - 1$}
    \If{j.pokenodos[$x+1$][$y$] $\neq$ NULL}     \Comment $O(1)$
        \State AgregarAtrasJugsQueEstanEnPos($jugsRadio$, crearCoordenada($x+1$, $y$), $c$, $j$)    \Comment $O(EC)$
    \EndIf

    \If{$y > 0$}
        \If{j.pokenodos[$x+1$][$y-1$] $\neq$ NULL}     \Comment $O(1)$
            \State AgregarAtrasJugsQueEstanEnPos($jugsRadio$, crearCoordenada($x+1$, $y-1$), $c$, $j$)    \Comment $O(EC)$
        \EndIf
    \EndIf

    \If{$y < tam(m)-1$}
        \If{j.pokenodos[$x+1$][$y+1$] $\neq$ NULL}     \Comment $O(1)$
            \State AgregarAtrasJugsQueEstanEnPos($jugsRadio$, crearCoordenada($x+1$, $y+1$), $c$, $j$)    \Comment $O(EC)$
        \EndIf

    \EndIf
\EndIf

\If{$tam(m) > 1 \land x < tam(m) - 2$}
    \If{j.pokenodos[$x+2$][$y$] $\neq$ NULL}     \Comment $O(1)$
        \State AgregarAtrasJugsQueEstanEnPos($jugsRadio$, crearCoordenada($x+21$, $y$), $c$, $j$)    \Comment $O(EC)$
    \EndIf
\EndIf

\State $res \gets jugsRadio$ \Comment Por referencia $O(1)$

\medskip
\State \underline{Complejidad:} $O(EC)$ % por enunciado
\State \underline{Justificacion:} En peor caso agrego jugadores de 13 posiciones, donde ese agregar me cuesta O(EC) cada vez. $O(EC)$ + $O(EC)$ + ... + $O(EC)$ = $O(EC)$ 

\end{algorithmic}
%\end{algorithm}


  


% agregarAtrasJugsEnPos

\begin{algorithm}[H]
{\textbf{iAgregarAtrasJugsQueEstanEnPos}(\Inout{jugs}{vector(jugador)}, \In{posJug}{coor}, \In{posPoke}{coor}, \In{j}{juego})}
\begin{algorithmic}[1]

\Statex \underline{AgregarAtrasJugsQueEstanEnPos} : Funci\'on privada 
\Statex \underline{Descripci\'on} : Agrega los jugadores en condiciones de capturar que se encuentran en esa posicion, al vector pasado por parametros,   
\Statex \underline{Pre}: $jugs = jugs_0$ $\land$  posValida($posJug$, $j$.mapa) $\land$ posValida($posPoke$, $j$.mapa)
\Statex \underline{Post}: $jugs = jugs_0 con los jugadores en condiciones de capturar agregados atras$
\Statex \underline{Complejidad}: $O(EC)$ 

\State lista(jugador) $jugsEnPos \gets$ $j$.grillaJugs[Latitud($posJug$)][Longitud($posJug$)] \Comment Por referencia $O(1)$
\State itLista $iterJug \gets$ CreatIt($jugsEnPos$) \Comment $O(1)$

\While{HaySiguiente($iterJug$)} \Comment $O(longitud(jugsEnPos))$
    \State nat $e \gets$ Siguiente($iterJug$) \Comment $O(1)$

    \If{Conectado($e$) $\land$ HayCamino(Posicion($e$), $posPoke$)}
        \State AgregarAtras($jugs$, $e$) \Comment $O(1) amortizado$
    \EndIf 

    \State Avanzar($iterJug$) \Comment $O(1)$


\EndWhile

\medskip
\Statex \underline{Complejidad:} $O(EC)$
\Statex \underline{Justificaion:} En el peor caso todos los jugadores que estan en la posici\'on dada son todos los que tienen que esperar la captura. Como longitud($jugsEnPos$) $\leq$ EC, O(longitud($jugsEnPos$)) = O(EC)

\end{algorithmic}
\end{algorithm}  
  
\end{Algoritmos}



\subsection{Servicios usados} 

De Mapa \\
 - iTam(map) debe ser O(1) \\
 - HayCamino( coord, coord, map) debe ser  O(1) \\
 - PosExistente( coord,  map)  debe ser O(1) \\

De Coordenada \\
 - longitud(coor) debe ser O(1) \\
 - distEuclidea( coor, coor)  debe ser O(1) \\
 

De Lista enlazada \\
 - CrearIt(lista) debe ser O(1) \\
 - EliminarSiguiente( itLista($\alpha$)) debe ser O(1) \\
 - Avanzar(itLista($\alpha$)) debe ser O(1) \\

De Vector \\
 - AgregarAtras( vector($\alpha$), $\alpha$ $\alpha$) debe ser O(f(long(v)) + copy(a))\\

De Cola \\
 - Encolar(colaEntr, entrenador) debe ser O(log(EC)) \\

De Diccstring \\
iVacio() debe ser O(1)
 - Borrar( string, diccString($\alpha$)) debe ser O(|P|) \\
 - Def?(string,  diccString($\alpha$)) debe ser O(|P|) \\
 - Definir(diccString($\alpha$), string, $\alpha$ $\alpha$) debe ser O(|P|) \\
 - Obtener(string, diccString($\alpha$)) debe ser $\alpha$ O(|P|) \\

De Conjunto Lineal \\
 - AgregarRapido( conj($\alpha$), $\alpha$ $\alpha$) debe ser O(copy(a)) \\
 - EliminarSiguiente(itConj($\alpha$)) debe ser O(1) \\
 - HaySiguiente( itConjAcotado) debe ser O(1) \\
 - Avanzar( itConj($\alpha$)) debe ser O(1) \\
 - Siguiente(tConj($\alpha$)) debe ser O(1) \\

