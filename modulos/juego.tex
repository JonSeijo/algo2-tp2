\begin{Interfaz}


\textbf{se explica con}: \tadNombre{Juego}.

\textbf{g\'eneros}: \TipoVariable{juego}.

\Title{Operaciones b\'asicas de Juego}



% GENERADORES %


\InterfazFuncion{crearJuego}{\In{m}{map}}{juego}%
{$res \igobs crearJuego(m)$}%
[$\Theta(INFINITO, VER DESPUES)$]
[genera una juego con el mapa \texttt{m} y sin jugadores.]


\InterfazFuncion{agregarPok\'emon}{\In{p}{pokemon}, \In{c}{coord}, \Inout{j}{juego}}{}
[$j_0 \igobs j \land posExistente(c, mapa(j)) \land p \not \in pokemones(j) Y PUEDOAGREGARPOKEMON() QUE CHECKEE LAS DISTANCIAS $]  
{$j \igobs agregarPokemon(p, c, j_0)  \land p \in pokemones(j)$}
[$\Theta(¡¡completar!!)$]
[agrega pok\'emon \texttt{p} al juego \texttt{j} en la coordenada \texttt{c}.]


\InterfazFuncion{agregarJugador}{\In{j}{juego}}{nat}% REVISAR SI HAY QUE DEVOLVER NAT
[$ j_0 \igobs j $]
{$res \igobs ProxId(j_0) \land j \igobs agregarJugador(j_0)$}%
[$\Theta(\# jugadores(j) REVISAR)$]
[agrega un jugador al juego \texttt{j} con id igual a ProxId(j).]


\InterfazFuncion{conectarse}{\Inout{j}{juego}, \In{c}{coor}, \In{e}{jugador}}{}%
[$j \igobs j_0 \land e \in jugadores(j) \yluego \neg estaConectado(e, j) \land posExistente(c, mapa(j)) $]
{$estaConectado(e, j) Y cambian capturables y contadores y sarasa$}%
[$O(log(EC))$] % Es asi por enunciado
[Conecta al jugador e en la posicion c]


\InterfazFuncion{desconectarse}{\Inout{j}{juego}, \In{e}{jugador}}{}%
[$j \igobs j_0 \land e \in jugadores(j) \yluego estaConectado(e, j)$]
{$\neg estaConectado(e, j) Y cambian capturables y contadores y sarasa$}%
[$O(log(EC))$] % Es asi por enunciado
[Desconecta al jugador e del juego]


\InterfazFuncion{moverse}{\Inout{j}{juego}, \In{c}{coor}, \In{e}{jugador}}{}%
[$j \igobs j_0 \land e \in jugadores(j) \yluego estaConectado(e, j) \land posExistente(c, mapa(j)) $]
{$cambia posicion y cambian capturables y contadores y sarasa$}%
[$O((PC + PS) * |P| + EC * log(EC))$] % Es asi por enunciado
[Mueve al jugador e en la posicion c si es valido, sino sanciona o captura o sarasa]

% OBSERVADORES

%mapa : juego −→ map
\InterfazFuncion{Mapa}{\In{j}{juego}}{map}%
[true]
{$res = mapa(j)$}%
[$O(1)$] % HAGAMOS QUE LO DEVUELVA POR REFERENCIA
[Devuelve el mapa del juego]
{Es por referencia, produce aliasing}


%jugadores : juego −→ conj(jugador)
\InterfazFuncion{Jugadores}{\In{j}{juego}, \In{e}{jugador}}{ITERADOR}%
[true]
{$TENGO QUE DEVOLVER ITERADOR VER ENUNCIADO$}%
[$O(1)$] % por enunciado. "Ver que siguiente no tiene por que ser O(1)"
[Devuelve un iterador al jugador. Puede borrarse]



%estaConectado : jugador e × juego j −→ bool  {e ∈ jugadores(j)}
\InterfazFuncion{EstaConectado}{\In{j}{juego}, \In{e}{jugador}}{bool}%
[$e \in jugadores(j)$]
{$res = estaConectado(e, j)$}%
[$O(1)$] % por enunciado. "Ver que siguiente no tiene por que ser O(1)"
[Devuelve true si el jugador esta conectado]



%sanciones : jugador e × juego j −→ nat {e ∈ jugadores(j)}
\InterfazFuncion{Sanciones}{\In{j}{juego}, \In{e}{jugador}}{nat}%
[$e \in jugadores(j)$]
{$res = sanciones(e, j)$}%
[$O(1)$] % por enunciado. 
[Devuelve la cantidad de sanciones de un jugador]



%posicion : jugador e × juego j −→ coor  {e ∈ jugadores(j) ∧ L estaConectado(e, j)}
\InterfazFuncion{Posicion}{\In{j}{juego}, \In{e}{jugador}}{coor}%
[$e \in jugadores(j)  \yluego estaConectado(e, j)$]
{$res = posicion(e, j)$}%
[$O(1)$] % por enunciado. 
[Devuelve la posicion actual de un jugador]



%pokémons : jugador e × juego j −→ multiconj(pokémon) {e ∈ jugadores(j)}
%VER
\InterfazFuncion{Pokemons}{\In{j}{juego}, \In{e}{jugador}}{multiconj}%
[$e \in jugadores(j)$]
{$res = ITERADOR?? VER ENUNCIADO POCO CLARO$}%
[$O(1)$] % por enunciado. 
[FRUTA]
{TENEMOS QUE HACER EL MULTICONJUNTO? ITERADOR A TUPLA POR ENUNCIADO? VER SI ESTA EN MODS BASICOS SINO QUE SEA VECTOR Y CHAU}



%expulsados : juego −→ conj(jugador)
\InterfazFuncion{Expulsados}{\In{j}{juego}}{conj(jugador)}%
[true]
{$res = expulsados(j)$}%
[$O(\#jugadores(j))$] % VER COMO LA IMPLEMENTAMOS   SOSPECHO O(#jugadores). 
[Devuelve un conjunto con los jugadores expulsados]


%posConPokémons : juego −→ conj(coor)
\InterfazFuncion{PosConPokemons}{\In{j}{juego}}{conj(coor)}%
[true]
{$res = posConPokemons(j)$}%
[$O(1)$] % Devuelve por referencia el conjunto, asi que habria que ir construyendolo
[Devuelve un conjunto con las posiciones del mapa que tienen pokemons. Aliasing: devuelve el conjunto por referencia]
% ACA DEVOLVEMOS LAS COORDENADAS DE LOS POKENODOS



%pokémonEnPos : coor c × juego j −→ pokémon {c ∈ posConPokémons(j)}
\InterfazFuncion{PokemonEnPos}{\In{j}{juego}, \In{c}{coor}}{pokemon}%
[$c \in posConPokemons(j)$]
{$res = pokemonEnPos(c, j)$}%
[$O(1)$] % Ibamos a guardar el pokemon en la tupla del pokenodo
[Devuelve el pokemon que se encuentra en la posicion c. Sin aliasing, devuelve por copia]


%cantMovimientosParaCaptura : coor c × juego j −→ nat {c ∈ posConPokémons(j)}
\InterfazFuncion{CantMovimientosParaCaptura}{\In{c}{coor}, \In{j}{juego}}{nat}%
[$c \in posConPokemons(j)$] %requiere que c sea pos de pokenodo
{$res = cantMovimientosParaCaptura(c, j)$}%
[$O(1)$] % Ibamos a guardar el contador en la tupla del pokenodo
[Devuelve el numero de movimientos que indican cuando se captura un pokemon]


% otras operaciones publicas

% puedoAgregarPokémon : coor c × juego j −→ bool
\InterfazFuncion{PuedoAgregarPokemon}{\In{c}{coor}, \In{j}{juego}}{bool}%
[true] 
{$res = puedoAgregarPokemon(c, j)$}  % Ver que mucho no me convence
[$O(1)$] 
[Devuelve verdadero si la coordenada es valida y no hay ningun pokemon en el territorio]


% hayPokémonCercano : coor c × juego j −→ bool
\InterfazFuncion{HayPokemonCercano}{\In{c}{coor}, \In{j}{juego}}{bool}%
[true] 
{$res = hayPokemonCercano(c, j)$}  % Ver que mucho no me convence
[$O(1)$] 
[Devuelve verdadero si hay algun pokemon en el territorio]


% posPókemonCercano : coor c × juego j −→ coor {hayPokémonCercano(c,j)}
\InterfazFuncion{PosPokemonCercano}{\In{c}{coor}, \In{j}{juego}}{coor}%
[hayPokemonCercano(c, j)] 
{$res = posPokemonCercano(c, j)$}  % Ver que mucho no me convence
[$O(1)$] 
[Devuelve la posicion del pokemon que esta en territorio]


% entrenadoresPosibles : coor c × conj(jugador) es × juego j −→ conj(jugador)
% {hayPokémonCercano(c,j) ∧ es ⊆ jugadoresConectados(j)}
\InterfazFuncion{EntrenadoresPosibles}{\In{c}{coor},\In{es}{conj(jugador)}, \In{j}{juego}}{coor}%
[hayPokemonCercano(c, j) $\land$ es $\subset$ jugadoresConectados(j)] 
{$res = entrenadoresPosibles(c, es, j)$}  % Ver que mucho no me convence
[$O(1)$] % Se supone que vamos a guardar los posibles en un "AVL" en la coordenada del pokenodo
[Devuelve un conjunto con los entrenadores que estan en condiciones de capturar el pokemon que se encuentra en el rango de c. Que esten en condiciones de capturar significa que estan en rango2 del pokemon y que existe un camino hacia el]


% indiceRareza : pokémon p × juego j −→ nat  {p ∈ todosLosPokémons(j)}
\InterfazFuncion{IndiceRareza}{\In{p}{pokemon}, \In{j}{juego}}{nat}%
[p $\in$ todosLosPokemons(j)] 
{$res = indiceRareza(p, j)$}  % Ver que mucho no me convence
[$O(|P|)$] % es una cuenta, obtener los numeros de p nos cuesta recorrer el trie
[Devuelve el indice de rareza del pokemon dado]


% cantPokémonsTotales : juego −→ nat
\InterfazFuncion{cantPokemonsTotales}{\In{j}{juego}}{nat}%
[true] 
{$res = cantPokemonsTotales(p, j)$}  % Ver que mucho no me convence
[$O(1)$] % tiene que ser O(1) para que el indice de rareza lo calculemos rapido, 
% Podemos guardar el dato como un valor de la estructura del juego
[Devuelve la cantidad de pokemons totales del juego]


% cantMismaEspecie : pokémon × multiconj(pokémon) −→ nat
VERVERVER \\
HAY DIFERENCIA ENTRE LA ESPECIFICACION Y SU SIGNATURA \\
\InterfazFuncion{cantMismaEspecie}{\In{j}{juego}}{nat}%
[true] 
{$res = cantMismaEspecie(j)$}  % Ver que mucho no me convence
[$O(iNFINITO)$] % tiene que ser O(1) para que el indice de rareza lo calculemos rapido, 
% Podemos guardar el dato como un valor de la estructura del juego
[Devuelve la cantidad de pokemons totales del juego]


\end{Interfaz}

~ 

\begin{Representacion}

% se representa con una tupla(variable, variable, pokenodos, )


NO ES DEFINITIVO, PERO PARA IR TENIENDO LA IDEA
 
\begin{Estructura}{Mapa}[map]

\begin{Tupla}[map]  
	\tupItem{cantPokemon}{diccTrie}  % Tendria la cantidad total de cada pokemon
	\tupItem{\\ map}{mapa}  % Tendria el mapa con el que se crea
	\tupItem{\\ jugadores}{vector(jugStruc)}  % Tendria los datos de los jugadores, o iteradores, VER
	\tupItem{\\ grillaJugs}{vector(vector(vector(jugador)))} % Una grilla R2 del tamaño del mapa donde en cada posicion hay un vector de los jugadores que estan en esa posicion
	\tupItem{\\ pokenodos}{vector(vector(pokeStruc))}  % Una grilla R2 del tamaño del mapa donde en cada coordenada puede haber un pokenodo (ver en REP que tienen que estar a cierta distancia)
\end{Tupla}
\end{Estructura}

    \begin{Tupla}[pokeStruc]
      \tupItem{poke}{pokemon}
      \tupItem{\\ contador}{nat}%
	  \tupItem{\\ entrenadores}{HEAP(JUGADOR)} % Deberia ser como sea que se llame el modulo, cola_de_prioridadJug o pokeHeap, nose, pero en el fondo seria un heap
    \end{Tupla}
    
    
    \begin{Tupla}[jugStruc]
      \tupItem{id}{nat}
      \tupItem{\\ sanciones}{nat}%
	  \tupItem{\\ conectado}{bool}
	  \tupItem{\\ pos}{coor}
	  \tupItem{\\ pokemons}{VECTOR(TUPLA(POKEMON, CANTIDAD))} % Hay que ver como nos conviene mantener a los pokemones que capturo el jugador para que no nos arruine la complejidad    
    \end{Tupla}


\RepFc[]{true}

  

\AbsFc[]{}

\end{Representacion}

\begin{Algoritmos}
  
\end{Algoritmos}