\begin{Algoritmos}
\subsection{Algoritmos ColaPrioridad}

% vacio

\begin{algorithm}[H]
{\textbf{iVacia}() $\to$ $res$ : colaPrioridad}
\begin{algorithmic}[1]
    \State $res$ $\gets$  $\langle$ NULL, NULL $\rangle$   \Comment $O(1)$

    \medskip
    \Statex \underline{Complejidad:} $O(1)$
\end{algorithmic}
\end{algorithm}
   

% esVacia
\begin{algorithm}[H]
{\textbf{iEsVacia?}(\In{c}{colaPrioridad($\alpha$)}) $\to$ $res$ : bool}
\begin{algorithmic}[1]
    \State $res$ $\gets$ ($c$.raiz = NULL) \Comment $O(1)$

    \medskip
    \Statex \underline{Complejidad:} $O(1)$
\end{algorithmic}
\end{algorithm}


% proximo
\begin{algorithm}[H]
{\textbf{iPr\'oximo}(\In{c}{colaPrioridad($\alpha$)}) $\to$ $res$ : $\alpha$}
\begin{algorithmic}[1]
    \State $res$ $\gets$ ($c$.raiz $\rightarrow$ elem) \Comment $O(1)$

    \medskip
    \Statex \underline{Complejidad:} $O(1)$
\end{algorithmic}
\end{algorithm}
 

% encolar
\begin{algorithm}[H]
{\textbf{iEncolar}(\In{c}{colaPrioridad($\alpha$)}, \In{e}{$\alpha$}) $\to$ $res$ : itColaPrioridad}
\begin{algorithmic}[1]

    \If{EsVacia?($c$)}
        \State nodo $nuevoNodo \gets$ $\langle$ e, NULL, NULL, NULL $\rangle$   \Comment $O(1)$
        \State $c$.raiz $\gets$ $nuevoNodo$ \Comment $O(1)$
    \Else
        \If{EstaCompleto($c$)}  \Comment $O(log(\#(c)))$
            \State nodo $nodoActual \gets$ $c$.raiz \Comment $O(1)$
            \While{$nodoActual$ $\to$ izq $\neq$ NULL}  \Comment $O(log(\#(c)))$
                \State $nodoActual$ $\gets$ ($nodoActual$ $\to$ izq)  \Comment $O(1)$
            \EndWhile
            \State nodo $nuevoNodo \gets$ $\langle$ e, $nodoActual$, NULL, NULL $\rangle$   \Comment $O(1)$
            \State ($nodoActual$ $\to$ izq) $\gets$ $nuevoNodo$ \Comment $O(1)$
        \Else
            \If{EsHijoIzquierdo($c$.ultimo)}  \Comment $O(1)$
                \State nodo $nuevoNodo \gets$ $\langle$ e, $c$.ultimo $\to$ padre, NULL, NULL $\rangle$   \Comment $O(1)$
                \State ($c$.ultimo $\to$ padre $\to$ izq) $\gets$ $nuevoNodo$ \Comment $O(1)$
            \Else %esHijoDerecho
                \State nodo $nuevoNodo \gets$ $\langle$ e, $c$.ultimo $\to$ padre $\to$ padre $\to$ der, NULL, NULL $\rangle$   \Comment $O(1)$
                \State ($c$.ultimo $\to$ padre $\to$ padre $\to$ der $\to$ izq) $\gets$ $nuevoNodo$ \Comment $O(1)$
            \EndIf
        \EndIf
    \EndIf
    \State $ $
    \State $c$.ultimo $\gets$ $nuevoNodo$ \Comment $O(1)$   
    \State SiftUp($c$.ultimo) \Comment $O(log(\#(c)))$

    NO OLVIDAR DEVOLVER ITERADOR AL ULTIMO

    \medskip
    \Statex \underline{Complejidad:} $O(log(\#(c)))$
    \Statex \underline{Justificaci\'on:} El While es O(log($\#$c)) porque como el nodo forma parte de \'arbol, yendo siempre hacia abajo a la izquierda recorro como m\'aximo la altura del \'arbol: log($\#$c). La complejidad del algoritmo en peor caso es la suma de las complejidades: $O(1)$ + $O(1)$ + .. $O(1)$ + $O(log(\#(c)))$ + $O(log(\#(c)))$ + $O(log(\#(c)))$ = $O(log(\#(c)))$ por \'algebra de \'ordenes.
\end{algorithmic}
\end{algorithm}
 





$ $\newline
$ $\newline

% estaCompleto
% explicacion: si el de mas abajo a la derecha es el ultimo, entonces esta completo
\textbf{Funcion privada}\\
\textbf{Pre} $\equiv$ \{$\neg$ vac\'ia?($c$)\}\\%
\textbf{Post} $\equiv$ \{Res es true sii el ultimo es el de mas abajo a la derecha\}%
\begin{algorithm}[H]
{\textbf{iEstaCompleto}(\In{c}{colaPrioridad($\alpha$)}) $\to$ $res$ : bool}
\begin{algorithmic}[1]
    
    \State nodo $nodoActual \gets$ $c$.raiz \Comment $O(1)$
    \While{$nodoActual$ $\rightarrow$ der $\neq$ NULL}
        $nodoActual$ $\gets$ $nodoActual$ $\rightarrow$ der \Comment $O(1)$
    \EndWhile

    \State $res \gets$ ($nodoActual$ = $c$.ultimo)

    \medskip
    \Statex \underline{Complejidad:} $O(1)$
\end{algorithmic}
\end{algorithm}
    

$ $\newline

% swapValores
% explicacion: swap de los valores
\textbf{Funcion privada}\\
\textbf{Pre} $\equiv$ \{$na$ $\igobs$ $na_0$ $\land$ $nb$ $\igobs$ $nb_0$ $\land$ $na$ $\neq$ NULL $\land$ $nb$ $\neq$ NULL\}\\%
\textbf{Post} $\equiv$ \{($na \to$ elem $\igobs$ $nb_0 \to$ elem) $\land$ ($nb \to$ elem $\igobs$ $na_0 \to$ elem)\}%
\begin{algorithm}[H]
{\textbf{iSwapValores}(\Inout{na}{nodo}, \Inout{nb}{nodo}) $\to$ $res$ : bool}
\begin{algorithmic}[1]
    
    \State $tmp \gets$ (na $\to$ elem) \Comment $O(1)$
    \State ($na \to$ elem) $\gets$ ($nb \to$ elem) \Comment $O(1)$
    \State ($nb \to$ elem) $\gets$ tmp \Comment $O(1)$

    \medskip
    \Statex \underline{Complejidad:} $O(1)$
\end{algorithmic}
\end{algorithm}

   
$ $\newline
   

%siftUp
%explicacion: dado un nodo, lleva el elemento hacia arriba hast que este en la pos correcta
\textbf{Funcion privada}\\
\textbf{Pre} $\equiv$ \{$n$ $\neq$ NULL $\land$ el nodo esta en la estructura de C\}\\%
\textbf{Post} $\equiv$ \{El elemento de n se fue swappeando con su padre mientras era menor\}%
\begin{algorithm}[H]
{\textbf{iSiftUp}(\Inout{n}{nodo})}
\begin{algorithmic}[1]

    \While{($n \to$ padre $\neq$ NULL) $\land$ (($n \to$ elem) < ($n \to$ padre $\to$ elem))} \Comment $O(log(\#c))$
        \State Swap($n$, $n \to$ padre) \Comment $O(1)$
        \State $n$ $\gets$ ($n \to$ padre) \Comment $O(1)$
    \EndWhile

    \medskip
    \Statex \underline{Complejidad:} $O(1)$
    \Statex \underline{Justificacion:} En el peor caso se recorre toda la altura del arbol: O(log($\#$C))
\end{algorithmic}
\end{algorithm}
       
   

   
\end{Algoritmos}