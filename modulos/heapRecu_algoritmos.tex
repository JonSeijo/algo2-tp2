\begin{Algoritmos}
\subsection{Algoritmos ColaPrioridad}

% vacio

\begin{algorithm}[H]
{\textbf{iVacia}() $\to$ $res$ : colaPrioridad}
\begin{algorithmic}[1]
    \State $res$ $\gets$  $\langle$ NULL, NULL $\rangle$   \Comment $O(1)$

    \medskip
    \Statex \underline{Complejidad:} $O(1)$
\end{algorithmic}
\end{algorithm}


% esVacia
\begin{algorithm}[H]
{\textbf{iEsVacia?}(\In{c}{colaPrioridad($\alpha$)}) $\to$ $res$ : bool}
\begin{algorithmic}[1]
    \State $res$ $\gets$ ($c$.raiz = NULL) \Comment $O(1)$

    \medskip
    \Statex \underline{Complejidad:} $O(1)$
\end{algorithmic}
\end{algorithm}


% proximo
\begin{algorithm}[H]
{\textbf{iPr\'oximo}(\In{c}{colaPrioridad($\alpha$)}) $\to$ $res$ : $\alpha$}
\begin{algorithmic}[1]
    \State $res$ $\gets$ ($c$.raiz $\rightarrow$ elem) \Comment $O(1)$

    \medskip
    \Statex \underline{Complejidad:} $O(1)$
\end{algorithmic}
\end{algorithm}


% encolar
%\begin{algorithm}[H]
{\textbf{iEncolar}(\In{c}{colaPrioridad($\alpha$)}, \In{e}{$\alpha$}) $\to$ $res$ : itColaPrioridad}
\begin{algorithmic}[1]

    \If{EsVacia?($c$)}
        \State nodo $nuevoNodo \gets$ $\langle$ e, NULL, NULL, NULL $\rangle$   \Comment $O(1)$
        \State $c$.raiz $\gets$ $nuevoNodo$ \Comment $O(1)$
    \Else
        \If{EstaCompleto($c$)}  \Comment $O(log(\#(c)))$
            \State nodo $nodoActual \gets$ $c$.raiz \Comment $O(1)$
            \While{$nodoActual$ $\to$ izq $\neq$ NULL}  \Comment $O(log(\#(c)))$
                \State $nodoActual$ $\gets$ ($nodoActual$ $\to$ izq)  \Comment $O(1)$
            \EndWhile
            \State nodo $nuevoNodo \gets$ $\langle$ e, $nodoActual$, NULL, NULL $\rangle$   \Comment $O(1)$
            \State ($nodoActual$ $\to$ izq) $\gets$ $nuevoNodo$ \Comment $O(1)$
        \Else
            \If{EsHijoIzquierdo($c$.ultimo)}  \Comment $O(1)$
                \State nodo $nuevoNodo \gets$ $\langle$ e, $c$.ultimo $\to$ padre, NULL, NULL $\rangle$   \Comment $O(1)$
                \State ($c$.ultimo $\to$ padre $\to$ izq) $\gets$ $nuevoNodo$ \Comment $O(1)$
            \Else %esHijoDerecho
                \State nodo $nuevoNodo \gets$ $\langle$ e, $c$.ultimo $\to$ padre $\to$ padre $\to$ der, NULL, NULL $\rangle$   \Comment $O(1)$
                \State ($c$.ultimo $\to$ padre $\to$ padre $\to$ der $\to$ izq) $\gets$ $nuevoNodo$ \Comment $O(1)$
            \EndIf
        \EndIf
    \EndIf
    \State $ $
    \State $c$.ultimo $\gets$ $nuevoNodo$ \Comment $O(1)$
    \State SiftUp($c$.ultimo) \Comment $O(log(\#(c)))$

    NO OLVIDAR DEVOLVER ITERADOR AL ULTIMO

    \medskip
    \Statex \underline{Complejidad:} $O(log(\#(c)))$
    \Statex \underline{Justificaci\'on:} El While es O(log($\#$c)) porque como el nodo forma parte de \'arbol, yendo siempre hacia abajo a la izquierda recorro como m\'aximo la altura del \'arbol: log($\#$c). La complejidad del algoritmo en peor caso es la suma de las complejidades: $O(1)$ + $O(1)$ + .. $O(1)$ + $O(log(\#(c)))$ + $O(log(\#(c)))$ + $O(log(\#(c)))$ = $O(log(\#(c)))$ por \'algebra de \'ordenes.
\end{algorithmic}
%\end{algorithm}






$ $\newline
$ $\newline

% estaCompleto
% explicacion: si el de mas abajo a la derecha es el ultimo, entonces esta completo
\textbf{Funcion privada}\\
\textbf{Pre} $\equiv$ \{$\neg$ vac\'ia?($c$)\}\\%
\textbf{Post} $\equiv$ \{Res es true sii el ultimo es el de mas abajo a la derecha\}%
\begin{algorithm}[H]
{\textbf{iEstaCompleto}(\In{c}{colaPrioridad($\alpha$)}) $\to$ $res$ : bool}
\begin{algorithmic}[1]

    \State nodo $nodoActual \gets$ $c$.raiz \Comment $O(1)$
    \While{$nodoActual$ $\rightarrow$ der $\neq$ NULL}
        $nodoActual$ $\gets$ $nodoActual$ $\rightarrow$ der \Comment $O(1)$
    \EndWhile

    \State $res \gets$ ($nodoActual$ = $c$.ultimo)

    \medskip
    \Statex \underline{Complejidad:} $O(1)$
\end{algorithmic}
\end{algorithm}

% hayUnicoNodoEnUltimoNivel
% explicacion: si el de mas abajo a la izquierda es el ultimo, entonces el ultimo nivel tiene un unico nodo
\textbf{Funcion privada}\\
\textbf{Pre} $\equiv$ \{$\neg$ vac\'ia?($c$)\}\\%
\textbf{Post} $\equiv$ \{Res es true sii el ultimo es el de mas abajo a la izquierda\}%
\begin{algorithm}[H]
{\textbf{iHayUnicoNodoEnUltimoNivel}(\In{c}{colaPrioridad($\alpha$)}) $\to$ $res$ : bool}
\begin{algorithmic}[1]

    \State nodo $nodoActual \gets$ $c$.raiz \Comment $O(1)$
    \While{$nodoActual$ $\rightarrow$ izq $\neq$ NULL}
        $nodoActual$ $\gets$ $nodoActual$ $\rightarrow$ izq \Comment $O(1)$
    \EndWhile

    \State $res \gets$ ($nodoActual$ = $c$.ultimo)

    \medskip
    \Statex \underline{Complejidad:} $O(1)$
\end{algorithmic}
\end{algorithm}



$ $\newline

% swapValores
% explicacion: swap de los valores
\textbf{Funcion privada}\\
\textbf{Pre} $\equiv$ \{$na$ $\igobs$ $na_0$ $\land$ $nb$ $\igobs$ $nb_0$ $\land$ $na$ $\neq$ NULL $\land$ $nb$ $\neq$ NULL\}\\%
\textbf{Post} $\equiv$ \{($na \to$ elem $\igobs$ $nb_0 \to$ elem) $\land$ ($nb \to$ elem $\igobs$ $na_0 \to$ elem)\}%
\begin{algorithm}[H]
{\textbf{iSwapValores}(\Inout{na}{nodo}, \Inout{nb}{nodo}) $\to$ $res$ : bool}
\begin{algorithmic}[1]

    \State $tmp \gets$ (na $\to$ elem) \Comment $O(1)$
    \State ($na \to$ elem) $\gets$ ($nb \to$ elem) \Comment $O(1)$
    \State ($nb \to$ elem) $\gets$ tmp \Comment $O(1)$

    \medskip
    \Statex \underline{Complejidad:} $O(1)$
\end{algorithmic}
\end{algorithm}


% swapNodos
% explicacion: swap de los nodos
\textbf{Funcion privada}\\
\textbf{Pre} $\equiv$ \{$a$ $\igobs$ $a_0$ $\land$ $b$ $\igobs$ $b_0$ $\land$ $a$ $\neq$ NULL $\land$ $b$ $\neq$ NULL \}\\%
\textbf{Post} $\equiv$ \{Los nodos a y b son swappeados reordenando los punteros\}%
\begin{algorithm}[H]
{\textbf{iSwapNodos}(\Inout{a}{nodo}, \Inout{b}{nodo})}
\begin{algorithmic}[1]

    \If{($a \to$ padre) = $b$}
        \State SwapConHijo($a$, $b$)
    \Else
        \If{($b \to$ padre) = $a$}
            \State SwapConHijo($b$, $a$)
        \Else
            \State SwapDisjunto($a$, $b$)
        \EndIf 
    \EndIf 

    \medskip
    \Statex \underline{Complejidad:} $O(1)$

\end{algorithmic}
\end{algorithm}




$ $\newline

% swapConHijo
% explicacion: swap de los nodos
\textbf{Funcion privada}\\
\textbf{Pre} $\equiv$ \{a es padre de b\}\\%
\textbf{Post} $\equiv$ \{Los nodos a y b son swappeados reordenando los punteros\}%
\begin{algorithm}[H]
{\textbf{iSwapConHijo}(\Inout{a}{nodo}, \Inout{b}{nodo})}
\begin{algorithmic}[1]

    \If{($a \to$ izq) = $b$}
        \State SwapConHijoIzquierdo($a$, $b$)
    \Else \If{($a \to$ der) = $b$}
            \State SwapConHijoDerecho($a$, $b$)
        \EndIf 
    \EndIf 

    \medskip
    \Statex \underline{Complejidad:} $O(1)$

\end{algorithmic}
\end{algorithm}

$ $\newline



$ $\newline

% swapConHijoIzquierdo
% explicacion: swap de los nodos
\textbf{Funcion privada}\\
\textbf{Pre} $\equiv$ \{b es hijo izquierdo de a\}\\%
\textbf{Post} $\equiv$ \{Los nodos a y b son swappeados reordenando los punteros\}%
\begin{algorithm}[H]
{\textbf{iSwapConHijoIzquierdo}(\Inout{a}{nodo}, \Inout{b}{nodo})}
\begin{algorithmic}[1]

    \State puntero(nodo) $tmpderA \gets$ ($a \to$ der) \Comment $O(1)$
    \State ($a \to$ der) $\gets$ ($b \to$ der)  \Comment $O(1)$
    \If{$a \to$ der $\neq$ NULL}
        \State ($a \to$ der $\to$ padre) $\gets$ $b$ \Comment $O(1)$
    \EndIf

    \State ($b \to$ der) $\gets$ tmpderA  \Comment $O(1)$
    \If{$b \to$ der $\neq$ NULL}
        \State ($b \to$ der $\to$ padre) $\gets$ a  \Comment $O(1)$
    \EndIf
    
    \State " "

    \If{EsHijoIzquierdo($a$)}
        \State ($a \to$ padre $\to$ izq) $\gets$ $b$ \Comment $O(1)$
    \Else \If{EsHijoDerecho($a$)}
        \State ($a \to$ padre $\to$ der) $\gets$ $b$ \Comment $O(1)$
    \EndIf
    \EndIf
    
    \State " "

    \State ($b \to$ padre) $\gets$ ($a \to$ padre) \Comment $O(1)$
    \If{$b \to$ izq $\neq$ NULL}
        \State ($b \to$ izq $\to$ padre) $\gets$ $a$ \Comment $O(1)$
    \EndIf
    
    \State ($a \to$ izq) $\gets$ ($b \to$ izq) \Comment $O(1)$
    
    \State ($b \to$ izq) $\gets$ $a$ \Comment $O(1)$
    \State ($a \to$ padre) $\gets$ $b$ \Comment $O(1)$





    \medskip
    \Statex \underline{Complejidad:} $O(1)$

\end{algorithmic}
\end{algorithm}

$ $\newline


$ $\newline

% swapConHijoDerecho
% explicacion: swap de los nodos
\textbf{Funcion privada}\\
\textbf{Pre} $\equiv$ \{b es hijo derecho de a\}\\%
\textbf{Post} $\equiv$ \{Los nodos a y b son swappeados reordenando los punteros\}%
\begin{algorithm}[H]
{\textbf{iSwapConHijoDerecho}(\Inout{a}{nodo}, \Inout{b}{nodo})}
\begin{algorithmic}[1]

    \State puntero(nodo) $tmpizqA \gets$ ($a \to$ izq) \Comment $O(1)$
    \State ($a \to$ izq) $\gets$ ($b \to$ izq)  \Comment $O(1)$
    \If{$a \to$ izq $\neq$ NULL}
        \State ($a \to$ izq $\to$ padre) $\gets$ $b$ \Comment $O(1)$
    \EndIf

    \State ($b \to$ izq) $\gets$ tmpizqA  \Comment $O(1)$
    \If{$b \to$ izq $\neq$ NULL}
        \State ($b \to$ izq $\to$ padre) $\gets$ a  \Comment $O(1)$
    \EndIf
    
    \State " "

    \If{EsHijoIzquierdo($a$)}
        \State ($a \to$ padre $\to$ izq) $\gets$ $b$ \Comment $O(1)$
    \Else \If{EsHijoDerecho($a$)}
        \State ($a \to$ padre $\to$ der) $\gets$ $b$ \Comment $O(1)$
    \EndIf
    \EndIf
    
    \State " "

    \State ($b \to$ padre) $\gets$ ($a \to$ padre) \Comment $O(1)$
    \If{$b \to$ der $\neq$ NULL}
        \State ($b \to$ der $\to$ padre) $\gets$ $a$ \Comment $O(1)$
    \EndIf
    
    \State ($a \to$ der) $\gets$ ($b \to$ der) \Comment $O(1)$
    
    \State ($b \to$ der) $\gets$ $a$ \Comment $O(1)$
    \State ($a \to$ padre) $\gets$ $b$ \Comment $O(1)$

    \medskip
    \Statex \underline{Complejidad:} $O(1)$

\end{algorithmic}
\end{algorithm}

$ $\newline


$ $\newline

% swapDisjunto
% explicacion: swap de los nodos
\begin{algorithm}[H]
\textbf{SwapDisjunto(a, b)\hspace*{1cm}Funcion privada}\\
\textbf{Pre} $\equiv$ \{a distinto de b. a no es hijo de b. b no es hijo de a.\}\\
\textbf{Post} $\equiv$ \{Los nodos a y b son swappeados reordenando los punteros\}\\
{\textbf{iSwapDisjunto}(\Inout{a}{nodo}, \Inout{b}{nodo})}
\begin{algorithmic}[1]

    \If{EsHijoIzquierdo($b$)}
        \State ($b \to$ padre $\to$ izq) $\gets$ a \Comment $O(1)$
    \Else \If{EsHijoDerecho($b$)}
        \State ($b \to$ padre $\to$ der) $\gets$ a \Comment $O(1)$
    \EndIf
    \EndIf

    \If{$b$ $\to$ der $\neq$ NULL}
        \State ($b \to$ der $\to$ padre) $\gets$ a \Comment $O(1)$
    \EndIf

    \If{$b$ $\to$ izq $\neq$ NULL}
        \State ($b \to$ izq $\to$ padre) $\gets$ a \Comment $O(1)$
    \EndIf

    \State " "

    \If{EsHijoIzquierdo($a$)}
        \State ($a \to$ padre $\to$ izq) $\gets$ b \Comment $O(1)$
    \Else \If{EsHijoDerecho($b$)}
        \State ($a \to$ padre $\to$ der) $\gets$ b \Comment $O(1)$
    \EndIf
    \EndIf

    \If{$a$ $\to$ der $\neq$ NULL}
        \State ($a \to$ der $\to$ padre) $\gets$ b \Comment $O(1)$
    \EndIf

    \If{$a$ $\to$ izq $\neq$ NULL}
        \State ($a \to$ izq $\to$ padre) $\gets$ b \Comment $O(1)$
    \EndIf

    \State " "

    \State puntero(nodo) tmpPadreB $\gets$ ($b \to$ padre) \Comment $O(1)$
    \State puntero(nodo) tmpIzqB $\gets$ ($b \to$ izq) \Comment $O(1)$
    \State puntero(nodo) tmpDerB $\gets$ ($b \to$ der) \Comment $O(1)$

    \State " "

    \State ($b \to$ padre) $\gets$ ($a \to$ padre) \Comment $O(1)$
    \State ($b \to$ izq) $\gets$ ($a \to$ izq) \Comment $O(1)$
    \State ($b \to$ der) $\gets$ ($a \to$ der) \Comment $O(1)$

    \State ($a \to$ padre) $\gets$ tmpPadreB \Comment $O(1)$
    \State ($a \to$ izq) $\gets$ tmpIzqB \Comment $O(1)$
    \State ($a \to$ der) $\gets$ tmpDerB \Comment $O(1)$


    \medskip
    \Statex \underline{Complejidad:} $O(1)$
    \Statex \underline{Justificaci\'on:} Todas las operaciones son O(1)

\end{algorithmic}
\end{algorithm}

$ $\newline

%eliminarUltimo
%explicacion: elimina el ultimo nodo y actualiza c.ultimo
\textbf{Funcion privada}\\
\textbf{Pre} $\equiv$ \{ $\#$c > 0 \}\\%
\textbf{Post} $\equiv$ \{El nodo c.ultimo se elimina, y es actualizado\}%
\begin{algorithm}[H]
{\textbf{iEliminarUltimo}(\Inout{c}{ColaPrioridad})}
\begin{algorithmic}[1]

    \If{$c$.ultimo = $c$.raiz}
        \State $c$.ultimo $\gets$ NULL \Comment Libero memoria $O(1)$
        \State $c$.raiz $\gets$ NULL \Comment $O(1)$
    \Else

    \If{EsHijoDerecho($c$.ultimo)}
        \State puntero(nodo) $antiguoUltimo \gets$ $c$.ultimo \Comment $O(1)$
        \State $c$.ultimo $\gets$ ($c$.ultimo $\to$ padre $\to$ izq) \Comment $O(1)$
        \State ($c$.ultimo $\to$ padre $\to$ der) $\gets$ NULL \Comment $O(1)$
        \State $antiguoUltimo \gets$ NULL \Comment $O(1)$
    \Else
        \If{HayUnicoNodoEnUltimoNivel($c$)}
            \State ($c$.ultimo $\to$ padre $\to$ izq) $\gets$ NULL \Comment $O(1)$
            \State $c$.ultimo $\gets$ NULL \Comment Libero memoria $O(1)$
            \State puntero(nodo) $nodoActual \gets$ $c$.raiz \Comment $O(1)$
            \While{($nodoActual \to$ der) $\neq$ NULL}
                $nodoActual \gets$ ($nodoActual \to$ der)
            \EndWhile
            \State $c$.ultimo $\gets$ $nodoActual$
        \Else
            % es hijo izquierdo pero no es el unico
            \State puntero(nodo) $nuevoUltimo \gets$ $c$.ultimo \Comment $O(1)$
            \While{$\neg$EsHijoDerecho($nuevoUltimo$)}  \Comment En peor caso recorro toda la altura $O(log(\#c))$
                \State $nuevoUltimo \gets$ ($nuevoUltimo \to$ padre) \Comment $O(1)$  
            \EndWhile
            \State $nuevoUltimo \gets$ ($nuevoUltimo \to$ padre $\to$ izq)  \Comment $O(1)$

            \While{$nuevoUltimo$ $\neq$ NULL)}  \Comment En peor caso recorro toda la altura  $O(log(\#c))$
                \State $nuevoUltimo \gets$ ($nuevoUltimo \to$ der) \Comment $O(1)$  
            \EndWhile

            \State $c$.ultimo $\gets$ NULL \Comment Libero memoria $O(1)$
            \State $c$.ultimo $\gets$ $nuevoUltimo$ \Comment $O(1)$

        \EndIf


    \EndIf

    \EndIf

    \medskip
    \Statex \underline{Complejidad:} $O(1)$
    \Statex \underline{Justificacion:} Para la complejidad del peor caso, tomo la rama que mas complejidad tiene. Todas las ramas son O(1) (por ser suma de O(1)) expecto la que contiene los While (cuando es hijo izquierdo pero no el unico del nivel) En esta rama, loa complejidad en peor caso es: $O(1)$ + $O(log(\#c))$ + $O(1)$ + $O(log(\#c))$ + $O(1)$ = 2*$O(log(\#c))$ = $O(log(\#c))$

\end{algorithmic}
\end{algorithm}

$ $\newline

%siftUp
%explicacion: dado un nodo, lleva el elemento hacia arriba hast que este en la pos correcta
\textbf{Funcion privada}\\
\textbf{Pre} $\equiv$ \{$n$ $\neq$ NULL $\land$ el nodo esta en la estructura de C\}\\%
\textbf{Post} $\equiv$ \{El elemento de n se fue swappeando con su padre mientras era menor\}%
\begin{algorithm}[H]
{\textbf{iSiftUp}(\Inout{n}{nodo})}
\begin{algorithmic}[1]

    \While{($n \to$ padre $\neq$ NULL) $\land$ (($n \to$ elem) < ($n \to$ padre $\to$ elem))} \Comment $O(log(\#c))$
        \State SwapNodo($n$, $n \to$ padre) \Comment $O(1)$
        \State $n$ $\gets$ ($n \to$ padre) \Comment $O(1)$
    \EndWhile

    \medskip
    \Statex \underline{Complejidad:} $O(1)$
    \Statex \underline{Justificacion:} En el peor caso se recorre toda la altura del arbol: O(log($\#$C))
\end{algorithmic}
\end{algorithm}




\end{Algoritmos}
