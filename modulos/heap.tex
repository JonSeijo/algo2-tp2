\begin{Interfaz}

  \textbf{se explica con}: \tadNombre{Cola de Prioridad(jugStruct)}.

  \textbf{g\'eneros}: \TipoVariable{heap(tupla<id: nat, cantCapt: nat>)}, \TipoVariable{itheap(jugStruct)}.

  \Title{Operaciones b\'asicas de Heap}


  \InterfazFuncion{Vacia}{}{heap(tupla<id: nat, cantCapt: nat>)}%
  {$res \igobs vacia$}%
  [$O(1)$]
  [genera un nuevo heap]


  \InterfazFuncion{Encolar}{\Inout{h}{heap(tupla<id: nat, cantCapt: nat>)}, \In{j}{tupla<id: nat, cantCapt: nat>}}{itHeap(tupla<id: nat, cantCapt: nat>)}
  [$h \igobs h_{0}$]
  {$h \igobs encolar(h_{0}, j)$}
  [$O(log(EC))$]
  [encola $j$ a $h$]
  [el elemento $j$ se encola por copia, REVISAR PRE Y POS]

  \InterfazFuncion{EsVacia?}{\In{h}{heap(tupla<id: nat, cantCapt: nat>)}}{bool}
  {$res \igobs vacia?(h)$}
  [$O(1)$]
  [devuelve true si la cola es vacia]


  \InterfazFuncion{Proximo}{\In{h}{heap(tupla<id: nat, cantCapt: nat>)}}{tupla<id: nat, cantCapt: nat>}
  [$\neg$ vacia?(h)]  
  {$alias(res \igobs proximo(h))$} 
  [$O(1)$]
  [devuelve el pr\'oximo de la cola]
  [PREGUNTAR ALIASING Y ALIAS]
  
  
  \InterfazFuncion{Desencolar}{\Inout{h}{heap(tupla<id: nat, cantCapt: nat>)}}{}
  [$h \igobs h_{0} \land \neg vacia(h)$ ]  
  {$h \igobs desencolar(h_{0})$} 
  [$O(log(EC))$]
  [desencola el pr\'oximo de h]


  \Title{Operaciones del iterador}
  
   \InterfazFuncion{CrearIt}{\In {h}{heap(tupla<id: nat, cantCapt: nat>)}}{itHeap(tupla<id: nat, cantCapt: nat>)}%
  {$HCER ESTO$}%
  [$O(1)$]
  [crea un iterador unidireccional modificable a la \'ultima posici\'on]
  [el iterador se invalida si se elimina el siguiente sin usar la funcion BORRARSIGUIENTE]
 
 
 \InterfazFuncion{HayPadre?}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{bool}%
  {$HCER ESTO$}
  [$O(1)$]
  [devuelve true si hay padre del elemento]
  
  \InterfazFuncion{HayHijoIzq?}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{bool}%
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve true si hay hijo izquierdo del elemento]
  
  \InterfazFuncion{HayHijoDer?}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{bool}%
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve true si hay hijo derecho del elemento]
  
  \InterfazFuncion{HayNodo?}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>t)}}{bool}%
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve true si hay elementos por recorrer]
  
  \InterfazFuncion{Elemento}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{tupla$<$id: nat, cantCapt: nat$>$}%
  [HayNodo?(it)]
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve el elemento del nodo]
  
  \InterfazFuncion{Elementohijoizq}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{tupla<id: nat, cantCapt: nat>}%
  [HayHijoIzq?(it)]
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve el elemento del hijo izquierdo del nodo]
  
  \InterfazFuncion{Elementohijoder}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{tupla<id: nat, cantCapt: nat>}%
  [HayHijoDer?(it)]
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve el elemento del hijo derecho del nodo]
  
  \InterfazFuncion{Elementopadre}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{tupla<id: nat, cantCapt: nat>}%
  [HayPadre?(it)]
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve el elemento del padre del nodo]
  
  \InterfazFuncion{Borrar}{\Inout {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{}%
  [ITERADOR VALIDO]
  {$HACER ESTO$}
  [$O(log(EC))$]
  [Borra el elemento dado]
  
\end{Interfaz}

\begin{Representacion}
 
  \begin{Estructura}{heap(tupla<id: nat, cantCapt: nat>)}[estr]
      \begin{Tupla}[estr]%
      \tupItem{raiz}{puntero(Nodoheap)}%
      \tupItem{ultimo}{puntero(Nodoheap)}%
    \end{Tupla}
  \end{Estructura}

	\begin{Tupla}[Nodoheap]
	\tupItem{elemento}{tupla<id: nat, cantCapt: nat>}%
	\tupItem{padre}{puntero(Nodoheap)}%
	\tupItem{izq}{puntero(Nodoheap)}%
	\tupItem{der}{puntero(Nodoheap)}%
	\end{Tupla}

  \RepFc[estr$/e$]{true}

  ~

  \AbsFc[estr]{coor}[e]{}

\end{Representacion}

\begin{Representacion}
 
  \begin{Estructura}{itHeap(tupla<id: nat, cantCapt: nat>)}[estr]
      \begin{Tupla}[estr]%
      \tupItem{siguiente}{puntero(Nodoheap)}%
      \tupItem{estructura}{puntero(Heap)}%
    \end{Tupla}
  \end{Estructura}

  \RepFc[estr$/e$]{true}

  ~

  \AbsFc[estr]{heap}[e]{}

\end{Representacion}



\begin{Algoritmos}
   
\begin{algorithm}[H]{\textbf{iVacio}() $\to$ $res$ : heap(jugStruct)}
    	\begin{algorithmic}[1]
			 \State $res \gets  <NULL, NULL> $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}
   
\begin{algorithm}[H]{\textbf{iEsVacia?}(\In{h}{heap(tupla<id: nat, cantCapt: nat>)}) $\to$ $res$ : bool}
    	\begin{algorithmic}[1]
			 \State $res \gets  h.raiz \not=$ NULL \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iEncolarElem}(\Inout{h}{heap(tupla$<$id: nat, cantCapt: nat$>$)}, \In{j}{tupla$<$id: nat, cantCapt: nat$>$}) $\to$ $res$ : itHeap(tupla$<$id: nat, cantCapt: nat$>$)}
    	\begin{algorithmic}[1]
    	\State $Nodoheap$ n $\gets <j, NULL, NULL, NULL>$ \Comment $O(1)$
    	\State $puntero(Nodoheap)$ p $\gets n$  \Comment $O(1)$
		\State $InsertarAlFinal(h, p)$
		\State $it \gets CrearIt(h)$ \Comment $O(1)$

		\If{$h.raiz \not= h.ultimo$} \Comment $O(1)$
			\State $puntero(Nodo)$ nuevoNodo $\gets h.ultimo$			\Comment $O(1)$
			\While{$((nuevoNodo \rightarrow elemento.cantCapt)$ <\hspace{0.4mm} $(nuevoNodo \rightarrow padre \rightarrow elemento.cantCapt)) \lor (((nuevoNodo \rightarrow elemento.cantCapt)$ = $(nuevoNodo \rightarrow padre \rightarrow elemento.cantCapt)) \land ((nuevoNodo \rightarrow elemento.id)$ <\hspace{0.4mm} $(nuevoNodo \rightarrow padre \rightarrow elemento.id)))$} \Comment $O(log(EC))$
				\State $Swap(h, nuevoNodo)$ \Comment $O(1)$
						
			\EndWhile
		\EndIf
		\State $res \gets it$ \Comment $O(1)$
			\medskip
			\Statex \underline{Complejidad:} $O(log(EC))$
			\Statex \underline{Justificaci\'on:} Todas las operaciones son $O(1)$ y en el ciclo se va recorriendo el heap desde una de las hojas hasta la raiz (o vice versa). Al ser el heap un \'arbol completo (ya que siempre se agregan elementos al \'ultimo lugar disponible), si la cantidad de elementos es EC en el peor cas, entonces su altura es log(EC). Por lo tanto el ciclo se repiten log(EC) veces en el peor caso.
    	\end{algorithmic}   	
\end{algorithm}

\begin{algorithm}[H]{\textbf{iProximo}(\In{h}{heap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
    		 \State $res \gets (h.raiz \rightarrow elemento)$ \Comment $O(1)$
    		 \medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iDesencolar}(\In{h}{heap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
    		 \State $it \gets <h.raiz, h>$ \Comment $O(1)$
		     \State $res \gets Proximo(h)$ \Comment $O(1)$	 
    		 \State $Borrar(it)$ \Comment $O(log(EC))$
    		 \medskip
			\Statex \underline{Complejidad:} $O(log(EC))$
			\Statex \underline{Justificaci\'on:} Hay dos operaciones $O(1)$ y una $O(log(EC))$, por lo tanto, por \'algebra de \'ordenes $O(1)$ + $O(1)$ + $O(log(EC))$ = $O(log(EC))$
    	\end{algorithmic}
\end{algorithm}

\end{Algoritmos}

\begin{Algoritmos}


\begin{algorithm}[H]{\textbf{iCrearIt}(\In{h}{heap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : itHeap(tupla$<$id: nat, cantCapt: nat$>$)}
    	\begin{algorithmic}[1]
			 \State $res \gets  <h.ultimo, h> $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
			\Statex \underline{Justificaci\'on:} Todas las operaciones son $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{HayPadre?}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : bool}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente \rightarrow padre \not= NULL) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{HayHijoDer?}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : bool}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente \rightarrow der \not= NULL) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{HayHijoIzq?}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : bool}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente \rightarrow izq \not= NULL) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iHayNodo?}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : bool}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente \not= NULL) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
			\Statex \underline{Justificaci\'on:} Todas las operaciones son $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iElemento}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente \rightarrow elemento) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
			\Statex \underline{Justificaci\'on:} Todas las operaciones son $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{Elementohijoizq}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente  \rightarrow izq \rightarrow elemento) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{Elementohijoder}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente  \rightarrow der \rightarrow elemento) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{Elementopadre}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente  \rightarrow padre \rightarrow elemento) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}   	
\end{algorithm}

\begin{algorithm}[H]{\textbf{iBorrar}(\Inout{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}}
    	\begin{algorithmic}[1]
    		\If{$(it.estructura \rightarrow raiz) = (it.estructura \rightarrow ultimo)$} \Comment $O(1)$
    			\State $it.siguiente \gets NULL$ \Comment Libera memoria $O(1)$
    			\State $(it.estructura \rightarrow raiz) \gets NULL$ \Comment $O(1)$
    			\State $(it.estructura \rightarrow ultimo) \gets NULL$ \Comment $O(1)$
    		\Else    		
    			\State $puntero(Nodo)$ cambiado $\gets (it.estructura \rightarrow ultimo)$ \Comment $O(1)$
				\State $SwapConElUltimo(*(it.estructura), it.siguiente)$ \Comment $O(1)$
				\If{$EsHijoIzquierdo?(it.estructura \rightarrow ultimo)$} \Comment $O(1)$
					\State $puntero(Nodoheap)$ $buscador \gets (it.estructura \rightarrow ultimo)$ \Comment $O(1)$
					\State $nat$ i $\gets 7$ \Comment $O(1)$
					\While{$(buscador \rightarrow padre) \not= NULL$ $\land i = 7$} \Comment $O(log(EC))$
						\If{$\neg EsHijoIzquierdo?(buscador)$} \Comment $O(1)$
							\State $i \gets 0$ \Comment $O(1)$
						\Else$ $ $buscador \gets (buscador \rightarrow padre)$ \Comment $O(1)$
						\EndIf
					\EndWhile
					\If{$(buscador \rightarrow padre) = NULL$} \Comment $O(1)$
						\While{$(buscador \rightarrow der) \not= NULL$} \Comment $O(log(EC))$
							\State $buscador \gets (buscador \rightarrow der)$ \Comment $O(1)$
						\EndWhile
						\State $(it.estructura \rightarrow ultimo) \gets NULL$ \Comment Libera memoria $O(1)$						
						\State $(it.estructura \rightarrow ultimo) \gets buscador$ \Comment $O(1)$
					\Else $buscador \gets (buscador \rightarrow padre \rightarrow izq)$ \Comment $O(1)$
						\While{$(buscador \rightarrow der) \not= NULL$} \Comment $O(log(EC))$
							\State $buscador \gets (buscador \rightarrow der)$ \Comment $O(1)$
						\EndWhile
						\State $(it.estructura \rightarrow ultimo) \gets NULL$ \Comment Libera memoria $O(1)$						
						\State $(it.estructura \rightarrow ultimo) \gets buscador$ \Comment $O(1)$
					\EndIf
				\Else
					\State $(it.estructura \rightarrow ultimo) \gets (it.estructura \rightarrow ultimo \rightarrow padre \rightarrow izq)$ \Comment $O(1)$
					\State $(it.estructura \rightarrow ultimo \rightarrow padre \rightarrow der) \gets NULL$ \Comment Libera memoria del nodo borrado $O(1)$
				\EndIf				
				\While {$(cambiado \rightarrow der) \not= NULL$} \Comment $O(log(EC))$
					\State $puntero(Nodoheap) minimo \gets Min(cambiado \rightarrow izq, cambiado \rightarrow der)$ \Comment $O(1)$
					\If{$((minimo \rightarrow elemento.cantCapt)$ <\hspace{0.4mm} $(cambiado \rightarrow elemento.cantCapt)) \lor (((minimo \rightarrow elemento.cantCapt)$ = $(cambiado \rightarrow elemento.cantCapt)) \land ((minimo \rightarrow elemento.id)$ <\hspace{0.4mm} $(cambiado elemento.id)))$} \Comment $O(1)$
					\State $Swap(*(it.estructura), minimo)$ \Comment $O(1)$
					\EndIf					
				\EndWhile
				\If{$(cambiado \rightarrow izq) \not= NULL$} \Comment $O(1)$
					\If{$((cambiado \rightarrow izq \rightarrow elemento.cantCapt)$ <\hspace{0.4mm} $(cambiado \rightarrow elemento.cantCapt)) \lor (((cambiado \rightarrow izq \rightarrow elemento.cantCapt)$ = $(cambiado \rightarrow elemento.cantCapt)) \implies ((cambiado \rightarrow izq \rightarrow elemento.id)$ <\hspace{0.4mm} $(cambiado elemento.id)))$} \Comment $O(1)$
						\State $Swap(*(it.estructura), cambiado \rightarrow izq)$ \Comment $O(1)$
					\EndIf
				\EndIf
			\EndIf
			\medskip
			\Statex \underline{Complejidad:} $O(log(EC))$
			\Statex \underline{Justificaci\'on:} Todas las operaciones son $O(1)$ y en cada uno de los ciclos se va recorriendo el heap desde una de las hojas hasta la raiz (o vice versa). Al ser el heap un \'arbol completo (ya que siempre se agregan elementos al \'ultimo lugar disponible), si la cantidad de elementos es EC en el peor cas, entonces su altura es log(EC). Por lo tanto estos ciclos se repiten log(EC) veces en el peor caso.
    	\end{algorithmic}
\end{algorithm}



\begin{algorithm}[H]{\textbf{iInsertarAlFinal}(\Inout{h}{heap(tupla$<$id: nat, cantCapt: nat$>$)}, \In{p}{puntero(Nodoheap)})} $ $\newline
\Comment Esta funci\'on es privada y lo que hace es modificar los punteros del heap para que el nodo apuntado por el puntero pasado por par\'ametro quede en la posici\'on del \'ultimo.
    	\begin{algorithmic}[1]
			\If{$EsVacia?(h)$} \Comment $O(1)$
    		\State $h.raiz \gets p$ \Comment $O(1)$
    		\State $h.ultimo \gets p$ \Comment $O(1)$
    	\Else
    		\If{$h.raiz = h.ultimo$} \Comment $O(1)$
    			\State $n.padre \gets h.raiz$ \Comment $O(1)$
    			\State $(h.raiz \rightarrow izq) \gets p$ \Comment $O(1)$
    			\State $h.ultimo \gets p$    \Comment $O(1)$
    		\Else
    			\If{$(h.raiz \rightarrow izq) = h.ultimo$} \Comment $O(1)$
    				\State $n.padre \gets h.raiz$ \Comment $O(1)$
    				\State $(h.raiz \rightarrow der) \gets p$ \Comment $O(1)$
    				\State $h.ultimo \gets p$ \Comment $O(1)$
    			\Else
    				\If{$EsHijoIzquierdo?(h.ultimo)$} \Comment $O(1)$
    					\State $n.padre \gets (h.ultimo \rightarrow padre)$ \Comment $O(1)$
    					\State $(h.ultimo \rightarrow padre \rightarrow der) \gets p$ \Comment $O(1)$
    					\State $h.ultimo \gets p$ \Comment $O(1)$
    				\Else
						\State $puntero(Nodoheap)$ i $\gets h.ultimo$    				 \Comment $O(1)$	
    					\While {$i \not= NULL \land \neg EsHijoIzquierdo?(j)$} \Comment $O(log(EC))$
    						\State $i \gets (i \rightarrow padre)$ \Comment $O(1)$
    					
    					\EndWhile
    					\If{$i = NULL$} \Comment $O(1)$
    						\State $puntero(Nodoheap)$ ultimoizq $\gets h.raiz$ \Comment $O(1)$
    						\While {$(ultimoizq \rightarrow izq) \not= NULL$} \Comment $O(log(EC))$
    							\State $ultimoizq \gets (ultimoizq \rightarrow izq)$ \Comment $O(1)$
    						\EndWhile
    						\State $n.padre \gets ultimoizqu$ \Comment $O(1)$
    						\State $(ultimoizq \rightarrow izq) \gets p$ \Comment $O(1)$
    						\State $h.ultimo \gets p$ \Comment $O(1)$
    					\Else
    						\State $i \gets (i \rightarrow padre \rightarrow der)$ \Comment $O(1)$
    						\While{$(i \rightarrow izq) \not= NULL$} \Comment $O(log(EC))$
    							\State $i \gets (i \rightarrow izq)$ \Comment $O(1)$
    						\EndWhile
    						\State $n.padre \gets i$ \Comment $O(1)$
    						\State $(j \rightarrow izq) \gets p$ \Comment $O(1)$
    						\State $h.ultimo \gets p$ \Comment $O(1)$
    					\EndIf
    				\EndIf		
    			\EndIf	    	
	    	\EndIf
		\EndIf

			\medskip
			\Statex \underline{Complejidad:} $O(log(EC))$
			\Statex \underline{Justificaci\'on:} Todas las operaciones son $O(1)$ y en cada uno de los ciclos se va recorriendo el heap desde una de las hojas hasta la raiz (o vice versa). Al ser el heap un \'arbol completo (ya que siempre se agregan elementos al \'ultimo lugar disponible), si la cantidad de elementos es EC en el peor cas, entonces su altura es log(EC). Por lo tanto estos ciclos se repiten log(EC) veces en el peor caso.
    	\end{algorithmic}   	
\end{algorithm} $ $\newline
$ $\newline
$ $\newline
$ $\newline

{\textbf{iSwap}(\Inout{h}{heap(tupla$<$id: nat, cantCapt: nat$>$), \In{nuevoNodo}{puntero(Nodoheap)}})} $ $\newline
$ $\Comment Esta funci\'on es privada y swapea dos nodos cambiando los punteros.
    	\begin{algorithmic}[1]
    		\State $puntero(Nodoheap)$ aSwapear $\gets (nuevoNodo \rightarrow padre)$
    		\If{$h.ultimo = nuevoNodo$}
    			\State $h.ultimo \gets aSwapear$
    		\EndIf
			\If{$EsHijoIzquierdo?(nuevoNodo)$} \Comment $O(1)$
						\If{$(nuevoNodo \rightarrow izq) = NULL$} \Comment $O(1)$
								\State $(aSwapear \rightarrow izq) \gets NULL$ \Comment $O(1)$
							\Else
								\State $(aSwapear \rightarrow izq) \gets (nuevoNodo \rightarrow izq)$ \Comment $O(1)$
								\State $(nuevoNodo \rightarrow izq \rightarrow padre) \gets aSwapear$ \Comment $O(1)$
							\EndIf
							\If{$(nuevoNodo \rightarrow der) = NULL$} \Comment $O(1)$
								\State $(nuevoNodo \rightarrow der) \gets (aSwapear \rightarrow der)$ \Comment $O(1)$
								\If{$(aSwapear \rightarrow der) \not= NULL$} \Comment $O(1)$
								\State $(aSwapear \rightarrow der \rightarrow padre) \gets nuevoNodo$	 \Comment $O(1)$						
								\EndIf
								\State $(aSwapear \rightarrow der) \gets NULL$ \Comment $O(1)$
							\Else
								\If{$(aSwapear \rightarrow der) = NULL$} \Comment $O(1)$
									\State $(aSwapear \rightarrow der) \gets (nodoNuevo \rightarrow der)$ \Comment $O(1)$
									\State $(nodoNuevo \rightarrow der \rightarrow padre) \gets aSwapear$ \Comment $O(1)$
									\State $(nodoNuevo \rightarrow der) \gets NULL$ \Comment $O(1)$
								\Else
									\State $(nodoNuevo \rightarrow der \rightarrow padre) \gets aSwapear$ \Comment $O(1)$
									\State $(aSwapear \rightarrow der \rightarrow padre) \gets nuevoNodo$ \Comment $O(1)$
									\State $puntero(Nodoheap)$ auxiliar $\gets (nuevoNodo \rightarrow der)$ \Comment $O(1)$
									\State $(nuevoNodo \rightarrow der) \gets (aSwapear \rightarrow der)$ \Comment $O(1)$
									\State $(aSwapear \rightarrow der) \gets auxiliar$ \Comment $O(1)$
								\EndIf
							\EndIf
						\State $(nuevoNodo \rightarrow izq) \gets aSwapear$ \Comment $O(1)$
					\Else
						\If{$(nuevoNodo \rightarrow der) = NULL$} \Comment $O(1)$
								\State $(aSwapear \rightarrow der) \gets NULL$ \Comment $O(1)$
							\Else
								\State $(aSwapear \rightarrow der) \gets (nuevoNodo \rightarrow der)$ \Comment $O(1)$
								\State $(nuevoNodo \rightarrow der \rightarrow padre) \gets aSwapear$ \Comment $O(1)$
							\EndIf
							\If{$(nuevoNodo \rightarrow izq) = NULL$} \Comment $O(1)$
								\State $(nuevoNodo \rightarrow izq) \gets (aSwapear \rightarrow izq)$ \Comment $O(1)$
								\If{$(aSwapear \rightarrow izq) \not= NULL$} \Comment $O(1)$
									\State $(aSwapear \rightarrow izq \rightarrow padre) \gets nuevoNodo$	\Comment $O(1)$						
								\EndIf
								\State $(aSwapear \rightarrow izq) \gets NULL$ \Comment $O(1)$
							\Else
								\If{$(aSwapear \rightarrow izq) = NULL$} \Comment $O(1)$
									\State $(aSwapear \rightarrow izq) \gets (nodoNuevo \rightarrow izq)$ \Comment $O(1)$
									\State $(nodoNuevo \rightarrow izq \rightarrow padre) \gets aSwapear$ \Comment $O(1)$
									\State $(nodoNuevo \rightarrow izq) \gets NULL$ \Comment $O(1)$
								\Else
									\State $(nodoNuevo \rightarrow izq \rightarrow padre) \gets aSwapear$ \Comment $O(1)$
									\State $(aSwapear \rightarrow izq \rightarrow padre) \gets nuevoNodo$ \Comment $O(1)$
									\State $puntero(Nodoheap)$ auxiliar $\gets (nuevoNodo \rightarrow izq)$ \Comment $O(1)$
									\State $(nuevoNodo \rightarrow izq) \gets (aSwapear \rightarrow izq)$ \Comment $O(1)$
									\State $(aSwapear \rightarrow izq) \gets auxiliar$ \Comment $O(1)$
								\EndIf
							\EndIf
						\State $(nuevoNodo \rightarrow der) \gets aSwapear$ \Comment $O(1)$
					\EndIf	
					\If{$aSwapear = h.raiz$}					
					\State $(aSwapear \rightarrow padre) \gets nuevoNodo$ \Comment $O(1)$
					\State $h.raiz \gets nuevoNodo$	 \Comment $O(1)$
					\State $(nuevoNodo \rightarrow padre) \gets NULL$			 \Comment $O(1)$
					\Else
					\State $puntero(Nodoheap)$ abuelo $\gets (aSwapear \rightarrow padre)$ \Comment $O(1)$
						\If{$EsHijoIzquierdo?(aSwapear)$} \Comment $O(1)$
							\State $(abuelo \rightarrow izq) \gets nuevoNuevo$ \Comment $O(1)$
							\State $(nuevoNodo \rightarrow padre) \gets abuelo$ \Comment $O(1)$
							\State $(aSwapear \rightarrow padre) \gets nuevoNodo$ \Comment $O(1)$
						\Else
							\State $(abuelo \rightarrow der) \gets nuevoNuevo$ \Comment $O(1)$
							\State $(nuevoNodo \rightarrow padre) \gets abuelo$ \Comment $O(1)$
							\State $(aSwapear \rightarrow padre) \gets nuevoNodo$ \Comment $O(1)$
						\EndIf
					\EndIf
			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}   
    	
 \begin{algorithm}[H]{\textbf{iSwapConElUltimo}(\Inout{h}{heap(tupla$<$id: nat, cantCapt: nat$>$)}, \In{aPonerUltimo}{puntero(Nodo)})} $ $\newline
 \Comment Esta funci\'on es privada y swapea al nodo apuntado con el \'ultimo del heap.
    	\begin{algorithmic}[1] 
	\If{($h.ultimo \rightarrow padre) \not= aPonerUltimo$} \Comment $O(1)$					\State $(h.ultimo \rightarrow izq) \gets (aPonerUltimo \rightarrow izq)$ \Comment $O(1)$
			\State $(h.ultimo \rightarrow der) \gets (aPonerUltimo \rightarrow der)$ \Comment $O(1)$	
			\If{$(aPonerUltimo \rightarrow izq) \not= NULL$} \Comment $O(1)$
				\State $(aPonerUltimo \rightarrow izq \rightarrow padre) \gets h.ultimo$ \Comment $O(1)$
			\EndIf	
			\If{$(aPonerUltimo \rightarrow der) \not= NULL$} \Comment $O(1)$
				\State $(aPonerUltimo \rightarrow der \rightarrow padre) \gets h.ultimo$ \Comment $O(1)$
			\EndIf		
			\If{$aPonerUltimo \not= h.raiz$} \Comment $O(1)$
				\State $padreaPonerUltimo \gets (aPonerUltimo \rightarrow padre)$ \Comment $O(1)$
				\State $padreUltimo \gets (h.ultimo \rightarrow padre)$			 	 \Comment $O(1)$
			 	\If{$EsHijoIzquierdo?(aPonerUltimo) \land EsHijoIzquierdo?(h.ultimo)$} \Comment $O(1)$
			 	\State $(padreaPonerUltimo \rightarrow izq) \gets h.ultimo$ \Comment $O(1)$
			 	\State $(h.ultimo \rightarrow padre) \gets padreaPonerUltimo$ \Comment $O(1)$
			 	\State $(aPonerUltimo \rightarrow padre) \gets padreUltimo$ \Comment $O(1)$
			 	\State $(padreUltimo \rightarrow izq) \gets aPonerUltimo$ \Comment $O(1)$
			 	\Else
			 		\If{$EsHijoIzquierdo?(aPonerUltimo) \land \neg EsHijoIzquierdo?(h.ultimo)$} \Comment $O(1)$
			 		\State $(padreaPonerUltimo \rightarrow izq) \gets h.ultimo$ \Comment $O(1)$
			 		\State $(aPonerUltimo \rightarrow padre) \gets padreUltimo$ \Comment $O(1)$
			 		\State $(h.ultimo \rightarrow padre) \gets padreaPonerUltimo$ \Comment $O(1)$
			 		\State $(padreUltimo \rightarrow der) \gets aPonerUltimo$ \Comment $O(1)$
			 		\Else
			 			\If{$\neg EsHijoIzquierdo?(aPonerUltimo) \land EsHijoIzquierdo?(h.ultimo)$} \Comment $O(1)$
			 			\State $(padreaPonerUltimo \rightarrow izq) \gets h.ultimo$ \Comment $O(1)$
			 			\State $(aPonerUltimo \rightarrow padre) \gets padreUltimo$ \Comment $O(1)$
			 			\State $(h.ultimo \rightarrow padre) \gets padreaPonerUltimo$ \Comment $O(1)$
			 			\State $(padreUltimo \rightarrow izq) \gets aPonerUltimo$ \Comment $O(1)$
			 			\Else
			 				\If{$\neg EsHijoIzquierdo?(aPonerUltimo) \land \neg EsHijoIzquierdo?(h.ultimo)$} \Comment $O(1)$
			 				\State $(padreaPonerUltimo \rightarrow der) \gets h.ultimo$ \Comment $O(1)$
			 				\State $(h.ultimo \rightarrow padre) \gets padreaPonerUltimo$ \Comment $O(1)$
			 				\State $(aPonerUltimo \rightarrow padre) \gets padreUltimo$ \Comment $O(1)$
			 				\State $(padreUltimo \rightarrow der) \gets aPonerUltimo$ \Comment $O(1)$
			 				\EndIf
			 			\EndIf
			 		\EndIf
			 	\EndIf
			\Else
				\State $(h.raiz \rightarrow padre) \gets (h.ultimo \rightarrow padre)$ \Comment $O(1)$
				\If{$EsHijoIzquierdo?(h.ultimo)$} \Comment $O(1)$
					\State $(h.ultimo \rightarrow padre \rightarrow izq) \gets h.raiz$ \Comment $O(1)$
				\Else
					\State $(h.ultimo \rightarrow padre \rightarrow der) \gets h.raiz$ \Comment $O(1)$
				\EndIf			
				\State ($h.ultimo \rightarrow padre) \gets NULL$ \Comment $O(1)$
				\State $h.raiz \gets h.ultimo$ \Comment $O(1)$
			\EndIf
	\Else
		\State $Swap(h, h.ultimo)$	\Comment $O(1)$
	\EndIf	
	\State $h.ultimo \gets aPonerUltimo$	\Comment $O(1)$
			\medskip
			\Statex \underline{Complejidad:} $O(1)$
			\Statex \underline{Justificaci\'on:} Todas las operaciones son $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iEsHijoIzquierdo?}(\In{p}{puntero(Nodoheap)}) $\to$ $res$ : bool} $ $\newline
\Comment Esta funci\'on es privada y devuelve true si el nodo apuntado es hijo izquierdo de su padre. Pre: el padre del nodo tiene que ser $\not=$ NULL
    	\begin{algorithmic}[1] 
			 \State $res \gets  (p = p \rightarrow padre \rightarrow izq) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
			\Statex \underline{Justificaci\'on:} Todas las operaciones son $O(1)$
    	\end{algorithmic}   	
\end{algorithm}

\begin{algorithm}[H]{\textbf{iMin}(\In{izq}{puntero(Nodoheap)}, \In{der}{puntero(Nodoheap)}) $\to$ $res$ : puntero(Nodoheap)}  $ $\newline
\Comment Esta funci\'on es privada y devuelve el nodo con menor cantidad de pokemones capturados, y en caso de empate, devuelve al que tiene menor id.
    	\begin{algorithmic}[1] 
			 \If{$((izq \rightarrow elemento.cantCapt)$ <\hspace{0.4mm} $(der \rightarrow elemento.cantCapt)) \lor (((izq \rightarrow elemento.cantCapt)$ = $(der \rightarrow elemento.cantCapt)) \land ((izq \rightarrow elemento.id)$ <\hspace{0.4mm} $(der \rightarrow elemento.id)))$} \Comment $O(1)$
			 	\State $res \gets izq$ \Comment $O(1)$
			 \Else
			 	\State $res \gets der$ \Comment $O(1)$
			 \EndIf		
			\medskip
			\Statex \underline{Complejidad:} $O(1)$
			\Statex \underline{Justificaci\'on:} Todas las operaciones son $O(1)$ 
    	\end{algorithmic}   	
\end{algorithm}


\end{Algoritmos}