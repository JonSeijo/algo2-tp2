\begin{Interfaz}

  \textbf{se explica con}: \tadNombre{Cola de Prioridad(jugStruct)}.

  \textbf{g\'eneros}: \TipoVariable{heap(tupla<id: nat, cantCapt: nat>)}, \TipoVariable{itheap(jugStruct)}.

  \Title{Operaciones b\'asicas de Heap}


  \InterfazFuncion{Vacia}{}{heap(tupla<id: nat, cantCapt: nat>)}%
  {$res \igobs vacia$}%
  [$O(1)$]
  [genera un nuevo heap]


  \InterfazFuncion{Encolar}{\Inout{h}{heap(tupla<id: nat, cantCapt: nat>)}, \In{j}{tupla<id: nat, cantCapt: nat>}}{itHeap(tupla<id: nat, cantCapt: nat>)}
  [$h \igobs h_{0}$]
  {$h \igobs encolar(h_{0}, j)$}
  [$O(1)$]
  [encola $j$ a $h$]
  [el elemento $j$ se encola por copia, REVISAR PRE Y POS]

  \InterfazFuncion{EsVacia?}{\In{h}{heap(tupla<id: nat, cantCapt: nat>)}}{bool}
  {$res \igobs vacia?(h)$}
  [$O(1)$]
  [devuelve true si la cola es vacia]


  \InterfazFuncion{Proximo}{\In{h}{heap(tupla<id: nat, cantCapt: nat>)}}{tupla<id: nat, cantCapt: nat>}
  [$\neg$ vacia?(h)]  
  {$alias(res \igobs proximo(h))$} 
  [$O(1)$]
  [devuelve el pr\'oximo de la cola]
  [PREGUNTAR ALIASING Y ALIAS]
  
  
  \InterfazFuncion{Desencolar}{\Inout{h}{heap(tupla<id: nat, cantCapt: nat>)}}{}
  [$h \igobs h_{0} \land \neg vacia(h)$ ]  
  {$h \igobs desencolar(h_{0})$} 
  [$O(1)$]
  [desencola el pr\'oximo de h]


  \Title{Operaciones del iterador}
  
   \InterfazFuncion{CrearIt}{\In {h}{heap(tupla<id: nat, cantCapt: nat>)}}{itHeap(tupla<id: nat, cantCapt: nat>)}%
  {$HCER ESTO$}%
  [$O(1)$]
  [crea un iterador unidireccional modificable a la \'ultima posici\'on]
  [el iterador se invalida si se elimina el siguiente sin usar la funcion BORRARSIGUIENTE]
 
 
 \InterfazFuncion{HayPadre?}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{bool}%
  {$HCER ESTO$}
  [$O(1)$]
  [devuelve true si hay padre del elemento]
  
  \InterfazFuncion{HayHijoIzq?}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{bool}%
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve true si hay hijo izquierdo del elemento]
  
  \InterfazFuncion{HayHijoDer?}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{bool}%
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve true si hay hijo derecho del elemento]
  
  \InterfazFuncion{HayNodo?}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>t)}}{bool}%
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve true si hay elementos por recorrer]
  
  \InterfazFuncion{Elemento}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{tupla$<$id: nat, cantCapt: nat$>$}%
  [HayNodo?(it)]
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve el elemento del nodo]
  
  \InterfazFuncion{Elementohijoizq}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{tupla<id: nat, cantCapt: nat>}%
  [HayHijoIzq?(it)]
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve el elemento del hijo izquierdo del nodo]
  
  \InterfazFuncion{Elementohijoder}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{tupla<id: nat, cantCapt: nat>}%
  [HayHijoDer?(it)]
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve el elemento del hijo derecho del nodo]
  
  \InterfazFuncion{Elementopadre}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{tupla<id: nat, cantCapt: nat>}%
  [HayPadre?(it)]
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve el elemento del padre del nodo]
  
  \InterfazFuncion{Borrar}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}, \Inout{h}{heap(tupla<id: nat, cantCapt: nat>)}}{}%
  [ITERADOR VALIDO]
  {$HACER ESTO$}
  [$O(log(EC))$]
  [Borra el elemento dado]
  
   \InterfazFuncion{EncolarElem}{\Inout {h}{heap(tupla<id: nat, cantCapt: nat>)}, \In {j}{tupla<id: nat, cantCapt: nat>}}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}%
  [ITERADOR VALIDO,]
  {$DEVUELVE ITERADOR VALIDO$}
  [$O(log(EC))$]
  [Encola el elemento dado]


\end{Interfaz}

\begin{Representacion}
 
  \begin{Estructura}{heap(tupla<id: nat, cantCapt: nat>)}[estr]
      \begin{Tupla}[estr]%
      \tupItem{raiz}{puntero(Nodoheap)}%
      \tupItem{ultimo}{puntero(Nodoheap)}%
    \end{Tupla}
  \end{Estructura}

	\begin{Tupla}[Nodoheap]
	\tupItem{elemento}{tupla<id: nat, cantCapt: nat>}%
	\tupItem{padre}{puntero(Nodoheap)}%
	\tupItem{izq}{puntero(Nodoheap)}%
	\tupItem{der}{puntero(Nodoheap)}%
	\end{Tupla}

  \RepFc[estr$/e$]{true}

  ~

  \AbsFc[estr]{coor}[e]{}

\end{Representacion}

\begin{Representacion}
 
  \begin{Estructura}{itHeap(tupla<id: nat, cantCapt: nat>)}[estr]
      \begin{Tupla}[estr]%
      \tupItem{siguiente}{puntero(Nodoheap)}%
      \tupItem{estructura}{puntero(Heap)}%
    \end{Tupla}
  \end{Estructura}

  \RepFc[estr$/e$]{true}

  ~

  \AbsFc[estr]{heap}[e]{}

\end{Representacion}



\begin{Algoritmos}
   
\begin{algorithm}[H]{\textbf{Vacio}() $\to$ $res$ : heap(jugStruct)}
    	\begin{algorithmic}[1]
			 \State $res \gets  <NULL, NULL> $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}
   
\begin{algorithm}[H]{\textbf{Encolar}(\Inout{h}{heap(tupla<id: nat, cantCapt: nat>)}, \In{j}{tupla<id: nat, cantCapt: nat>}) $\to$ $res$ : itHeap(tupla<id: nat, cantCapt: nat>)}
    	\begin{algorithmic}[1]
			 \State $res \gets EncolarElem(h, j) $ \Comment $O(log(EC))$
			 

			\medskip
			\Statex \underline{Complejidad:} $O(log(EC))$
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{EsVacia?}(\In{h}{heap(tupla<id: nat, cantCapt: nat>)}) $\to$ $res$ : bool}
    	\begin{algorithmic}[1]
			 \State $res \gets  h.raiz \not=$ NULL \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{Proximo}(\In{h}{heap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
    		 \State $res \gets (h.raiz \rightarrow elemento)$ \Comment $O(1)$
    		 \medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{Desencolar}(\In{h}{heap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
    		 \State $it \gets CrearIt(h)$ \Comment $O(1)$
		     \State $res \gets Proximo(h)$    		 
    		 \State $Borrar(it)$ \Comment $O(log(EC))$
    		 \medskip
			\Statex \underline{Complejidad:} $O(log(EC))$
    	\end{algorithmic}
\end{algorithm}

\end{Algoritmos}

\begin{Algoritmos}


\begin{algorithm}[H]{\textbf{CrearIt}(\In{h}{heap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : itHeap(tupla$<$id: nat, cantCapt: nat$>$)}
    	\begin{algorithmic}[1]
			 \State $res \gets  <h.ultimo, h> $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{HayPadre?}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : bool}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente \rightarrow padre \not= NULL) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{HayHijoDer?}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : bool}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente \rightarrow der \not= NULL) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{HayHijoIzq?}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : bool}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente \rightarrow izq \not= NULL) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{HayNodo?}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : bool}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente \not= NULL) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{Elemento}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente \rightarrow elemento) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{Elementohijoizq}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente  \rightarrow izq \rightarrow elemento) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{Elementohijoder}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente  \rightarrow der \rightarrow elemento) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{Elementopadre}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente  \rightarrow padre \rightarrow elemento) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}   	
\end{algorithm}

\begin{algorithm}[H]{\textbf{EncolarElem}(\Inout{h}{heap(tupla$<$id: nat, cantCapt: nat$>$)}, \In{j}{tupla$<$id: nat, cantCapt: nat$>$}) $\to$ $res$ : itHeap(tupla$<$id: nat, cantCapt: nat$>$)}
    	\begin{algorithmic}[1]
    	\State $Nodoheap$ n $\gets <j, NULL, NULL, NULL>$ \Comment $O(1)$
    	\State $puntero(Nodoheap)$ p $\gets n$  \Comment $O(1)$
		\State $InsertarAlFinal(h, p)$
		\State $it \gets CrearIt(h)$ \Comment $O(1)$

		\If{$h.raiz \not= h.ultimo$} \Comment $O(1)$
			\State $puntero(Nodo)$ nuevoNodo $\gets h.ultimo$			\Comment $O(1)$
			\While{$((nuevoNodo \rightarrow elemento.cantCapt)$ <\hspace{0.4mm} $(nuevoNodo \rightarrow padre \rightarrow elemento.cantCapt)) \lor (((nuevoNodo \rightarrow elemento.cantCapt)$ = $(nuevoNodo \rightarrow padre \rightarrow elemento.cantCapt)) \implies ((nuevoNodo \rightarrow elemento.id)$ <\hspace{0.4mm} $(nuevoNodo \rightarrow padre \rightarrow elemento.id)))$} \Comment $O(1)$
				\State $Swap(h, nuevoNodo)$ \Comment $O(1)$
						
			\EndWhile
		\EndIf
		\State $res \gets it$ \Comment $O(1)$
			\medskip
			\Statex \underline{Complejidad:} $O(log(EC))$
    	\end{algorithmic}   	
\end{algorithm}

\begin{algorithm}[H]{\textbf{Borrar}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}, \Inout{h}{heap(tupla$<$id: nat, cantCapt: nat$>$)})}
    	\begin{algorithmic}[1]
    		\If{$h.raiz = h.ultimo$}
    			\State $it.siguiente \gets NULL$ \Comment Libera memoria $O(1)$
    			\State $h.raiz \gets NULL$
    			\State $h.ultimo \gets NULL$
    		\Else    		
    			\State $puntero(Nodo)$ cambiado $\gets h.ultimo$
				\State $SwapConElUltimo(h, it.siguiente)$
				\State BORRAR ULTIMO Y REACOMODAR PUNTEROS
				\While {$(cambiado \rightarrow izq) \not= NULL$}
					\State $puntero(Nodoheap) minimo \gets Min(cambiado \rightarrow izq, cambiado \rightarrow der)$
					\If{$((minimo \rightarrow elemento.cantCapt)$ <\hspace{0.4mm} $(cambiado \rightarrow elemento.cantCapt)) \lor (((minimo \rightarrow elemento.cantCapt)$ = $(cambiado \rightarrow elemento.cantCapt)) \implies ((minimo \rightarrow elemento.id)$ <\hspace{0.4mm} $(cambiado elemento.id)))$}
					
					\EndIf					
					\State $cambiado \gets $
				\EndWhile
				\If{$(cambiado \rightarrow der) \not= NULL$}
					\If
					\EndIf
				\EndIf
			\EndIf
			\medskip
			\Statex \underline{Complejidad:} $O(log(EC))$
    	\end{algorithmic}
\end{algorithm}



\begin{algorithm}[H]{\textbf{InsertarAlFinal}(\Inout{h}{heap(tupla$<$id: nat, cantCapt: nat$>$)}, \In{p}{puntero(Nodoheap)})}
    	\begin{algorithmic}[1]
			\If{$EsVacia?(h)$} \Comment $O(1)$
    		\State $h.raiz \gets p$ \Comment $O(1)$
    		\State $h.ultimo \gets p$ \Comment $O(1)$
    	\Else
    		\If{$h.raiz = h.ultimo$} \Comment $O(1)$
    			\State $n.padre \gets h.raiz$ \Comment $O(1)$
    			\State $(h.raiz \rightarrow izq) \gets p$ \Comment $O(1)$
    			\State $h.ultimo \gets p$    \Comment $O(1)$
    		\Else
    			\If{$(h.raiz \rightarrow izq) = h.ultimo$} \Comment $O(1)$
    				\State $n.padre \gets h.raiz$ \Comment $O(1)$
    				\State $(h.raiz \rightarrow der) \gets p$ \Comment $O(1)$
    				\State $h.ultimo \gets p$ \Comment $O(1)$
    			\Else
    				\If{$EsHijoIzquierdo?(h.ultimo)$} \Comment $O(1)$
    					\State $n.padre \gets (h.ultimo \rightarrow padre)$ \Comment $O(1)$
    					\State $(h.ultimo \rightarrow padre \rightarrow der) \gets p$ \Comment $O(1)$
    					\State $h.ultimo \gets p$ \Comment $O(1)$
    				\Else
						\State $puntero(Nodoheap)$ i $\gets h.ultimo$    				 \Comment $O(1)$	
    					\While {$i \not= NULL \land \neg EsHijoIzquierdo?(j)$}
    						\State $i \gets (i \rightarrow padre)$ \Comment $O(1)$
    					
    					\EndWhile
    					\If{$i = NULL$} \Comment $O(1)$
    						\State $puntero(Nodoheap)$ ultimoizq $\gets h.raiz$ \Comment $O(1)$
    						\While {$(ultimoizq \rightarrow izq) \not= NULL$}
    							\State $ultimoizq \gets (ultimoizq \rightarrow izq)$ \Comment $O(1)$
    						\EndWhile
    						\State $n.padre \gets ultimoizqu$ \Comment $O(1)$
    						\State $(ultimoizq \rightarrow izq) \gets p$ \Comment $O(1)$
    						\State $h.ultimo \gets p$ \Comment $O(1)$
    					\Else
    						\State $i \gets (i \rightarrow padre \rightarrow der)$ \Comment $O(1)$
    						\While{$(i \rightarrow izq) \not= NULL$}
    							\State $i \gets (i \rightarrow izq)$ \Comment $O(1)$
    						\EndWhile
    						\State $n.padre \gets i$ \Comment $O(1)$
    						\State $(j \rightarrow izq) \gets p$ \Comment $O(1)$
    						\State $h.ultimo \gets p$ \Comment $O(1)$
    					\EndIf
    				\EndIf		
    			\EndIf	    	
	    	\EndIf
		\EndIf

			\medskip
			\Statex \underline{Complejidad:} $O(log(EC))$
    	\end{algorithmic}   	
\end{algorithm} $ $\newline
$ $\newline
$ $\newline
$ $\newline
$ $\newline
$ $\newline
$ $\newline
$ $\newline
$ $\newline
$ $\newline

{\textbf{Swap}(\Inout{h}{heap(tupla$<$id: nat, cantCapt: nat$>$), \In{nuevoNodo}{puntero(Nodoheap)}})} $ $\newline
$ $\Comment Esta funci\'on es privada y swapea dos nodos cambiando los punteros.
    	\begin{algorithmic}[1]
    		\State $puntero(Nodoheap)$ aSwapear $\gets (nuevoNodo \rightarrow padre)$
    		\If{$h.ultimo = nuevoNodo$}
    			\State $h.ultimo \gets aSwapear$
    		\EndIf
			\If{$EsHijoIzquierdo?(nuevoNodo)$} \Comment $O(1)$
						\If{$(nuevoNodo \rightarrow izq) = NULL$} \Comment $O(1)$
								\State $(aSwapear \rightarrow izq) \gets NULL$ \Comment $O(1)$
							\Else
								\State $(aSwapear \rightarrow izq) \gets (nuevoNodo \rightarrow izq)$ \Comment $O(1)$
								\State $(nuevoNodo \rightarrow izq \rightarrow padre) \gets aSwapear$ \Comment $O(1)$
							\EndIf
							\If{$(nuevoNodo \rightarrow der) = NULL$} \Comment $O(1)$
								\State $(nuevoNodo \rightarrow der) \gets (aSwapear \rightarrow der)$ \Comment $O(1)$
								\If{$(aSwapear \rightarrow der) \not= NULL$} \Comment $O(1)$
								\State $(aSwapear \rightarrow der \rightarrow padre) \gets nuevoNodo$	 \Comment $O(1)$						
								\EndIf
								\State $(aSwapear \rightarrow der) \gets NULL$ \Comment $O(1)$
							\Else
								\If{$(aSwapear \rightarrow der) = NULL$} \Comment $O(1)$
									\State $(aSwapear \rightarrow der) \gets (nodoNuevo \rightarrow der)$ \Comment $O(1)$
									\State $(nodoNuevo \rightarrow der \rightarrow padre) \gets aSwapear$ \Comment $O(1)$
									\State $(nodoNuevo \rightarrow der) \gets NULL$ \Comment $O(1)$
								\Else
									\State $(nodoNuevo \rightarrow der \rightarrow padre) \gets aSwapear$ \Comment $O(1)$
									\State $(aSwapear \rightarrow der \rightarrow padre) \gets nuevoNodo$ \Comment $O(1)$
									\State $puntero(Nodoheap)$ auxiliar $\gets (nuevoNodo \rightarrow der)$ \Comment $O(1)$
									\State $(nuevoNodo \rightarrow der) \gets (aSwapear \rightarrow der)$ \Comment $O(1)$
									\State $(aSwapear \rightarrow der) \gets auxiliar$ \Comment $O(1)$
								\EndIf
							\EndIf
						\State $(nuevoNodo \rightarrow izq) \gets aSwapear$ \Comment $O(1)$
					\Else
						\If{$(nuevoNodo \rightarrow der) = NULL$} \Comment $O(1)$
								\State $(aSwapear \rightarrow der) \gets NULL$ \Comment $O(1)$
							\Else
								\State $(aSwapear \rightarrow der) \gets (nuevoNodo \rightarrow der)$ \Comment $O(1)$
								\State $(nuevoNodo \rightarrow der \rightarrow padre) \gets aSwapear$ \Comment $O(1)$
							\EndIf
							\If{$(nuevoNodo \rightarrow izq) = NULL$} \Comment $O(1)$
								\State $(nuevoNodo \rightarrow izq) \gets (aSwapear \rightarrow izq)$ \Comment $O(1)$
								\If{$(aSwapear \rightarrow izq) \not= NULL$} \Comment $O(1)$
									\State $(aSwapear \rightarrow izq \rightarrow padre) \gets nuevoNodo$	\Comment $O(1)$						
								\EndIf
								\State $(aSwapear \rightarrow izq) \gets NULL$ \Comment $O(1)$
							\Else
								\If{$(aSwapear \rightarrow izq) = NULL$} \Comment $O(1)$
									\State $(aSwapear \rightarrow izq) \gets (nodoNuevo \rightarrow izq)$ \Comment $O(1)$
									\State $(nodoNuevo \rightarrow izq \rightarrow padre) \gets aSwapear$ \Comment $O(1)$
									\State $(nodoNuevo \rightarrow izq) \gets NULL$ \Comment $O(1)$
								\Else
									\State $(nodoNuevo \rightarrow izq \rightarrow padre) \gets aSwapear$ \Comment $O(1)$
									\State $(aSwapear \rightarrow izq \rightarrow padre) \gets nuevoNodo$ \Comment $O(1)$
									\State $puntero(Nodoheap)$ auxiliar $\gets (nuevoNodo \rightarrow izq)$ \Comment $O(1)$
									\State $(nuevoNodo \rightarrow izq) \gets (aSwapear \rightarrow izq)$ \Comment $O(1)$
									\State $(aSwapear \rightarrow izq) \gets auxiliar$ \Comment $O(1)$
								\EndIf
							\EndIf
						\State $(nuevoNodo \rightarrow der) \gets aSwapear$ \Comment $O(1)$
					\EndIf	
					\If{$aSwapear = h.raiz$}					
					\State $(aSwapear \rightarrow padre) \gets nuevoNodo$ \Comment $O(1)$
					\State $h.raiz \gets nuevoNodo$	 \Comment $O(1)$
					\State $(nuevoNodo \rightarrow padre) \gets NULL$			 \Comment $O(1)$
					\Else
					\State $puntero(Nodoheap)$ abuelo $\gets (aSwapear \rightarrow padre)$ \Comment $O(1)$
						\If{$EsHijoIzquierdo?(aSwapear)$} \Comment $O(1)$
							\State $(abuelo \rightarrow izq) \gets nuevoNuevo$ \Comment $O(1)$
							\State $(nuevoNodo \rightarrow padre) \gets abuelo$ \Comment $O(1)$
							\State $(aSwapear \rightarrow padre) \gets nuevoNodo$ \Comment $O(1)$
						\Else
							\State $(abuelo \rightarrow der) \gets nuevoNuevo$ \Comment $O(1)$
							\State $(nuevoNodo \rightarrow padre) \gets abuelo$ \Comment $O(1)$
							\State $(aSwapear \rightarrow padre) \gets nuevoNodo$ \Comment $O(1)$
						\EndIf
					\EndIf
			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}   
    	
 
    	

\end{Algoritmos}