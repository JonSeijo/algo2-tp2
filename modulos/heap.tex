\begin{Interfaz}

  \textbf{se explica con}: \tadNombre{Cola de Prioridad(jugStruct)}.

  \textbf{g\'eneros}: \TipoVariable{heap(tupla<id: nat, cantCapt: nat>)}, \TipoVariable{itheap(jugStruct)}.

  \Title{Operaciones b\'asicas de Heap}


  \InterfazFuncion{Vacia}{}{heap(tupla<id: nat, cantCapt: nat>)}%
  {$res \igobs vacia$}%
  [$O(1)$]
  [genera un nuevo heap]


  \InterfazFuncion{Encolar}{\Inout{h}{heap(tupla<id: nat, cantCapt: nat>)}, \In{j}{tupla<id: nat, cantCapt: nat>}}{itHeap(tupla<id: nat, cantCapt: nat>)}
  [$h \igobs h_{0}$]
  {$h \igobs encolar(h_{0}, j)$}
  [$O(1)$]
  [encola $j$ a $h$]
  [el elemento $j$ se encola por copia, REVISAR PRE Y POS]

  \InterfazFuncion{EsVacia?}{\In{h}{heap(tupla<id: nat, cantCapt: nat>)}}{bool}
  {$res \igobs vacia?(h)$}
  [$O(1)$]
  [devuelve true si la cola es vacia]


  \InterfazFuncion{Proximo}{\In{h}{heap(tupla<id: nat, cantCapt: nat>)}}{tupla<id: nat, cantCapt: nat>}
  [$\neg$ vacia?(h)]  
  {$alias(res \igobs proximo(h))$} 
  [$O(1)$]
  [devuelve el pr\'oximo de la cola]
  [PREGUNTAR ALIASING Y ALIAS]
  
  
  \InterfazFuncion{Desencolar}{\Inout{h}{heap(tupla<id: nat, cantCapt: nat>)}}{}
  [$h \igobs h_{0} \land \neg vacia(h)$ ]  
  {$h \igobs desencolar(h_{0})$} 
  [$O(1)$]
  [desencola el pr\'oximo de h]


  \Title{Operaciones del iterador}
  
   \InterfazFuncion{CrearIt}{\In {h}{heap(tupla<id: nat, cantCapt: nat>)}}{itHeap(tupla<id: nat, cantCapt: nat>)}%
  {$HCER ESTO$}%
  [$O(1)$]
  [crea un iterador unidireccional modificable a la \'ultima posici\'on]
  [el iterador se invalida si se elimina el siguiente sin usar la funcion BORRARSIGUIENTE]
 
 
 \InterfazFuncion{HayPadre?}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{bool}%
  {$HCER ESTO$}
  [$O(1)$]
  [devuelve true si hay padre del elemento]
  
  \InterfazFuncion{HayHijoIzq?}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{bool}%
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve true si hay hijo izquierdo del elemento]
  
  \InterfazFuncion{HayHijoDer?}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{bool}%
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve true si hay hijo derecho del elemento]
  
  \InterfazFuncion{HayNodo?}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>t)}}{bool}%
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve true si hay elementos por recorrer]
  
  \InterfazFuncion{Elemento}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{tupla$<$id: nat, cantCapt: nat$>$}%
  [HayNodo?(it)]
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve el elemento del nodo]
  
  \InterfazFuncion{Elementohijoizq}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{tupla<id: nat, cantCapt: nat>}%
  [HayHijoIzq?(it)]
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve el elemento del hijo izquierdo del nodo]
  
  \InterfazFuncion{Elementohijoder}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{tupla<id: nat, cantCapt: nat>}%
  [HayHijoDer?(it)]
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve el elemento del hijo derecho del nodo]
  
  \InterfazFuncion{Elementopadre}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{tupla<id: nat, cantCapt: nat>}%
  [HayPadre?(it)]
  {$HACER ESTO$}
  [$O(1)$]
  [devuelve el elemento del padre del nodo]
  
  \InterfazFuncion{Borrar}{\In {it}{itHeap(tupla<id: nat, cantCapt: nat>)}}{}%
  [ITERADOR VALIDO]
  {$HACER ESTO$}
  [$O(log(EC))$]
  [Borra el elemento dado]
  
   \InterfazFuncion{EncolarElem}{\Inout {h}{heap(tupla<id: nat, cantCapt: nat>)}, \In {j}{tupla<id: nat, cantCapt: nat>}}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}%
  [ITERADOR VALIDO,]
  {$DEVUELVE ITERADOR VALIDO$}
  [$O(log(EC))$]
  [Encola el elemento dado]


\end{Interfaz}

\begin{Representacion}
 
  \begin{Estructura}{heap(tupla<id: nat, cantCapt: nat>)}[estr]
      \begin{Tupla}[estr]%
      \tupItem{raiz}{puntero(Nodoheap)}%
      \tupItem{ultimo}{puntero(Nodoheap)}%
    \end{Tupla}
  \end{Estructura}

	\begin{Tupla}[Nodoheap]
	\tupItem{elemento}{tupla<id: nat, cantCapt: nat>}%
	\tupItem{padre}{puntero(Nodoheap)}%
	\tupItem{izq}{puntero(Nodoheap)}%
	\tupItem{der}{puntero(Nodoheap)}%
	\end{Tupla}

  \RepFc[estr$/e$]{true}

  ~

  \AbsFc[estr]{coor}[e]{}

\end{Representacion}

\begin{Representacion}
 
  \begin{Estructura}{itHeap(tupla<id: nat, cantCapt: nat>)}[estr]
      \begin{Tupla}[estr]%
      \tupItem{siguiente}{puntero(Nodoheap)}%
      \tupItem{estructura}{puntero(Heap)}%
    \end{Tupla}
  \end{Estructura}

  \RepFc[estr$/e$]{true}

  ~

  \AbsFc[estr]{heap}[e]{}

\end{Representacion}



\begin{Algoritmos}
   
\begin{algorithm}[H]{\textbf{Vacio}() $\to$ $res$ : heap(jugStruct)}
    	\begin{algorithmic}[1]
			 \State $res \gets  <NULL, NULL> $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}
   
\begin{algorithm}[H]{\textbf{Encolar}(\Inout{h}{heap(tupla<id: nat, cantCapt: nat>)}, \In{j}{tupla<id: nat, cantCapt: nat>}) $\to$ $res$ : itHeap(tupla<id: nat, cantCapt: nat>)}
    	\begin{algorithmic}[1]
			 \State $res \gets EncolarElem(h, j) $ \Comment $O(log(EC))$
			 

			\medskip
			\Statex \underline{Complejidad:} $O(log(EC))$
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{EsVacia?}(\In{h}{heap(tupla<id: nat, cantCapt: nat>)}) $\to$ $res$ : bool}
    	\begin{algorithmic}[1]
			 \State $res \gets  h.raiz \not=$ NULL \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{Proximo}(\In{h}{heap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
    		 \State $res \gets (h.raiz \rightarrow elemento)$ \Comment $O(1)$
    		 \medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{Desencolar}(\In{h}{heap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
    		 \State $it \gets CrearIt(h)$ \Comment $O(1)$
		     \State $res \gets Proximo(h)$    		 
    		 \State $Borrar(it)$ \Comment $O(log(EC))$
    		 \medskip
			\Statex \underline{Complejidad:} $O(log(EC))$
    	\end{algorithmic}
\end{algorithm}

\end{Algoritmos}

\begin{Algoritmos}


\begin{algorithm}[H]{\textbf{CrearIt}(\In{h}{heap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : itHeap(tupla$<$id: nat, cantCapt: nat$>$)}
    	\begin{algorithmic}[1]
			 \State $res \gets  <h.ultimo, h> $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{HayPadre?}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : bool}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente \rightarrow padre \not= NULL) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{HayHijoDer?}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : bool}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente \rightarrow der \not= NULL) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{HayHijoIzq?}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : bool}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente \rightarrow izq \not= NULL) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{HayNodo?}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : bool}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente \not= NULL) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{Elemento}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente \rightarrow elemento) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{Elementohijoizq}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente  \rightarrow izq \rightarrow elemento) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{Elementohijoder}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente  \rightarrow der \rightarrow elemento) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{Elementopadre}(\In{it}{itHeap(tupla$<$id: nat, cantCapt: nat$>$)}) $\to$ $res$ : tupla$<$id: nat, cantCapt: nat$>$}
    	\begin{algorithmic}[1]
			 \State $res \gets  (it.siguiente  \rightarrow padre \rightarrow elemento) $ \Comment $O(1)$

			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}   	
\end{algorithm}

\begin{algorithm}[H]{\textbf{EncolarElem}(\Inout{h}{heap(tupla$<$id: nat, cantCapt: nat$>$)}, \In{j}{tupla$<$id: nat, cantCapt: nat$>$}) $\to$ $res$ : itHeap(tupla$<$id: nat, cantCapt: nat$>$)}
    	\begin{algorithmic}[1]
    	\State $Nodoheap$ n $\gets <j, NULL, NULL, NULL>$
    	\State $puntero(Nodoheap)$ p $\gets n$    	
		\State $InsertarAlFinal(h, p)$
		\State $it \gets CrearIt(h)$
		\newpage		
		
		\If{$h.raiz \not= h.ultimo$}
			\State $puntero(Nodo)$ nuevoNodo $\gets h.ultimo$			
			\While{$(nuevoNodo \rightarrow padre) \not=$ NULL}
				\If{$((nuevoNodo \rightarrow elemento.cantCapt)$ <\hspace{0.4mm} $(nuevoNodo \rightarrow padre \rightarrow elemento.cantCapt)) \lor (((nuevoNodo \rightarrow elemento.cantCapt)$ = $(nuevoNodo \rightarrow padre \rightarrow elemento.cantCapt)) \implies ((nuevoNodo \rightarrow elemento.id)$ <\hspace{0.4mm} $(nuevoNodo \rightarrow padre \rightarrow elemento.id)))$}
					\If{$(nuevoNodo \rightarrow padre) = h.raiz$}					
						\State $SwapPadreRaiz(h, nuevoNodo)$
					\Else
						\State $SwapPadre(h, nuevoNodo)$							\EndIf		
				\EndIf
				\State $nuevoNodo \gets (nuevoNodo \rightarrow padre)$
			\EndWhile
		\EndIf
		\State $res \gets it$
			\medskip
			\Statex \underline{Complejidad:} $O(log(EC))$
    	\end{algorithmic}   	
\end{algorithm}

\begin{algorithm}[H]{\textbf{InsertarAlFinal}(\Inout{h}{heap(tupla$<$id: nat, cantCapt: nat$>$)}, \In{p}{puntero(Nodoheap)})}
    	\begin{algorithmic}[1]
			\If{$EsVacia?(h)$}
    		\State $h.raiz \gets p$
    		\State $h.ultimo \gets p$
    	\Else
    		\If{$h.raiz = h.ultimo$}
    			\State $n.padre \gets h.raiz$
    			\State $(h.raiz \rightarrow izq) \gets p$
    			\State $h.ultimo \gets p$   
    		\Else
    			\If{$(h.raiz \rightarrow izq) = h.ultimo$}
    				\State $n.padre \gets h.raiz$
    				\State $(h.raiz \rightarrow der) \gets p$
    				\State $h.ultimo \gets p$
    			\Else
    				\If{$EsHijoIzquierdo?(h.ultimo)$}
    					\State $n.padre \gets (h.ultimo \rightarrow padre)$
    					\State $(h.ultimo \rightarrow padre \rightarrow der) \gets p$
    					\State $h.ultimo \gets p$
    				\Else
						\State $puntero(Nodoheap)$ i $\gets h.ultimo$    					
    					\While {$i \not= NULL \land \neg EsHijoIzquierdo?(j)$}
    						\State $i \gets (i \rightarrow padre)$
    					
    					\EndWhile
    					\If{$i = NULL$}
    						\State $puntero(Nodoheap)$ ultimoizq $\gets h.raiz$
    						\While {$(ultimoizq \rightarrow izq) \not= NULL$}
    							\State $ultimoizq \gets (ultimoizq \rightarrow izq)$
    						\EndWhile
    						\State $n.padre \gets ultimoizqu$
    						\State $(ultimoizq \rightarrow izq) \gets p$
    						\State $h.ultimo \gets p$
    					\Else
    						\State $i \gets (i \rightarrow padre \rightarrow der)$
    						\While{$(i \rightarrow izq) \not= NULL$}
    							\State $i \gets (i \rightarrow izq)$
    						\EndWhile
    						\State $n.padre \gets i$
    						\State $(j \rightarrow izq) \gets p$
    						\State $h.ultimo \gets p$
    					\EndIf
    				\EndIf		
    			\EndIf	    	
	    	\EndIf
		\EndIf

			\medskip
			\Statex \underline{Complejidad:} $O(log(EC))$
    	\end{algorithmic}   	
\end{algorithm}





\begin{algorithm}[H]{\textbf{SwapPadreRaiz}(\Inout{h}{heap(tupla$<$id: nat, cantCapt: nat$>$), \In{nuevoNodo}{puntero(Nodoheap)}})}
    	\begin{algorithmic}[1]
			 \If{$EsHijoIzquierdo?(nuevoNodo)$}
						\State $(nuevoNodo \rightarrow padre) \gets NULL$
							\If{$(nuevoNodo \rightarrow izq) = NULL$}
								\State $(h.raiz \rightarrow izq) \gets NULL$
							\Else
								\State $(h.raiz \rightarrow izq) \gets (nuevoNodo \rightarrow izq)$
								\State $(nuevoNodo \rightarrow izq \rightarrow padre) \gets h.raiz$
							\EndIf
							\If{$(nuevoNodo \rightarrow der) = NULL$}
								\State $(nuevoNodo \rightarrow der) \gets (h.raiz \rightarrow der)$
								\If{$(h.raiz \rightarrow der) \not= NULL$}
									\State $(h.raiz \rightarrow der \rightarrow padre) \gets nuevoNodo$							
								\EndIf
								\State $(h.raiz \rightarrow der) \gets NULL$
							\Else
								\If{$(h.raiz \rightarrow der) = NULL$}
									\State $(h.raiz \rightarrow der) \gets (nodoNuevo \rightarrow der)$
									\State $(nodoNuevo \rightarrow der \rightarrow padre) \gets h.raiz$
									\State $(nodoNuevo \rightarrow der) \gets NULL$
								\Else
									\State $(nodoNuevo \rightarrow der \rightarrow padre) \gets h.raiz$
									\State $(h.raiz \rightarrow der \rightarrow padre) \gets nuevoNodo$
									\State $puntero(Nodoheap)$ auxiliar $\gets (nuevoNodo \rightarrow der)$
									\State $(nuevoNodo \rightarrow der) \gets (h.raiz \rightarrow der)$
									\State $(h.raiz \rightarrow der) \gets auxiliar$
								\EndIf
							\EndIf
						\State $(h.raiz \rightarrow padre) \gets nuevoNodo$
						\State $(nuevoNodo \rightarrow izq) \gets h.raiz$
						\State $h.raiz \gets nuevoNodo$								\Else	
					\EndIf					
			\medskip
			\Statex \underline{Complejidad:} $O(1)$
    	\end{algorithmic}   	
\end{algorithm}

\end{Algoritmos}